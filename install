#!/usr/bin/env bash

#####################################
# GENERATED FILE FROM https://github.com/fchastanet/bash-dev-env/tree/master/tree/master/src/engine/install.sh
# DO NOT EDIT IT
#####################################

# shellcheck disable=SC2034
SCRIPT_NAME=${0##*/}
REAL_SCRIPT_FILE="$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")"
# shellcheck disable=SC2034
CURRENT_DIR="$(cd "$(readlink -e "${REAL_SCRIPT_FILE%/*}")" && pwd -P)"
BIN_DIR="${CURRENT_DIR}"
ROOT_DIR="$(cd "${BIN_DIR}/" && pwd -P)"
# shellcheck disable=SC2034
SRC_DIR="${ROOT_DIR}/src"
# shellcheck disable=SC2034
VENDOR_DIR="${ROOT_DIR}/vendor"
# shellcheck disable=SC2034
VENDOR_BIN_DIR="${ROOT_DIR}/vendor/bin"
export PATH="${BIN_DIR}":"${VENDOR_BIN_DIR}":${PATH}

# shellcheck disable=SC2034
TMPDIR="$(mktemp -d -p "${TMPDIR:-/tmp}" -t bash-framework-$$-XXXXXX)"
export TMPDIR

# temp dir cleaning
cleanOnExit() {
  rm -Rf "${TMPDIR}" >/dev/null 2>&1
}
trap cleanOnExit EXIT HUP QUIT ABRT TERM

# @see https://unix.stackexchange.com/a/386856
interruptManagement() {
  # restore SIGINT handler
  trap - INT
  # ensure that Ctrl-C is trapped by this script and not by sub process
  # report to the parent that we have indeed been interrupted
  kill -s INT "$$"
}
trap interruptManagement INT

# shellcheck disable=SC2034
((failures = 0)) || true

shopt -s expand_aliases

# Bash will remember & return the highest exit code in a chain of pipes.
# This way you can catch the error inside pipes, e.g. mysqldump | gzip
set -o pipefail
set -o errexit

# a log is generated when a command fails
set -o errtrace

# use nullglob so that (file*.php) will return an empty array if no file matches the wildcard
shopt -s nullglob

export TERM=xterm-256color

#avoid interactive install
export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true

if [[ -t 1 || -t 2 ]]; then
  # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
  readonly __ERROR_COLOR='\e[31m'      # Red
  readonly __INFO_COLOR='\e[44m'       # white on lightBlue
  readonly __SUCCESS_COLOR='\e[32m'    # Green
  readonly __WARNING_COLOR='\e[33m'    # Yellow
  readonly __TEST_COLOR='\e[100m'      # Light magenta
  readonly __TEST_ERROR_COLOR='\e[41m' # white on red
  readonly __SKIPPED_COLOR='\e[33m'    # Yellow
  readonly __HELP_COLOR='\e[7;49;33m'  # Black on Gold
  readonly __DEBUG_COLOR='\e[37m'      # Grey
  # Internal: reset color
  readonly __RESET_COLOR='\e[0m' # Reset Color
  # shellcheck disable=SC2155,SC2034
  readonly __HELP_EXAMPLE="$(echo -e "\e[1;30m")"
  # shellcheck disable=SC2155,SC2034
  readonly __HELP_TITLE="$(echo -e "\e[1;37m")"
  # shellcheck disable=SC2155,SC2034
  readonly __HELP_NORMAL="$(echo -e "\033[0m")"
else
  # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
  readonly __ERROR_COLOR=''
  readonly __INFO_COLOR=''
  readonly __SUCCESS_COLOR=''
  readonly __WARNING_COLOR=''
  readonly __SKIPPED_COLOR=''
  readonly __HELP_COLOR=''
  readonly __TEST_COLOR=''
  readonly __TEST_ERROR_COLOR=''
  readonly __DEBUG_COLOR=''
  # Internal: reset color
  readonly __RESET_COLOR=''
  readonly __HELP_EXAMPLE=''
  readonly __HELP_TITLE=''
  readonly __HELP_NORMAL=''
fi
export __ERROR_COLOR
export __INFO_COLOR
export __SUCCESS_COLOR
export __WARNING_COLOR
export __SKIPPED_COLOR
export __TEST_COLOR
export __TEST_ERROR_COLOR
export __SKIPPED_COLOR
export __HELP_COLOR
export __DEBUG_COLOR
export __RESET_COLOR
export __HELP_EXAMPLE
export __HELP_TITLE
export __HELP_NORMAL

# Public: exits with message if current user is root
#
# **Exit**: code 1 if current user is root
Assert::expectNonRootUser() {
  if [[ "$(id -u)" = "0" ]]; then
    Log::fatal "The script must not be run as root"
  fi
}

engine::config::check() {
  local envFile="$1"

  # check if ubuntu
  # load environment variables ID, VERSION_CODENAME
  engine::config::loadOsRelease
  if ! echo "${ID}" | grep -qEw 'debian|ubuntu'; then
    Log::fatal "This script is built to support only Debian or Ubuntu distributions. You are using ${ID}."
  fi

  ((errorCount = 0)) || true
  # shellcheck disable=SC2153
  if ! Assert::varExistsAndNotEmpty "USER_NAME"; then
    ((errorCount++))
  elif ! getent passwd "${USER_NAME}" 2>/dev/null >/dev/null; then
    Log::displayError "USER_NAME - user '${USER_NAME}' does not exist"
    ((errorCount++))
  fi

  # GIT_USER_NAME
  if ! Assert::varExistsAndNotEmpty "GIT_USER_NAME"; then
    ((errorCount++))
  elif ! Assert::firstNameLastName "${GIT_USER_NAME}"; then
    Log::displayError "GIT_USER_NAME - invalid format, expected : firstName lastName"
    ((errorCount++))
  fi

  # GIT_USER_MAIL
  if ! Assert::varExistsAndNotEmpty "GIT_USER_MAIL"; then
    ((errorCount++))
  elif ! Assert::emailAddress "${GIT_USER_MAIL}"; then
    Log::displayError "GIT_USER_MAIL: invalid email address"
    ((errorCount++))
  fi

  # PROJECTS_DIR
  if ! Assert::varExistsAndNotEmpty "PROJECTS_DIR"; then
    ((errorCount++))
  elif [[ ! -d "${PROJECTS_DIR}" ]]; then
    if ! mkdir -p "${PROJECTS_DIR}"; then
      Log::displayError "PROJECTS_DIR - impossible to create the directory '${PROJECTS_DIR}'"
      ((errorCount++))
    fi
  fi

  # CONF_DIR
  if ! Assert::varExistsAndNotEmpty "CONF_DIR"; then
    ((errorCount++))
  elif [[ ! -d "${CONF_DIR}" ]]; then
    Log::displayError "CONF_DIR - directory does not exist '${CONF_DIR}'"
    ((errorCount++))
  elif [[ ! -r "${CONF_DIR}" ]]; then
    Log::displayError "CONF_DIR - directory '${CONF_DIR}' is not accessible"
    ((errorCount++))
  fi

  # INSTALL_SCRIPTS_DIR
  if ! Assert::varExistsAndNotEmpty "INSTALL_SCRIPTS_DIR"; then
    ((errorCount++))
  elif [[ ! -d "${INSTALL_SCRIPTS_DIR}" ]]; then
    Log::displayError "INSTALL_SCRIPTS_DIR - directory does not exist '${INSTALL_SCRIPTS_DIR}'"
    ((errorCount++))
  elif [[ ! -r "${INSTALL_SCRIPTS_DIR}" ]]; then
    Log::displayError "INSTALL_SCRIPTS_DIR - directory '${INSTALL_SCRIPTS_DIR}' is not accessible"
    ((errorCount++))
  fi

  # BACKUP_DIR
  if ! Assert::varExistsAndNotEmpty "BACKUP_DIR"; then
    ((errorCount++))
  elif [[ ! -d "${BACKUP_DIR}" ]]; then
    mkdir -p "${BACKUP_DIR}" || Log::displayError "BACKUP_DIR - backup dir ${BACKUP_DIR} cannot be created"
    ((errorCount++))
  elif [[ ! -w "${BACKUP_DIR}" ]]; then
    Log::displayError "BACKUP_DIR - backup dir ${BACKUP_DIR} is not writable"
    ((errorCount++))
  fi

  if ((errorCount > 0)); then
    Log::displayError "one or more variables are invalid, check above logs and fix ${envFile} file accordingly"
    return 1
  fi
}

envTemplate="$(
  cat <<'EOF'
  #!/bin/bash
  # shellcheck disable=SC2034
  # wsl username
  USER_NAME="wsl"
  USER_HOME="/home/wsl"

  # your git full name 'FirstName LastName'
  GIT_USER_NAME=""
  # email used for git 'ldap@domain.com'
  GIT_USER_MAIL=""

  # conf files that will be used to configure the different tools
  CONF_DIR="${ROOT_DIR}/conf"

  # conf files that will be used to configure the different tools
  # some tools configuration will use CONF_DIR as template and
  # copy files into this directory
  CONF_OVERRIDE_DIR="${ROOT_DIR}/conf.override"

  # where to install bash-tools, ...
  PROJECTS_DIR="${USER_HOME}/projects"

  # where overridden config files will be backed up
  BACKUP_DIR="${ROOT_DIR}/backup"
  # logs CONF_DIR
  LOGS_DIR="${ROOT_DIR}/logs"
  # installScripts dir
  INSTALL_SCRIPTS_DIR="${ROOT_DIR}/installScripts"

  # 0   => no upgrade at all
  # lts => UPGRADE to latest ubuntu lts version
  # dev => UPGRADE to latest ubuntu dev version
  # Use if you know what you are doing,
  # could cause some packages to not being available yet
  UPGRADE_UBUNTU_VERSION=0

  # -----------------------------------------
  # PROFILES options

  # Choose your AWS authenticator tool
  # possible choices: Saml2Aws, Awsume
  AWS_AUTHENTICATOR="Saml2Aws"

  # Choose your preferred shell
  # possible choices: BashProfile (Legacy experience), ZshProfile (Recommended experience)
  PREFERRED_SHELL="BashProfile"

  # Display Fortune tooltip at bash/zsh session open
  SHOW_FORTUNES=1

  # Display MOTD at bash/zsh session open
  SHOW_MOTD=1

  # Install Docker inside wsl
  DOCKER_INSIDE_WSL=1

  # Configuration files are overwritten even if exists
  # !!!! First time initialization: let this value to 1 !!!!
  # Value 0:
  # - If target configuration file exists, displays a message and do not overwrite the file
  # - If target configuration file doesn't exist, installs the file
  # Value 1
  # - install or overwrite the file without checking existence
  OVERWRITE_CONFIG_FILES=1

  # Windows files can be overridden if 1
  # if 0
  # - skip changes to %USERPROFILE%/.wslconfig
  # - skip copying fonts
  CHANGE_WINDOWS_FILES=1

  # Indicate that install script can warn you using speaker when your input is needed
  CAN_TALK_DURING_INSTALLATION=1

  # if 1 install script will skip all interactive activity (saml2aws, ...),
  # so dependent installation will be skipped as well
  NON_INTERACTIVE=0

  # -----------------------------------------
  # WSLCONFIG - these parameters will help to automatically
  # configure %USERPROFILE%/.wslconfig file
  # Adjust these values to your needs
  # @see https://docs.microsoft.com/en-us/windows/wsl/wsl-config
  # Recommended 50% of total memory
  WSLCONFIG_MAX_MEMORY=8GB
  # personally I prefer run out of memory instead of beginning swapping
  # So I know immediately if some processes have to be stopped
  WSLCONFIG_SWAP=0

  # -----------------------------------------
  # Hacks
  # on some configurations we have to force path of some windows commands
  #POWERSHELL_BIN=/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe
  #IPCONFIG_BIN=/mnt/c/Windows/system32/ipconfig.exe
  #WSL_EXE_BIN=/mnt/c/Windows/system32/wsl.exe
EOF
)"

engine::config::checkConfigExist() {
  local envFile="$1"

  if [[ ! -f "${envFile}" ]]; then
    echo "${envTemplate}" >"${envFile}"
    Log::displayError "a default env file has been created, please edit ${envFile}"
    return 1
  fi
}

# set sudoer without password temporarily
engine::config::createSudoerFile() {
  local sudoerFile="/etc/sudoers.d/${USER_NAME}-bash-dev-env-no-password"

  # create /etc/sudoers.d/userName-bash-dev-env
  SUDOER_CHANGE="${USER_NAME} ALL=(ALL) NOPASSWD: ${ROOT_DIR}/install,/etc/cron.weekly/upgrade,/usr/sbin/service,${ROOT_DIR}/scripts/*/configure"
  if [[ "${SUDOER_CHANGE}" != "$(sudo cat "${sudoerFile}" 2>/dev/null || echo -n '')" ]]; then
    echo "${SUDOER_CHANGE}" | sudo tee "${sudoerFile}"
    sudo chmod 0440 "${sudoerFile}"

    echo "this file indicates that sudo has been configured to execute without password" |
      sudo tee "${USER_HOME}/.cron_activated" >/dev/null

    sudo visudo -c -s || {
      Log::displayError "Please check syntax of '${sudoerFile}' before closing this session - 'sudo visudo'"
      return 1
    }
  fi
}

engine::config::loadConfig() {
  local envFile="$1"

  # shellcheck source=/.env.template
  source "${envFile}"

  export USER_NAME
  export GIT_USER_NAME
  export GIT_USER_MAIL
  export CONF_DIR
  export CONF_OVERRIDE_DIR
  export PROJECTS_DIR
  export BACKUP_DIR
  export LOGS_DIR
  export SCRIPTS_DIR
  export UPGRADE_UBUNTU_VERSION
  export AWS_AUTHENTICATOR
  export PREFERRED_SHELL
  export SHOW_FORTUNES
  export SHOW_MOTD
  export DOCKER_INSIDE_WSL
  export OVERWRITE_CONFIG_FILES
  export CHANGE_WINDOWS_FILES
  export CAN_TALK_DURING_INSTALLATION
  export NON_INTERACTIVE
  export WSLCONFIG_MAX_MEMORY
  export WSLCONFIG_SWAP
  export POWERSHELL_BIN

  engine::config::loadUserVariables
}

engine::config::loadHostIp() {
  HOST_IP="$(/sbin/ip route | awk '/default/ { print $3 }')"

  export HOST_IP
}

engine::config::loadWslVariables() {
  if ! Assert::wsl; then
    # skip
    return 0
  fi

  # shellcheck disable=SC1003
  BASE_MNT_C="$(mount | grep 'path=C:\\' | awk -F ' ' '{print $3}')"

  # TODO default value if not found or wslpath not working
  WINDOWS_DIR="$(Wsl::cachedWslpathFromWslVar SystemRoot "${WINDOWS_DIR:-${BASE_MNT_C}/Windows}")"
  export WINDOWS_DIR

  WINDOWS_PROFILE_DIR="$(Wsl::cachedWslpathFromWslVar USERPROFILE "${WINDOWS_PROFILE_DIR:-${BASE_MNT_C}/Users/$(id -un)}")"
  export WINDOWS_PROFILE_DIR

  # POWERSHELL_BIN
  if [[ -z "${POWERSHELL_BIN+xxx}" ]]; then
    POWERSHELL_BIN="${WINDOWS_DIR}/System32/WindowsPowerShell/v1.0/powershell.exe"
    if ! command -v "${POWERSHELL_BIN}" >/dev/null 2>&1; then
      POWERSHELL_BIN="$(command -v powershell.exe 2>/dev/null)"
    fi
  fi
  if ! command -v "${POWERSHELL_BIN}" >/dev/null 2>&1; then
    Log::fatal "command powershell.exe not found"
  fi
  export POWERSHELL_BIN

  # Deduce wsl.exe path
  if [[ -z "${WSL_EXE_BIN+xxx}" ]]; then
    WSL_EXE_BIN="${WINDOWS_DIR}/system32/wsl.exe"
    if ! command -v "${WSL_EXE_BIN}" >/dev/null 2>&1; then
      WSL_EXE_BIN="$(command -v wsl.exe 2>/dev/null)"
    fi
  fi
  if ! command -v "${WSL_EXE_BIN}" >/dev/null 2>&1; then
    Log::fatal "command wsl.exe not found"
  fi
  export WSL_EXE_BIN

  # IPCONFIG_BIN - which ipconfig.exe does not work when executed as root
  if [[ -z "${IPCONFIG_BIN+xxx}" ]]; then
    IPCONFIG_BIN="${WINDOWS_DIR}/system32/ipconfig.exe"
    if ! command -v "${IPCONFIG_BIN}" >/dev/null 2>&1; then
      IPCONFIG_BIN="$(command -v ipconfig.exe 2>/dev/null)"
    fi
  fi
  if ! command -v "${IPCONFIG_BIN}" >/dev/null 2>&1; then
    Log::fatal "command ipconfig.exe not found"
  fi
  export IPCONFIG_BIN
}

engine::install::showHelp() {
  local description="$1"

  profilesList="$(Conf::list "${ROOT_DIR}" "profile." ".sh" "-type f" "" |
    paste -s -d ',' | sed -e 's/,/, /g' || true)"
  softwaresList="$(Conf::list "${ROOT_DIR}/installScripts" "" "" "-mindepth 1 -type d" "" |
    grep -v -E '^(_.*|MandatorySoftwares)$' | paste -s -d ',' | sed -e 's/,/, /g' || true)"
  cat <<EOF
${__HELP_TITLE}Description:${__HELP_NORMAL} ${description}

${__HELP_TITLE}Usage:${__HELP_NORMAL} ${SCRIPT_NAME} --help prints this help and exits
${__HELP_TITLE}Usage:${__HELP_NORMAL} ${SCRIPT_NAME} [--skip-install] [--skip-configure] [--skip-test] [--prepare-export] -p|--profile <profile>
${__HELP_TITLE}Usage:${__HELP_NORMAL} ${SCRIPT_NAME} [--skip-install] [--skip-configure] [--skip-test] [--prepare-export] [--skip-dependencies] <Software>

    -p|--profile profileName    the name of the profile to use that indicates configuration to run
    --skip-install              skip softwares installation
    --skip-configure            skip softwares configuration
    --skip-test                 skip softwares tests
    --prepare-export            prepare the wsl image for export (remove all sensitive files)
    --skip-dependencies         install the software requested without resolving dependencies

${__HELP_TITLE}List of available softwares:${__HELP_NORMAL}
${softwaresList}

${__HELP_TITLE}List of available profiles:${__HELP_NORMAL}
${profilesList}

${__HELP_TITLE}Author:${__HELP_NORMAL}
[François Chastanet](https://github.com/fchastanet)

${__HELP_TITLE}Source file:${__HELP_NORMAL}
https://github.com/fchastanet/bash-dev-env/tree/master/tree/master/src/engine/install.sh

${__HELP_TITLE}License:${__HELP_NORMAL}
MIT License

Copyright (c) 2022 François Chastanet
EOF
}

# Public: log level off
export __LEVEL_OFF=0
# Public: log level error
export __LEVEL_ERROR=1
# Public: log level warning
export __LEVEL_WARNING=2
# Public: log level info
export __LEVEL_INFO=3
# Public: log level success
export __LEVEL_SUCCESS=3
# Public: log level debug
export __LEVEL_DEBUG=4

export __LEVEL_OFF
export __LEVEL_ERROR
export __LEVEL_WARNING
export __LEVEL_INFO
export __LEVEL_SUCCESS
export __LEVEL_DEBUG

# Display message using error color (red)
# @param {String} $1 message
Log::displayError() {
  echo -e "${__ERROR_COLOR}ERROR   - ${1}${__RESET_COLOR}" >&2
  Log::logError "$1"
}

# Display message using info color (bg light blue/fg white)
# @param {String} $1 message
Log::displayInfo() {
  echo -e "${__INFO_COLOR}INFO    - ${1}${__RESET_COLOR}" >&2
  Log::logInfo "$1"
}

# Display message using success color (bg green/fg white)
# @param {String} $1 message
Log::displaySuccess() {
  echo -e "${__SUCCESS_COLOR}SUCCESS - ${1}${__RESET_COLOR}" >&2
  Log::logSuccess "$1"
}

# Display message using error color (red) and exit immediately with error status 1
# @param {String} $1 message
Log::fatal() {
  echo -e "${__ERROR_COLOR}FATAL   - ${1}${__RESET_COLOR}" >&2
  Log::logFatal "$1"
  exit 1
}

Log::headLine() {
  local type="$1"
  local message
  message="$(UI::textLine "${type}" " ")"
  echo -e "${__TEST_COLOR}${message}${__RESET_COLOR}"
}

# To be called before logging in the log file
# @param $1 log file name
# @param $2 maximum number of log files
Log::rotate() {
  local FILENAME="$1"
  local MAX_LOG="${2:-5}"
  for i in $(seq $((MAX_LOG - 1)) -1 1); do
    Log::displayInfo "Log rotation ${FILENAME}.${i} to ${FILENAME}.$((i + 1))"
    mv "${FILENAME}."{"${i}","$((i + 1))"} &>/dev/null || true
  done
  if mv "${FILENAME}" "${FILENAME}.1" &>/dev/null; then
    Log::displayInfo "Log rotation ${FILENAME} to ${FILENAME}.1"
  fi
}

declare -Ag allDepsResultSeen=()
declare -ag allDepsResult=()

Profiles::allDepsRecursive() {
  local scriptsDir="$1"
  local parent="$2"
  shift 2 || true
  local i
  local addDep=0
  local -a deps=()
  local -a newDeps

  for i in "$@"; do
    if [[ "${allDepsResultSeen["${i}"]}" = 'stored' ]]; then
      continue
    fi
    if [[ ! -f "${scriptsDir}/${i}.sh" ]]; then
      Log::fatal "Dependency ${i} doesn't exist"
    fi
    # shellcheck source=/src/Profiles/testsData/lintDefinitions/OK/Install1.sh
    source "${scriptsDir}/${i}.sh"

    if [[ "$(type -t "installScripts_${i}_dependencies")" != "function" ]]; then
      Log::displaySkipped "${scriptsDir}/${i}.sh does not define the function installScripts_${i}_dependencies"
      continue
    fi
    if [[ -z "${allDepsResultSeen[${i}]+exists}" ]]; then
      addDep=1
      allDepsResultSeen["${i}"]='stored'
    fi
    readarray -t newDeps < <("installScripts_${i}_dependencies")
    deps+=("${newDeps[@]}")
    # remove duplicates from deps preserving order
    mapfile -t deps < <(
      IFS=$'\n'
      echo "${deps[@]}" | awk '!x[$0]++'
    )
    if ((${#newDeps} > 0)); then
      Profiles::allDepsRecursive "${scriptsDir}" "${i}" "${newDeps[@]}"
    fi
    if [[ "${addDep}" = "1" ]]; then
      Log::displayInfo "${i} is a dependency of ${parent}"
      allDepsResult+=("${i}")
    fi
    addDep=0
  done
}

Profiles::checkScriptsExistence() {
  local scriptsDir="$1"
  local extension="$2"
  shift 2 || true

  for i in "$@"; do
    if [[ ! -f "${scriptsDir}/${i}${extension}" ]]; then
      Log::fatal "script ${i} doesn't exist"
    fi
  done
}

Profiles::loadProfile() {
  local profileDir="$1"
  local profile="$2"
  local -a CONFIG_LIST=()

  if [[ -z "${profile}" || -z "${profileDir}" ]]; then
    Log::displayError "This method needs exactly 2 parameters"
    return 1
  fi

  # load the profile
  Log::displayInfo "Loading profile '${profileDir}/profile.${profile}.sh'"
  if [[ ! -f "${profileDir}/profile.${profile}.sh" ]]; then
    Log::fatal "profile profile.${profile}.sh not found in '${profileDir}'"
  fi

  # shellcheck source=src/Profiles/testsData/profile.test1.sh
  source "${profileDir}/profile.${profile}.sh"

  if [[ ! -v CONFIG_LIST ]]; then
    Log::fatal "Profile ${profileDir}/profile.${profile}.sh missing variable CONFIG_LIST"
  fi
  if [[ ${#CONFIG_LIST[@]} -eq 0 ]]; then
    Log::fatal "Profile ${profileDir}/profile.${profile}.sh variable CONFIG_LIST cannot be empty"
  fi

  # remove duplicates from profile preserving order
  mapfile -t CONFIG_LIST < <(
    IFS=$'\n' printf '%s\n' "${CONFIG_LIST[@]}" | awk '!x[$0]++'
  )
  printf '%s\n' "${CONFIG_LIST[@]}"
}

stats::aggregateStats() {
  local statFile="$1"
  local aggregateStatFile="$2"

  (
    if [[ ! -f "${aggregateStatFile}" ]]; then
      (
        echo "count=0"
        echo "error=0"
        echo "warning=0"
        echo "skipped=0"
        echo "help=0"
        echo "success=0"
        echo "duration=0"
        echo "statusSuccess=0"
      ) >"${aggregateStatFile}"
    fi
    if [[ ! -f "${statFile}" ]]; then
      return 0
    fi

    # shellcheck source=src/stats/logStats.example
    source "${statFile}"
    local newError="${error}"
    local newWarning="${warning}"
    local newSkipped="${skipped}"
    local newHelp="${help}"
    local newSuccess="${success}"
    local newDuration="${duration}"
    local newStatus="${status}"

    # shellcheck source=src/stats/aggregateStats.example
    source "${aggregateStatFile}"

    ((count++)) || true
    if ((newStatus == 0)); then
      ((statusSuccess++)) || true
    fi
    if ((newError > 0)); then
      ((error++)) || true
    fi
    if ((newWarning > 0)); then
      ((warning++)) || true
    fi
    if ((newSkipped > 0)); then
      ((skipped++)) || true
    fi
    if ((newHelp > 0)); then
      ((help++)) || true
    fi
    if ((newSuccess > 0)); then
      ((success++)) || true
    fi
    ((duration = duration + newDuration)) || true
    (
      echo "count=${count}"
      echo "error=${error}"
      echo "warning=${warning}"
      echo "skipped=${skipped}"
      echo "help=${help}"
      echo "success=${success}"
      echo "duration=${duration}"
      echo "statusSuccess=${statusSuccess}"
    ) >"${aggregateStatFile}"
  )
}

stats::aggregateStatsSummary() {
  local msg="$1"
  local aggregateStatFile="$2"
  local appCount="$3"
  if [[ ! -f "${aggregateStatFile}" ]]; then
    return 0
  fi

  (
    # shellcheck source=src/stats/aggregateStats.example
    source "${aggregateStatFile}"

    echo -e "${__SUCCESS_COLOR}${count}${__RESET_COLOR} / ${__INFO_COLOR}${appCount}${__RESET_COLOR} ${msg} executed"
    echo -e " - ${__ERROR_COLOR}${error} ${msg} with error${__RESET_COLOR}"
    echo -e " - ${__SKIPPED_COLOR}${skipped} partial ${msg} (check logs marked as skipped)${__RESET_COLOR}"
    echo -e " - ${__WARNING_COLOR}${warning} ${msg} with warning${__RESET_COLOR}"
    echo -e " - ${__INFO_COLOR}Duration: ${duration}s${__RESET_COLOR}"
  )
}

stats::logRecapitulative() {
  local logFile="$1"

  local logRecapitulativeAwkScript
  logRecapitulativeAwkScript="$(
    cat <<'EOF'
BEGIN {
  currentProcessLogs = ""
  currentContainsLogs = 0
}
{
  buffer = substr($0, 1, 150)
  if(match(buffer, /PROCESS - Processing ([^ ]+) \([0-9]+\/[0-9]+\)/, arr) != 0) {
    processNameName = arr[1]

    currentProcessLogs = currentProcessLogs "\033[44m--- Process " processNameName " ---\033[0m\n"
  } else if(match(buffer, /(ERROR|SKIPPED|WARN|HELP|FATAL)[ ]+- /, arr) != 0) {
    currentContainsLogs = 1
    currentProcessLogs = currentProcessLogs $0 "\n"
  }
}
END {
  if (currentContainsLogs == 1) {
    printf currentProcessLogs
  }
}
EOF
  )"

  if [[ -f "${logFile}" ]]; then
    awk --source "${logRecapitulativeAwkScript}" "${logFile}" | uniq
  fi
}

# draw a line with the character passed in parameter repeated depending on terminal width
# @param {String} $1 character to use as separator (default value #)
UI::drawLine() {
  local character="${1:-#}"
  printf '%*s\n' "${COLUMNS:-$([[ -t 0 ]] && tput cols || echo)}" '' | tr ' ' "${character}"
}

# check if param is valid email address
# @param $1 the full email address
# @return 1 on error
Assert::emailAddress() {
  local email expectedRegexp
  email="$1"
  expectedRegexp="^\S+@\S+$"

  [[ "${email}" =~ ${expectedRegexp} ]]
}

Assert::firstNameLastName() {
  local regexp
  regexp="^[^ ]+ ([^ ]+[ ]?)+$"
  [[ $1 =~ ${regexp} ]]
}

Assert::varExistsAndNotEmpty() {
  local varName="$1"
  if ! Assert::validVariableName "${varName}"; then
    Log::displayError "${varName} - invalid variable name"
    return 3
  fi
  if [[ -z "${!varName+unset}" ]]; then
    Log::displayError "${varName} - not defined"
    return 1
  elif [[ -z "${!varName}" ]]; then
    Log::displayError "${varName} - please provide a value"
    return 2
  fi
}

# Public: determine if the script is executed under WSL
#
# @return 1 on error
Assert::wsl() {
  if grep -qEi "(Microsoft|WSL)" /proc/version &>/dev/null; then
    return 0
  else
    return 1
  fi
}

# Public: list files of dir with given extension and display it as a list one by line
#
# @param {String} dir $1 the directory to list
# @param {String} prefix $2 the profile file prefix (default: "")
# @param {String} ext $3 the extension
# @param {String} findOptions $4 find options, eg: -type d
# @paramDefault {String} findOptions $4 '-type f'
# @param {String} indentStr $5 the indentation can be any string compatible with sed not containing any /
# @paramDefault {String} indentStr $5 '       - '
# @output list of files without extension/directory
# eg:
#       - default.local
#       - default.remote
#       - localhost-root
# @return 1 if directory does not exists
Conf::list() {
  local dir="$1"
  local prefix="${2:-}"
  local ext="${3}"
  local findOptions="${4--type f}"
  local indentStr="${5-       - }"

  if [[ ! -d "${dir}" ]]; then
    Log::displayError "Directory ${dir} does not exist"
  fi
  if [[ -n "${ext}" && "${ext:0:1}" != "." ]]; then
    ext=".${ext}"
  fi
  (
    # shellcheck disable=SC2086
    cd "${dir}" &&
      find . -maxdepth 1 ${findOptions} -name "${prefix}*${ext}" |
      sed -E "s#^\./${prefix}##g" |
        sed -E "s#${ext}\$##g" | sort | sed -E "s#^#${indentStr}#"
  )
}

engine::config::loadOsRelease() {
  if [[ ! -f /etc/os-release ]]; then
    Log::displayError "file /etc/os-release does not exists"
    return 1
  fi
  # This will load environment variables ID, VERSION_CODENAME
  source /etc/os-release
  export NAME
  export VERSION
  export ID
  export ID_LIKE
  export PRETTY_NAME
  export VERSION_ID
  export HOME_URL
  export SUPPORT_URL
  export BUG_REPORT_URL
  export PRIVACY_POLICY_URL
  export VERSION_CODENAME
  export UBUNTU_CODENAME
}

engine::config::loadUserVariables() {
  # deduce user home and group
  # shellcheck disable=SC2153
  USER_HOME="$(getent passwd "${USER_NAME}" | cut -d: -f6)"
  USER_ID="$(getent passwd "${USER_NAME}" | cut -d: -f3)"
  USER_GROUP_ID="$(getent passwd "${USER_NAME}" | cut -d: -f4)"
  USER_GROUP="$(getent group "${USER_GROUP_ID}" | cut -d: -f1)"

  if [[ -z "${USER_GROUP}" || -z "${USER_HOME}" ]]; then
    Log::displayError "USER_NAME - unable to deduce USER_GROUP, USER_HOME from USER_NAME"
    return 1
  fi

  export USER_HOME
  export USER_ID
  export USER_GROUP_ID
  export USER_GROUP
}

# lazy initialization
declare -g BASH_FRAMEWORK_INITIALIZED="0"
declare -g BASH_FRAMEWORK_CACHED_ENV_FILE
declare -g BASH_FRAMEWORK_DEFAULT_ENV_FILE

# load variables in order(from less specific to more specific) from :
# - ${ROOT_DIR}/src/Env/testsData/.env file
# - ${ROOT_DIR}/conf/.env file if exists
# - ~/.env file if exists
# - ~/.bash-tools/.env file if exists
# - BASH_FRAMEWORK_ENV_FILEPATH=<fullPathToEnvFile or empty if no file to be loaded>
Env::load() {
  if [[ "${BASH_FRAMEWORK_INITIALIZED}" = "1" ]]; then
    return 0
  fi
  BASH_FRAMEWORK_CACHED_ENV_FILE="$(mktemp -p "${TMPDIR:-/tmp}" -t "env_vars.XXXXXXX")"
  BASH_FRAMEWORK_DEFAULT_ENV_FILE="$(mktemp -p "${TMPDIR:-/tmp}" -t "default_env_file.XXXXXXX")"
  # shellcheck source=src/Env/testsData/.env
  (
    echo "BASH_FRAMEWORK_LOG_LEVEL=${BASH_FRAMEWORK_LOG_LEVEL:-0}"
    echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${BASH_FRAMEWORK_DISPLAY_LEVEL:-3}"
    echo "BASH_FRAMEWORK_LOG_FILE=${BASH_FRAMEWORK_LOG_FILE:-${ROOT_DIR}/logs/${SCRIPT_NAME}.log}"
    echo "BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION=${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION:-5}"
  ) >"${BASH_FRAMEWORK_DEFAULT_ENV_FILE}"

  (
    # reset temp file
    echo >"${BASH_FRAMEWORK_CACHED_ENV_FILE}"

    # list .env files that need to be loaded
    local -a files=()
    if [[ -f "${BASH_FRAMEWORK_DEFAULT_ENV_FILE}" ]]; then
      files+=("${BASH_FRAMEWORK_DEFAULT_ENV_FILE}")
    fi
    if [[ -f "${ROOT_DIR}/conf/.env" && -r "${ROOT_DIR}/conf/.env" ]]; then
      files+=("${ROOT_DIR}/conf/.env")
    fi
    if [[ -f "${HOME}/.env" && -r "${HOME}/.env" ]]; then
      files+=("${HOME}/.env")
    fi
    local file
    for file in "$@"; do
      if [[ -f "${file}" && -r "${file}" ]]; then
        files+=("${file}")
      fi
    done
    # import custom .env file
    if [[ -n "${BASH_FRAMEWORK_ENV_FILEPATH+xxx}" ]]; then
      # load BASH_FRAMEWORK_ENV_FILEPATH
      if [[ -f "${BASH_FRAMEWORK_ENV_FILEPATH}" && -r "${BASH_FRAMEWORK_ENV_FILEPATH}" ]]; then
        files+=("${BASH_FRAMEWORK_ENV_FILEPATH}")
      else
        Log::displayWarning "env file not not found - ${BASH_FRAMEWORK_ENV_FILEPATH}"
      fi
    fi

    # add all files added as parameters
    files+=("$@")

    # source each file in order
    local file
    for file in "${files[@]}"; do
      # shellcheck source=src/Env/testsData/.env
      source "${file}" || {
        Log::displayWarning "Cannot load '${file}'"
      }
    done

    # copy only the variables to the tmp file
    local varName overrideVarName
    while IFS=$'\n' read -r varName; do
      overrideVarName="OVERRIDE_${varName}"
      if [[ -z ${!overrideVarName+xxx} ]]; then
        echo "${varName}='${!varName}'" >>"${BASH_FRAMEWORK_CACHED_ENV_FILE}"
      else
        # variable is overridden
        echo "${varName}='${!overrideVarName}'" >>"${BASH_FRAMEWORK_CACHED_ENV_FILE}"
      fi

      # using awk deduce all variables that need to be copied in tmp file
      #   from less specific file to the most
    done < <(awk -F= '!a[$1]++' "${files[@]}" | grep -v '^$\|^\s*\#' | cut -d= -f1)
  ) || exit 1

  # ensure all sourced variables will be exported
  set -o allexport

  # Finally load the temp file to make the variables available in current script
  # shellcheck source=src/Env/testsData/.env
  source "${BASH_FRAMEWORK_CACHED_ENV_FILE}"

  export BASH_FRAMEWORK_INITIALIZED=1

  set +o allexport
}

# Display message using debug color (grey)
# @param {String} $1 message
Log::displayDebug() {
  echo -e "${__DEBUG_COLOR}DEBUG   - ${1}${__RESET_COLOR}" >&2
  Log::logDebug "$1"
}

# Display message using info color (bg light blue/fg white)
# @param {String} $1 message
Log::displayHelp() {
  echo -e "${__HELP_COLOR}HELP    - ${1}${__RESET_COLOR}" >&2
  Log::logHelp "$1"
}

# Display message using skip color (yellow)
# @param {String} $1 message
Log::displaySkipped() {
  echo -e "${__SKIPPED_COLOR}SKIPPED - ${1}${__RESET_COLOR}" >&2
  Log::logSkipped "$1"
}

# Display message using warning color (yellow)
# @param {String} $1 message
Log::displayWarning() {
  echo -e "${__WARNING_COLOR}WARN    - ${1}${__RESET_COLOR}" >&2
  Log::logWarning "$1"
}

# log message to file
# @param {String} $1 message
Log::logDebug() {
  Log::logMessage "DEBUG" "$@"
}

# log message to file
# @param {String} $1 message
Log::logError() {
  Log::logMessage "ERROR" "$@"
}

# log message to file
# @param {String} $1 message
Log::logFatal() {
  Log::logMessage "FATAL" "$@"
}

# log message to file
# @param {String} $1 message
Log::logHelp() {
  Log::logMessage "HELP" "$@"
}

# log message to file
# @param {String} $1 message
Log::logInfo() {
  Log::logMessage "INFO" "$@"
}

# log message to file
# @param {String} $1 message
Log::logSkipped() {
  Log::logMessage "SKIPPED" "$@"
}

# log message to file
# @param {String} $1 message
Log::logSuccess() {
  Log::logMessage "SUCCESS" "$@"
}

# log message to file
# @param {String} $1 message
Log::logWarning() {
  Log::logMessage "WARNING" "$@"
}

# Display given text and complete the rest of the line with given character
# @param {String} $1 text to display
# @param {String} $2 (default:#) character to use to complete the line
UI::textLine() {
  local text="$1"
  local character="${2:-#}"
  ((textSize = ${#text}))
  ((fullWith = $(tput cols)))
  ((remainingWidth = $((fullWith - textSize))))
  echo -n "${text}"
  printf '%*s\n' "${remainingWidth}" '' | tr ' ' "${character}"
}

Wsl::cachedWslpathFromWslVar() {
  local var="$1"
  local value
  value="$(Wsl::cachedWslvar "${var}")"
  Wsl::cachedWslpath "${value}"
}

Assert::validVariableName() {
  echo "$1" | LC_ALL=POSIX grep -E -q '^[A-Za-z_0-9:]+$'
}

# Internal: common log message
#
# **Arguments**:
# * $1 - message's level description
# * $2 - message
# **Output**:
# [date]|[levelMsg]|message
#
# **Examples**:
# <pre>
# 2020-01-19 19:20:21|ERROR  |log error
# 2020-01-19 19:20:21|SKIPPED|log skipped
# </pre>
Log::logMessage() {
  local levelMsg="$1"
  local msg="$2"
  local date

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    date="$(date '+%Y-%m-%d %H:%M:%S')"
    printf "%s|%7s|%s\n" "${date}" "${levelMsg}" "${msg}" >>"${BASH_FRAMEWORK_LOG_FILE}"
  fi
}

Wsl::cachedWslpath() {
  local -a args=("$@")
  local tempEnvFile key

  tempEnvFile="${TMPDIR:-/tmp}/bash_tools_wslpath_$(id -un)"
  Cache::removeCacheFileIfTooOld "${tempEnvFile}" "+1"

  key="$(Wsl::getKeyFromWslpathOptions "$@")"
  Cache::getPropertyValue "${tempEnvFile}" "${key}" originalWslpath "${args[@]}"
}

Wsl::cachedWslvar() {
  local var="$1"
  local tempEnvFile
  tempEnvFile="${TMPDIR:-/tmp}/bash_tools_wslvar_$(id -un)"

  Cache::removeCacheFileIfTooOld "${tempEnvFile}" "+1"
  Cache::getPropertyValue "${tempEnvFile}" "${var}" Wsl::originalWslvar "${var}"
}

# get property value from file,
# if not present compute it using callback
# and store it in property file
Cache::getPropertyValue() {
  local propertyFile key callback value
  propertyFile="$1"
  shift || true
  key="$(echo -E "$1" | sed -E 's#\\#/#g')"
  shift || true
  callback=$1
  shift || true

  if grep -E "^${key}=.*" "${propertyFile}" &>/dev/null; then
    grep -E "^${key}=" "${propertyFile}" | cut -d'=' -f2
  elif [[ "$(type -t "${callback}")" = "function" ]]; then
    value="$(${callback} "$@")" || return $?
    if [[ -n "${value}" ]]; then
      echo -E "${key}=${value}" >>"${propertyFile}"
    fi
    echo -E "${value}"
  fi
}

Cache::removeCacheFileIfTooOld() {
  local cacheFile expiration
  cacheFile="$1"
  expiration="$2"

  if [[ -n "$(find "${cacheFile}" -mtime "${expiration}" -print 2>/dev/null)" ]]; then
    # file too old
    rm -f "${cacheFile}" || true
  fi
}

Wsl::getKeyFromWslpathOptions() {
  local options
  options=$(getopt -o "auwm" -- "$@" 2>/dev/null) || {
    Log::displayError "invalid options specified"
    return 1
  }
  local key="wslpath"
  eval set -- "${options}"
  while true; do
    case "$1" in
      -a | -u | -w | -m)
        key="${key}$1"
        ;;
      --)
        shift || true
        break
        ;;
      *)
        shift || true
        Log::displayWarning "Unknown key $1"
        ;;
    esac
    shift || true
  done
  echo -E "${key}_$1"
}

Wsl::originalWslvar() {
  wslvar "$@"
}

# FUNCTIONS

Env::load

# disable display methods following display level
if ((BASH_FRAMEWORK_DISPLAY_LEVEL < __LEVEL_DEBUG)); then
  Log::displayDebug() { :; }
fi
if ((BASH_FRAMEWORK_DISPLAY_LEVEL < __LEVEL_INFO)); then
  Log::displayHelp() { :; }
  Log::displayInfo() { :; }
  Log::displaySkipped() { :; }
  Log::displaySuccess() { :; }
fi
if ((BASH_FRAMEWORK_DISPLAY_LEVEL < __LEVEL_WARNING)); then
  Log::displayWarning() { :; }
fi
if ((BASH_FRAMEWORK_DISPLAY_LEVEL < __LEVEL_ERROR)); then
  Log::displayError() { :; }
fi
# disable log methods following log level
if ((BASH_FRAMEWORK_LOG_LEVEL < __LEVEL_DEBUG)); then
  Log::logDebug() { :; }
fi
if ((BASH_FRAMEWORK_LOG_LEVEL < __LEVEL_INFO)); then
  Log::logHelp() { :; }
  Log::logInfo() { :; }
  Log::logSkipped() { :; }
  Log::logSuccess() { :; }
fi
if ((BASH_FRAMEWORK_LOG_LEVEL < __LEVEL_WARNING)); then
  Log::logWarning() { :; }
fi
if ((BASH_FRAMEWORK_LOG_LEVEL < __LEVEL_ERROR)); then
  Log::logError() { :; }
fi

if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
  if [[ -z "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
    BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
    export BASH_FRAMEWORK_LOG_LEVEL
  elif [[ ! -f "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
    if ! mkdir -p "$(dirname "${BASH_FRAMEWORK_LOG_FILE}")" 2>/dev/null; then
      BASH_FRAMEWORK_LOG_LEVEL=__LEVEL_OFF
      Log::displayWarning "Log dir cannot be created $(dirname "${BASH_FRAMEWORK_LOG_FILE}")"
    fi
    if ! touch --no-create "${BASH_FRAMEWORK_LOG_FILE}" 2>/dev/null; then
      BASH_FRAMEWORK_LOG_LEVEL=__LEVEL_OFF
      Log::displayWarning "Log file '${BASH_FRAMEWORK_LOG_FILE}' cannot be created"
    fi
  fi
  Log::displayInfo "Logging to file ${BASH_FRAMEWORK_LOG_FILE}"
  if ((BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION > 0)); then
    Log::rotate "${BASH_FRAMEWORK_LOG_FILE}" "${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION}"
  fi
fi

if [[ -d "${ROOT_DIR}/vendor/bash-tools-framework" ]]; then
  FRAMEWORK_DIR="$(cd "${ROOT_DIR}/vendor/bash-tools-framework" && pwd -P)"
else
  # shellcheck disable=SC2034
  FRAMEWORK_DIR="${ROOT_DIR}/vendor/bash-tools-framework"
fi
# shellcheck disable=SC2034
INSTALL_SCRIPTS_DIR="${ROOT_DIR}/installScripts"

# we need non root user to be sure that all variables will be correctly deduced
Assert::expectNonRootUser

INSTALL_START="$(date +%s)"

showHelp() {
  # shellcheck disable=SC2317
  engine::install::showHelp "Installs, updates softwares (kube, aws, composer, node, ...),
  configure Home environnement (git config, kube, motd, ssh, dns, ...) and check configuration"
}

export CONFIG_LIST
export PROFILE
export SKIP_INSTALL
export SKIP_CONFIGURE
export SKIP_TEST
export PREPARE_EXPORT
export SKIP_DEPENDENCIES

CONFIG_LIST=()
PROFILE=
SKIP_INSTALL=0
SKIP_CONFIGURE=0
SKIP_TEST=0
PREPARE_EXPORT=0
SKIP_DEPENDENCIES=0

if [[ "$#" = "0" ]]; then
  showHelp
  Log::fatal "You have to specify a profile using -p option or specify a software to install"
fi

# read command parameters
# $@ is all command line parameters passed to the script.
# -o is for short options like -h
# -l is for long options with double dash like --help
# the comma separates different long options
LONG_OPTIONS="help,profile:,prepare-export,skip-test,skip-tests,skip-config,skip-configure,skip-configuration,skip-install,skip-installation,skip-dependencies"
SHORT_OPTIONS="hp:"

options=$(getopt -l "${LONG_OPTIONS}" -o "${SHORT_OPTIONS}" -- "$@" 2>/dev/null) || {
  showHelp
  Log::fatal "invalid options specified"
}

eval set -- "${options}"
while true; do
  case $1 in
    -h | --help)
      showHelp
      exit 0
      ;;
    -p | --profile)
      shift || true
      PROFILE="$1"
      if [[ ! -f "${ROOT_DIR}/profile.${PROFILE}.sh" ]]; then
        Log::fatal "Profile profile.${PROFILE}.sh doesn't exist"
      fi
      ;;
    --prepare-export)
      PREPARE_EXPORT=1
      ;;
    --skip-installation | --skip-install)
      SKIP_INSTALL=1
      ;;
    --skip-config | --skip-configure | --skip-configuration)
      SKIP_CONFIGURE=1
      ;;
    --skip-test | --skip-tests)
      SKIP_TEST=1
      ;;
    --skip-dependencies)
      SKIP_DEPENDENCIES=1
      ;;
    --)
      shift || true
      break
      ;;
    *)
      showHelp
      Log::fatal "invalid argument $1"
      ;;
  esac
  shift || true
done

if (($# > 0)); then
  if [[ -n "${PROFILE}" ]]; then
    Log::fatal "You cannot combine profile and softwares"
  fi
  # check if each Softwares exists
  for software in "$@"; do
    if ! ls "${ROOT_DIR}/installScripts/${software}" &>/dev/null; then
      Log::fatal "Software installScripts/${software} configuration does not exists"
    fi
  done
  CONFIG_LIST=("$@")
fi

err_report() {
  echo "$0 - Upgrade failure - Error on line $1"
  exit 1
}
trap 'err_report $LINENO' ERR

# load config
if ! engine::config::checkConfigExist "${ROOT_DIR}/.env"; then
  exit 1
fi
engine::config::loadConfig "${ROOT_DIR}/.env"
engine::config::check "${ROOT_DIR}/.env"
engine::config::loadHostIp
engine::config::loadWslVariables
engine::config::createSudoerFile

CONFIG_LOGS_DIR="${CONFIG_LOGS_DIR:-${TMPDIR}}"

# load selected profile
if [[ -n "${PROFILE}" ]]; then
  mapfile -t CONFIG_LIST < <(
    IFS=$'\n' Profiles::loadProfile "${ROOT_DIR}" "${PROFILE}"
  )
fi
Log::displayInfo "Install ${CONFIG_LIST[*]}"

if [[ "${SKIP_DEPENDENCIES}" = "0" ]]; then
  CONFIG_LIST=("MinimumRequirements" "Upgrade" "MandatorySoftwares" "${CONFIG_LIST[@]}" "Clean")
  if [[ "${PREPARE_EXPORT}" = "1" ]]; then
    CONFIG_LIST+=("_Export")
  fi

  declare rootDependency="your software selection"
  if [[ -n "${PROFILE}" ]]; then
    rootDependency="profile ${PROFILE}"
  fi
  # deduce dependencies
  declare -ag allDepsResult=()
  # shellcheck disable=SC2034
  declare -Ag allDepsResultSeen=()

  Profiles::allDepsRecursive \
    "${SRC_DIR}/installScripts/definitions" "${rootDependency}" "${CONFIG_LIST[@]}"

  CONFIG_LIST=("${allDepsResult[@]}")
fi

Profiles::checkScriptsExistence "${INSTALL_SCRIPTS_DIR}" "" "${CONFIG_LIST[@]}"
Log::displayInfo "Will Install ${CONFIG_LIST[*]}"

# Start install process
Log::rotate "${LOGS_DIR}/automatic-upgrade"
UI::drawLine '-'

# shellcheck source=./lib/installMain.sh
# if time "${LIB_DIR}/installMain.sh" "${PROFILE}" "${PREPARE_EXPORT}" "${SKIP_INSTALL}" "${SKIP_CONFIGURE}" "${SKIP_TEST}" "${CONFIG_LIST[@]}" 2>&1 | tee /var/log/automatic-upgrade; then
#   # everything OK
#   Log::displaySuccess "Successful Installation"
# else
#   Log::displayError "Installation error, check logs /var/log/automatic-upgrade"
# fi

# shellcheck disable=SC2317
declare summaryDisplayed="0"
summary() {
  if [[ "${summaryDisplayed}" = "1" ]]; then
    return 0
  fi
  UI::drawLine '-'
  Log::headLine "Important messages recapitulative"
  stats::logRecapitulative "${LOGS_DIR}/automatic-upgrade"

  UI::drawLine '-'
  Log::headLine "Summary"
  if [[ "${SKIP_INSTALL}" = "0" ]]; then
    stats::aggregateStatsSummary "installation(s)" "${TMPDIR}/install.stat" "${#CONFIG_LIST[@]}"
  fi
  if [[ "${SKIP_CONFIGURE}" = "0" ]]; then
    stats::aggregateStatsSummary "configuration(s)" "${TMPDIR}/config.stat" "${#CONFIG_LIST[@]}"
  fi
  if [[ "${SKIP_TEST}" = "0" ]]; then
    stats::aggregateStatsSummary "test(s)" "${TMPDIR}/test.stat" "${#CONFIG_LIST[@]}"
  fi
  INSTALL_END="$(date +%s)"
  Log::displayInfo "Total duration: $((INSTALL_END - INSTALL_START))s"
  summaryDisplayed="1"
}
trap 'summary' EXIT INT TERM ABRT

(
  # shellcheck disable=SC2317
  for configName in "${CONFIG_LIST[@]}"; do
    installCmd=(
      "${INSTALL_SCRIPTS_DIR}/${configName}"
    )
    if [[ "${SKIP_INSTALL}" = "1" ]]; then
      installCmd+=(--skip-install)
    fi
    if [[ "${SKIP_CONFIGURE}" = "1" ]]; then
      installCmd+=(--skip-configure)
    fi
    if [[ "${SKIP_TEST}" = "1" ]]; then
      installCmd+=(--skip-test)
    fi
    installStatus="0"

    (
      aggregateStat() {
        if [[ "${SKIP_INSTALL}" = "0" ]]; then
          stats::aggregateStats "${TMPDIR}/${configName}-install.stat" "${TMPDIR}/install.stat"
          rm -f "${TMPDIR}/${configName}-install.stat" || true # avoid to aggregate twice if trapped twice
        fi
        if [[ "${SKIP_CONFIGURE}" = "0" ]]; then
          stats::aggregateStats "${TMPDIR}/${configName}-config.stat" "${TMPDIR}/config.stat"
          rm -f "${TMPDIR}/${configName}-config.stat" || true # avoid to aggregate twice if trapped twice
        fi
        if [[ "${SKIP_TEST}" = "0" ]]; then
          stats::aggregateStats "${TMPDIR}/${configName}-test.stat" "${TMPDIR}/test.stat"
          rm -f "${TMPDIR}/${configName}-test.stat" || true # avoid to aggregate twice if trapped twice
        fi
      }
      trap 'aggregateStat' EXIT INT TERM ABRT

      CONFIG_LOGS_DIR="${TMPDIR}" "${installCmd[@]}"
    ) || installStatus="$?"
    if [[ "${installStatus}" != "0" ]]; then
      Log::displayError "Aborted after ${configName} failure"
      exit "${installStatus}"
    fi
  done
) | tee "${LOGS_DIR}/automatic-upgrade"
