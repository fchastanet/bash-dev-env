#!/usr/bin/env bash
# META_SCRIPT=Upgrade

#####################################
# GENERATED FILE FROM https://github.com/fchastanet/bash-dev-env/tree/master/tree/master/src/installScripts/scripts/Upgrade.sh
# DO NOT EDIT IT
#####################################

# shellcheck disable=SC2034
SCRIPT_NAME=${0##*/}
REAL_SCRIPT_FILE="$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")"
# shellcheck disable=SC2034
CURRENT_DIR="$(cd "$(readlink -e "${REAL_SCRIPT_FILE%/*}")" && pwd -P)"
BIN_DIR="${CURRENT_DIR}"
ROOT_DIR="$(cd "${BIN_DIR}/.." && pwd -P)"
# shellcheck disable=SC2034
SRC_DIR="${ROOT_DIR}/src"
# shellcheck disable=SC2034
VENDOR_DIR="${ROOT_DIR}/vendor"
# shellcheck disable=SC2034
VENDOR_BIN_DIR="${ROOT_DIR}/vendor/bin"
export PATH="${BIN_DIR}":"${VENDOR_BIN_DIR}":${PATH}

# shellcheck disable=SC2034
TMPDIR="$(mktemp -d -p "${TMPDIR:-/tmp}" -t bash-framework-$$-XXXXXX)"
export TMPDIR

# temp dir cleaning
cleanOnExit() {
  rm -Rf "${TMPDIR}" >/dev/null 2>&1
}
trap cleanOnExit EXIT HUP QUIT ABRT TERM

# @see https://unix.stackexchange.com/a/386856
interruptManagement() {
  # restore SIGINT handler
  trap - INT
  # ensure that Ctrl-C is trapped by this script and not by sub process
  # report to the parent that we have indeed been interrupted
  kill -s INT "$$"
}
trap interruptManagement INT

# shellcheck disable=SC2034
((failures = 0)) || true

shopt -s expand_aliases

# Bash will remember & return the highest exit code in a chain of pipes.
# This way you can catch the error inside pipes, e.g. mysqldump | gzip
set -o pipefail
set -o errexit

# a log is generated when a command fails
set -o errtrace

# use nullglob so that (file*.php) will return an empty array if no file matches the wildcard
shopt -s nullglob

export TERM=xterm-256color

#avoid interactive install
export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true

if [[ -t 1 || -t 2 ]]; then
  # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
  readonly __ERROR_COLOR='\e[31m'      # Red
  readonly __INFO_COLOR='\e[44m'       # white on lightBlue
  readonly __SUCCESS_COLOR='\e[32m'    # Green
  readonly __WARNING_COLOR='\e[33m'    # Yellow
  readonly __TEST_COLOR='\e[100m'      # Light magenta
  readonly __TEST_ERROR_COLOR='\e[41m' # white on red
  readonly __SKIPPED_COLOR='\e[33m'    # Yellow
  readonly __HELP_COLOR='\e[7;49;33m'  # Black on Gold
  readonly __DEBUG_COLOR='\e[37m'      # Grey
  # Internal: reset color
  readonly __RESET_COLOR='\e[0m' # Reset Color
  # shellcheck disable=SC2155,SC2034
  readonly __HELP_EXAMPLE="$(echo -e "\e[1;30m")"
  # shellcheck disable=SC2155,SC2034
  readonly __HELP_TITLE="$(echo -e "\e[1;37m")"
  # shellcheck disable=SC2155,SC2034
  readonly __HELP_NORMAL="$(echo -e "\033[0m")"
else
  # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
  readonly __ERROR_COLOR=''
  readonly __INFO_COLOR=''
  readonly __SUCCESS_COLOR=''
  readonly __WARNING_COLOR=''
  readonly __SKIPPED_COLOR=''
  readonly __HELP_COLOR=''
  readonly __TEST_COLOR=''
  readonly __TEST_ERROR_COLOR=''
  readonly __DEBUG_COLOR=''
  # Internal: reset color
  readonly __RESET_COLOR=''
  readonly __HELP_EXAMPLE=''
  readonly __HELP_TITLE=''
  readonly __HELP_NORMAL=''
fi
export __ERROR_COLOR
export __INFO_COLOR
export __SUCCESS_COLOR
export __WARNING_COLOR
export __SKIPPED_COLOR
export __TEST_COLOR
export __TEST_ERROR_COLOR
export __SKIPPED_COLOR
export __HELP_COLOR
export __DEBUG_COLOR
export __RESET_COLOR
export __HELP_EXAMPLE
export __HELP_TITLE
export __HELP_NORMAL

Apt::install() {
  Retry::default sudo apt-get install -y -q "$@"
}

Apt::remove() {
  Retry::default sudo dpkg --purge "$@"
}

Apt::update() {
  Retry::default sudo apt-get update -y --fix-missing -o Acquire::ForceIPv4=true
}

# check if an element is contained in an array
#
# **Arguments**:
# $@ - first parameter is the needle, rest is the array
#
# **Examples**:
#
# ```shell
#  Array::contains "${libPath}" "${__BASH_FRAMEWORK_IMPORTED_FILES[@]}"
# ```
#
# Returns 0 if found, 1 otherwise
Array::contains() {
  local element
  for element in "${@:2}"; do
    [[ "${element}" = "$1" ]] && return 0
  done
  return 1
}

# Public: exits with message if current user is root
#
# **Exit**: code 1 if current user is root
Assert::expectNonRootUser() {
  if [[ "$(id -u)" = "0" ]]; then
    Log::fatal "The script must not be run as root"
  fi
}

Assert::varExistsAndNotEmpty() {
  local varName="$1"
  if ! Assert::validVariableName "${varName}"; then
    Log::displayError "${varName} - invalid variable name"
    return 3
  fi
  if [[ -z "${!varName+unset}" ]]; then
    Log::displayError "${varName} - not defined"
    return 1
  elif [[ -z "${!varName}" ]]; then
    Log::displayError "${varName} - please provide a value"
    return 2
  fi
}

engine::config::check() {
  local envFile="$1"

  # check if ubuntu
  # load environment variables ID, VERSION_CODENAME
  engine::config::loadOsRelease
  if ! echo "${ID}" | grep -qEw 'debian|ubuntu'; then
    Log::fatal "This script is built to support only Debian or Ubuntu distributions. You are using ${ID}."
  fi

  ((errorCount = 0)) || true
  # shellcheck disable=SC2153
  if ! Assert::varExistsAndNotEmpty "USER_NAME"; then
    ((errorCount++))
  elif ! getent passwd "${USER_NAME}" 2>/dev/null >/dev/null; then
    Log::displayError "USER_NAME - user '${USER_NAME}' does not exist"
    ((errorCount++))
  fi

  # GIT_USER_NAME
  if ! Assert::varExistsAndNotEmpty "GIT_USER_NAME"; then
    ((errorCount++))
  elif ! Assert::firstNameLastName "${GIT_USER_NAME}"; then
    Log::displayError "GIT_USER_NAME - invalid format, expected : firstName lastName"
    ((errorCount++))
  fi

  # GIT_USER_MAIL
  if ! Assert::varExistsAndNotEmpty "GIT_USER_MAIL"; then
    ((errorCount++))
  elif ! Assert::emailAddress "${GIT_USER_MAIL}"; then
    Log::displayError "GIT_USER_MAIL: invalid email address"
    ((errorCount++))
  fi

  # PROJECTS_DIR
  if ! Assert::varExistsAndNotEmpty "PROJECTS_DIR"; then
    ((errorCount++))
  elif [[ ! -d "${PROJECTS_DIR}" ]]; then
    if ! mkdir -p "${PROJECTS_DIR}"; then
      Log::displayError "PROJECTS_DIR - impossible to create the directory '${PROJECTS_DIR}'"
      ((errorCount++))
    fi
  fi

  # CONF_DIR
  if ! Assert::varExistsAndNotEmpty "CONF_DIR"; then
    ((errorCount++))
  elif [[ ! -d "${CONF_DIR}" ]]; then
    Log::displayError "CONF_DIR - directory does not exist '${CONF_DIR}'"
    ((errorCount++))
  elif [[ ! -r "${CONF_DIR}" ]]; then
    Log::displayError "CONF_DIR - directory '${CONF_DIR}' is not accessible"
    ((errorCount++))
  fi

  # INSTALL_SCRIPTS_DIR
  if ! Assert::varExistsAndNotEmpty "INSTALL_SCRIPTS_DIR"; then
    ((errorCount++))
  elif [[ ! -d "${INSTALL_SCRIPTS_DIR}" ]]; then
    Log::displayError "INSTALL_SCRIPTS_DIR - directory does not exist '${INSTALL_SCRIPTS_DIR}'"
    ((errorCount++))
  elif [[ ! -r "${INSTALL_SCRIPTS_DIR}" ]]; then
    Log::displayError "INSTALL_SCRIPTS_DIR - directory '${INSTALL_SCRIPTS_DIR}' is not accessible"
    ((errorCount++))
  fi

  # BACKUP_DIR
  if ! Assert::varExistsAndNotEmpty "BACKUP_DIR"; then
    ((errorCount++))
  elif [[ ! -d "${BACKUP_DIR}" ]]; then
    mkdir -p "${BACKUP_DIR}" || Log::displayError "BACKUP_DIR - backup dir ${BACKUP_DIR} cannot be created"
    ((errorCount++))
  elif [[ ! -w "${BACKUP_DIR}" ]]; then
    Log::displayError "BACKUP_DIR - backup dir ${BACKUP_DIR} is not writable"
    ((errorCount++))
  fi

  if ((errorCount > 0)); then
    Log::displayError "one or more variables are invalid, check above logs and fix ${envFile} file accordingly"
    return 1
  fi
}

envTemplate="$(
  cat <<'EOF'
  #!/bin/bash
  # shellcheck disable=SC2034
  # wsl username
  USER_NAME="wsl"
  USER_HOME="/home/wsl"

  # your git full name 'FirstName LastName'
  GIT_USER_NAME=""
  # email used for git 'ldap@domain.com'
  GIT_USER_MAIL=""

  # conf files that will be used to configure the different tools
  CONF_DIR="${ROOT_DIR}/conf"

  # conf files that will be used to configure the different tools
  # some tools configuration will use CONF_DIR as template and
  # copy files into this directory
  CONF_OVERRIDE_DIR="${ROOT_DIR}/conf.override"

  # where to install bash-tools, ...
  PROJECTS_DIR="${USER_HOME}/projects"

  # where overridden config files will be backed up
  BACKUP_DIR="${ROOT_DIR}/backup"
  # logs CONF_DIR
  LOGS_DIR="${ROOT_DIR}/logs"
  # installScripts dir
  INSTALL_SCRIPTS_DIR="${ROOT_DIR}/installScripts"

  # 0   => no upgrade at all
  # lts => UPGRADE to latest ubuntu lts version
  # dev => UPGRADE to latest ubuntu dev version
  # Use if you know what you are doing,
  # could cause some packages to not being available yet
  UPGRADE_UBUNTU_VERSION=0

  # -----------------------------------------
  # PROFILES options

  # Choose your AWS authenticator tool
  # possible choices: Saml2Aws, Awsume
  AWS_AUTHENTICATOR="Saml2Aws"

  # Choose your preferred shell
  # possible choices: BashProfile (Legacy experience), ZshProfile (Recommended experience)
  PREFERRED_SHELL="BashProfile"

  # Display Fortune tooltip at bash/zsh session open
  SHOW_FORTUNES=1

  # Display MOTD at bash/zsh session open
  SHOW_MOTD=1

  # Install Docker inside wsl
  DOCKER_INSIDE_WSL=1

  # Configuration files are overwritten even if exists
  # !!!! First time initialization: let this value to 1 !!!!
  # Value 0:
  # - If target configuration file exists, displays a message and do not overwrite the file
  # - If target configuration file doesn't exist, installs the file
  # Value 1
  # - install or overwrite the file without checking existence
  OVERWRITE_CONFIG_FILES=1

  # Windows files can be overridden if 1
  # if 0
  # - skip changes to %USERPROFILE%/.wslconfig
  # - skip copying fonts
  CHANGE_WINDOWS_FILES=1

  # Indicate that install script can warn you using speaker when your input is needed
  CAN_TALK_DURING_INSTALLATION=1

  # if 1 install script will skip all interactive activity (saml2aws, ...),
  # so dependent installation will be skipped as well
  NON_INTERACTIVE=0

  # -----------------------------------------
  # WSLCONFIG - these parameters will help to automatically
  # configure %USERPROFILE%/.wslconfig file
  # Adjust these values to your needs
  # @see https://docs.microsoft.com/en-us/windows/wsl/wsl-config
  # Recommended 50% of total memory
  WSLCONFIG_MAX_MEMORY=8GB
  # personally I prefer run out of memory instead of beginning swapping
  # So I know immediately if some processes have to be stopped
  WSLCONFIG_SWAP=0

  # -----------------------------------------
  # Hacks
  # on some configurations we have to force path of some windows commands
  #POWERSHELL_BIN=/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe
  #IPCONFIG_BIN=/mnt/c/Windows/system32/ipconfig.exe
  #WSL_EXE_BIN=/mnt/c/Windows/system32/wsl.exe
EOF
)"

engine::config::checkConfigExist() {
  local envFile="$1"

  if [[ ! -f "${envFile}" ]]; then
    echo "${envTemplate}" >"${envFile}"
    Log::displayError "a default env file has been created, please edit ${envFile}"
    return 1
  fi
}

# set sudoer without password temporarily
engine::config::createSudoerFile() {
  local sudoerFile="/etc/sudoers.d/${USER_NAME}-bash-dev-env-no-password"

  # create /etc/sudoers.d/userName-bash-dev-env
  SUDOER_CHANGE="${USER_NAME} ALL=(ALL) NOPASSWD: ${ROOT_DIR}/install,/etc/cron.weekly/upgrade,/usr/sbin/service,${ROOT_DIR}/scripts/*/configure"
  if [[ "${SUDOER_CHANGE}" != "$(sudo cat "${sudoerFile}" 2>/dev/null || echo -n '')" ]]; then
    echo "${SUDOER_CHANGE}" | sudo tee "${sudoerFile}"
    sudo chmod 0440 "${sudoerFile}"

    echo "this file indicates that sudo has been configured to execute without password" |
      sudo tee "${USER_HOME}/.cron_activated" >/dev/null

    sudo visudo -c -s || {
      Log::displayError "Please check syntax of '${sudoerFile}' before closing this session - 'sudo visudo'"
      return 1
    }
  fi
}

engine::config::loadConfig() {
  local envFile="$1"

  # shellcheck source=/.env.template
  source "${envFile}"

  export USER_NAME
  export GIT_USER_NAME
  export GIT_USER_MAIL
  export CONF_DIR
  export CONF_OVERRIDE_DIR
  export PROJECTS_DIR
  export BACKUP_DIR
  export LOGS_DIR
  export SCRIPTS_DIR
  export UPGRADE_UBUNTU_VERSION
  export AWS_AUTHENTICATOR
  export PREFERRED_SHELL
  export SHOW_FORTUNES
  export SHOW_MOTD
  export DOCKER_INSIDE_WSL
  export OVERWRITE_CONFIG_FILES
  export CHANGE_WINDOWS_FILES
  export CAN_TALK_DURING_INSTALLATION
  export NON_INTERACTIVE
  export WSLCONFIG_MAX_MEMORY
  export WSLCONFIG_SWAP
  export POWERSHELL_BIN

  engine::config::loadUserVariables
}

engine::config::loadHostIp() {
  HOST_IP="$(/sbin/ip route | awk '/default/ { print $3 }')"

  export HOST_IP
}

engine::config::loadWslVariables() {
  if ! Assert::wsl; then
    # skip
    return 0
  fi

  # shellcheck disable=SC1003
  BASE_MNT_C="$(mount | grep 'path=C:\\' | awk -F ' ' '{print $3}')"

  # TODO default value if not found or wslpath not working
  WINDOWS_DIR="$(Wsl::cachedWslpathFromWslVar SystemRoot "${WINDOWS_DIR:-${BASE_MNT_C}/Windows}")"
  export WINDOWS_DIR

  WINDOWS_PROFILE_DIR="$(Wsl::cachedWslpathFromWslVar USERPROFILE "${WINDOWS_PROFILE_DIR:-${BASE_MNT_C}/Users/$(id -un)}")"
  export WINDOWS_PROFILE_DIR

  # POWERSHELL_BIN
  if [[ -z "${POWERSHELL_BIN+xxx}" ]]; then
    POWERSHELL_BIN="${WINDOWS_DIR}/System32/WindowsPowerShell/v1.0/powershell.exe"
    if ! command -v "${POWERSHELL_BIN}" >/dev/null 2>&1; then
      POWERSHELL_BIN="$(command -v powershell.exe 2>/dev/null)"
    fi
  fi
  if ! command -v "${POWERSHELL_BIN}" >/dev/null 2>&1; then
    Log::fatal "command powershell.exe not found"
  fi
  export POWERSHELL_BIN

  # Deduce wsl.exe path
  if [[ -z "${WSL_EXE_BIN+xxx}" ]]; then
    WSL_EXE_BIN="${WINDOWS_DIR}/system32/wsl.exe"
    if ! command -v "${WSL_EXE_BIN}" >/dev/null 2>&1; then
      WSL_EXE_BIN="$(command -v wsl.exe 2>/dev/null)"
    fi
  fi
  if ! command -v "${WSL_EXE_BIN}" >/dev/null 2>&1; then
    Log::fatal "command wsl.exe not found"
  fi
  export WSL_EXE_BIN

  # IPCONFIG_BIN - which ipconfig.exe does not work when executed as root
  if [[ -z "${IPCONFIG_BIN+xxx}" ]]; then
    IPCONFIG_BIN="${WINDOWS_DIR}/system32/ipconfig.exe"
    if ! command -v "${IPCONFIG_BIN}" >/dev/null 2>&1; then
      IPCONFIG_BIN="$(command -v ipconfig.exe 2>/dev/null)"
    fi
  fi
  if ! command -v "${IPCONFIG_BIN}" >/dev/null 2>&1; then
    Log::fatal "command ipconfig.exe not found"
  fi
  export IPCONFIG_BIN
}

engine::installScript::showHelp() {
  local description="$1"
  local helpVariables="$2"
  local dependencies="$3"
  if [[ "${dependencies}" = "" ]]; then
    dependencies="${__HELP_EXAMPLE}None${__HELP_NORMAL}"
  fi

  cat <<EOF
${__HELP_TITLE}Description:${__HELP_NORMAL} ${description}

${__HELP_TITLE}Usage:${__HELP_NORMAL} ${SCRIPT_NAME} --help prints this help and exits
${__HELP_TITLE}Usage:${__HELP_NORMAL} ${SCRIPT_NAME} [--skip-install] [--skip-configure] [--skip-test]

    --skip-install              skip softwares installation
    --skip-configure            skip softwares configuration
    --skip-test                 skip softwares tests

${__HELP_TITLE}List of needed variables:${__HELP_NORMAL}
${helpVariables}

${__HELP_TITLE}List of dependencies:${__HELP_NORMAL}
  ${dependencies}

${__HELP_TITLE}Author:${__HELP_NORMAL}
[François Chastanet](https://github.com/fchastanet)

${__HELP_TITLE}Source file:${__HELP_NORMAL}
https://github.com/fchastanet/bash-dev-env/tree/master/tree/master/src/installScripts/scripts/Upgrade.sh

${__HELP_TITLE}License:${__HELP_NORMAL}
MIT License

Copyright (c) 2022 François Chastanet
EOF
}

# Public: log level off
export __LEVEL_OFF=0
# Public: log level error
export __LEVEL_ERROR=1
# Public: log level warning
export __LEVEL_WARNING=2
# Public: log level info
export __LEVEL_INFO=3
# Public: log level success
export __LEVEL_SUCCESS=3
# Public: log level debug
export __LEVEL_DEBUG=4

export __LEVEL_OFF
export __LEVEL_ERROR
export __LEVEL_WARNING
export __LEVEL_INFO
export __LEVEL_SUCCESS
export __LEVEL_DEBUG

# Display message using error color (red)
# @param {String} $1 message
Log::displayError() {
  echo -e "${__ERROR_COLOR}ERROR   - ${1}${__RESET_COLOR}" >&2
  Log::logError "$1"
}

# Display message using info color (bg light blue/fg white)
# @param {String} $1 message
Log::displayHelp() {
  echo -e "${__HELP_COLOR}HELP    - ${1}${__RESET_COLOR}" >&2
  Log::logHelp "$1"
}

# Display message using info color (bg light blue/fg white)
# @param {String} $1 message
Log::displayInfo() {
  echo -e "${__INFO_COLOR}INFO    - ${1}${__RESET_COLOR}" >&2
  Log::logInfo "$1"
}

# Display message using error color (red) and exit immediately with error status 1
# @param {String} $1 message
Log::fatal() {
  echo -e "${__ERROR_COLOR}FATAL   - ${1}${__RESET_COLOR}" >&2
  Log::logFatal "$1"
  exit 1
}

Log::headLine() {
  local type="$1"
  local message
  message="$(UI::textLine "${type}" " ")"
  echo -e "${__TEST_COLOR}${message}${__RESET_COLOR}"
}

# Retry a command 5 times with a delay of 15 seconds between each attempt
# @param          $@ the command to run
# @return 0 on success, 1 if max retries count reached
Retry::default() {
  Retry::parameterized 5 15 "" "$@"
}

stats::computeFromLog() {
  local logFile="$1"
  local status="$2"
  local duration="$3"

  local logStatsAwkScript
  logStatsAwkScript="$(
    cat <<'EOF'
BEGIN {
  error=0
  warning=0
  skipped=0
  help=0
  success=0
}
{
  buffer = substr($0, 1, 20)
  if(match(buffer, /(ERROR)[ ]+- /, arr) != 0) {
    error+=1
  } else if(match(buffer, /(WARNING)[ ]+- /, arr) != 0) {
    warning+=1
  } else if(match(buffer, /(SKIPPED)[ ]+- /, arr) != 0) {
    skipped+=1
  } else if(match(buffer, /(ERROR)[ ]+- /, arr) != 0) {
    error+=1
  } else if(match(buffer, /(HELP)[ ]+- /, arr) != 0) {
    help+=1
  } else if(match(buffer, /(SUCCESS)[ ]+- /, arr) != 0) {
    success+=1
  }

}
END {
  print "error=" error
  print "warning=" warning
  print "skipped=" skipped
  print "help=" help
  print "success=" success
}
EOF
  )"

  if [[ -f "${logFile}" ]]; then
    awk --source "${logStatsAwkScript}" "${logFile}"
    echo "status=${status}"
    echo "duration=${duration}"
  else
    # not executed
    echo "status=-1"
  fi
}

stats::statusLine() {
  local statFile="$1"
  local msg="$2"
  if [[ ! -f "${statFile}" ]]; then
    return 0
  fi

  (
    # shellcheck source=src/stats/logStats.example
    source "${statFile}" || exit 1

    local color="${__TEST_ERROR_COLOR}"
    local statusMsg
    if [[ "${status}" = "0" ]]; then
      if [[ "${skipped}" = "0" ]]; then
        color="${__SUCCESS_COLOR}"
        statusMsg="SUCCESS - ${msg} successful"
      else
        color="${__SKIPPED_COLOR}"
        statusMsg="SKIPPED - ${msg} skipped"
      fi
    elif [[ "${status}" = "-1" ]]; then
      statusMsg="ABORTED - ${msg} not executed"
    else
      statusMsg="ERROR  - ${msg} in error"
    fi
    # overwrite final TEST line
    echo -e "${color}${statusMsg}${__RESET_COLOR}"
  )
}

# check if param is valid email address
# @param $1 the full email address
# @return 1 on error
Assert::emailAddress() {
  local email expectedRegexp
  email="$1"
  expectedRegexp="^\S+@\S+$"

  [[ "${email}" =~ ${expectedRegexp} ]]
}

Assert::firstNameLastName() {
  local regexp
  regexp="^[^ ]+ ([^ ]+[ ]?)+$"
  [[ $1 =~ ${regexp} ]]
}

Assert::validVariableName() {
  echo "$1" | LC_ALL=POSIX grep -E -q '^[A-Za-z_0-9:]+$'
}

# Public: determine if the script is executed under WSL
#
# @return 1 on error
Assert::wsl() {
  if grep -qEi "(Microsoft|WSL)" /proc/version &>/dev/null; then
    return 0
  else
    return 1
  fi
}

engine::config::loadOsRelease() {
  if [[ ! -f /etc/os-release ]]; then
    Log::displayError "file /etc/os-release does not exists"
    return 1
  fi
  # This will load environment variables ID, VERSION_CODENAME
  source /etc/os-release
  export NAME
  export VERSION
  export ID
  export ID_LIKE
  export PRETTY_NAME
  export VERSION_ID
  export HOME_URL
  export SUPPORT_URL
  export BUG_REPORT_URL
  export PRIVACY_POLICY_URL
  export VERSION_CODENAME
  export UBUNTU_CODENAME
}

engine::config::loadUserVariables() {
  # deduce user home and group
  # shellcheck disable=SC2153
  USER_HOME="$(getent passwd "${USER_NAME}" | cut -d: -f6)"
  USER_ID="$(getent passwd "${USER_NAME}" | cut -d: -f3)"
  USER_GROUP_ID="$(getent passwd "${USER_NAME}" | cut -d: -f4)"
  USER_GROUP="$(getent group "${USER_GROUP_ID}" | cut -d: -f1)"

  if [[ -z "${USER_GROUP}" || -z "${USER_HOME}" ]]; then
    Log::displayError "USER_NAME - unable to deduce USER_GROUP, USER_HOME from USER_NAME"
    return 1
  fi

  export USER_HOME
  export USER_ID
  export USER_GROUP_ID
  export USER_GROUP
}

# lazy initialization
declare -g BASH_FRAMEWORK_INITIALIZED="0"
declare -g BASH_FRAMEWORK_CACHED_ENV_FILE
declare -g BASH_FRAMEWORK_DEFAULT_ENV_FILE

# load variables in order(from less specific to more specific) from :
# - ${ROOT_DIR}/src/Env/testsData/.env file
# - ${ROOT_DIR}/conf/.env file if exists
# - ~/.env file if exists
# - ~/.bash-tools/.env file if exists
# - BASH_FRAMEWORK_ENV_FILEPATH=<fullPathToEnvFile or empty if no file to be loaded>
Env::load() {
  if [[ "${BASH_FRAMEWORK_INITIALIZED}" = "1" ]]; then
    return 0
  fi
  BASH_FRAMEWORK_CACHED_ENV_FILE="$(mktemp -p "${TMPDIR:-/tmp}" -t "env_vars.XXXXXXX")"
  BASH_FRAMEWORK_DEFAULT_ENV_FILE="$(mktemp -p "${TMPDIR:-/tmp}" -t "default_env_file.XXXXXXX")"
  # shellcheck source=src/Env/testsData/.env
  (
    echo "BASH_FRAMEWORK_LOG_LEVEL=${BASH_FRAMEWORK_LOG_LEVEL:-0}"
    echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${BASH_FRAMEWORK_DISPLAY_LEVEL:-3}"
    echo "BASH_FRAMEWORK_LOG_FILE=${BASH_FRAMEWORK_LOG_FILE:-${ROOT_DIR}/logs/${SCRIPT_NAME}.log}"
    echo "BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION=${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION:-5}"
  ) >"${BASH_FRAMEWORK_DEFAULT_ENV_FILE}"

  (
    # reset temp file
    echo >"${BASH_FRAMEWORK_CACHED_ENV_FILE}"

    # list .env files that need to be loaded
    local -a files=()
    if [[ -f "${BASH_FRAMEWORK_DEFAULT_ENV_FILE}" ]]; then
      files+=("${BASH_FRAMEWORK_DEFAULT_ENV_FILE}")
    fi
    if [[ -f "${ROOT_DIR}/conf/.env" && -r "${ROOT_DIR}/conf/.env" ]]; then
      files+=("${ROOT_DIR}/conf/.env")
    fi
    if [[ -f "${HOME}/.env" && -r "${HOME}/.env" ]]; then
      files+=("${HOME}/.env")
    fi
    local file
    for file in "$@"; do
      if [[ -f "${file}" && -r "${file}" ]]; then
        files+=("${file}")
      fi
    done
    # import custom .env file
    if [[ -n "${BASH_FRAMEWORK_ENV_FILEPATH+xxx}" ]]; then
      # load BASH_FRAMEWORK_ENV_FILEPATH
      if [[ -f "${BASH_FRAMEWORK_ENV_FILEPATH}" && -r "${BASH_FRAMEWORK_ENV_FILEPATH}" ]]; then
        files+=("${BASH_FRAMEWORK_ENV_FILEPATH}")
      else
        Log::displayWarning "env file not not found - ${BASH_FRAMEWORK_ENV_FILEPATH}"
      fi
    fi

    # add all files added as parameters
    files+=("$@")

    # source each file in order
    local file
    for file in "${files[@]}"; do
      # shellcheck source=src/Env/testsData/.env
      source "${file}" || {
        Log::displayWarning "Cannot load '${file}'"
      }
    done

    # copy only the variables to the tmp file
    local varName overrideVarName
    while IFS=$'\n' read -r varName; do
      overrideVarName="OVERRIDE_${varName}"
      if [[ -z ${!overrideVarName+xxx} ]]; then
        echo "${varName}='${!varName}'" >>"${BASH_FRAMEWORK_CACHED_ENV_FILE}"
      else
        # variable is overridden
        echo "${varName}='${!overrideVarName}'" >>"${BASH_FRAMEWORK_CACHED_ENV_FILE}"
      fi

      # using awk deduce all variables that need to be copied in tmp file
      #   from less specific file to the most
    done < <(awk -F= '!a[$1]++' "${files[@]}" | grep -v '^$\|^\s*\#' | cut -d= -f1)
  ) || exit 1

  # ensure all sourced variables will be exported
  set -o allexport

  # Finally load the temp file to make the variables available in current script
  # shellcheck source=src/Env/testsData/.env
  source "${BASH_FRAMEWORK_CACHED_ENV_FILE}"

  export BASH_FRAMEWORK_INITIALIZED=1

  set +o allexport
}

# Display message using debug color (grey)
# @param {String} $1 message
Log::displayDebug() {
  echo -e "${__DEBUG_COLOR}DEBUG   - ${1}${__RESET_COLOR}" >&2
  Log::logDebug "$1"
}

# Display message using skip color (yellow)
# @param {String} $1 message
Log::displaySkipped() {
  echo -e "${__SKIPPED_COLOR}SKIPPED - ${1}${__RESET_COLOR}" >&2
  Log::logSkipped "$1"
}

# Display message using success color (bg green/fg white)
# @param {String} $1 message
Log::displaySuccess() {
  echo -e "${__SUCCESS_COLOR}SUCCESS - ${1}${__RESET_COLOR}" >&2
  Log::logSuccess "$1"
}

# Display message using warning color (yellow)
# @param {String} $1 message
Log::displayWarning() {
  echo -e "${__WARNING_COLOR}WARN    - ${1}${__RESET_COLOR}" >&2
  Log::logWarning "$1"
}

# log message to file
# @param {String} $1 message
Log::logDebug() {
  Log::logMessage "DEBUG" "$@"
}

# log message to file
# @param {String} $1 message
Log::logError() {
  Log::logMessage "ERROR" "$@"
}

# log message to file
# @param {String} $1 message
Log::logFatal() {
  Log::logMessage "FATAL" "$@"
}

# log message to file
# @param {String} $1 message
Log::logHelp() {
  Log::logMessage "HELP" "$@"
}

# log message to file
# @param {String} $1 message
Log::logInfo() {
  Log::logMessage "INFO" "$@"
}

# log message to file
# @param {String} $1 message
Log::logSkipped() {
  Log::logMessage "SKIPPED" "$@"
}

# log message to file
# @param {String} $1 message
Log::logSuccess() {
  Log::logMessage "SUCCESS" "$@"
}

# log message to file
# @param {String} $1 message
Log::logWarning() {
  Log::logMessage "WARNING" "$@"
}

# To be called before logging in the log file
# @param $1 log file name
# @param $2 maximum number of log files
Log::rotate() {
  local FILENAME="$1"
  local MAX_LOG="${2:-5}"
  for i in $(seq $((MAX_LOG - 1)) -1 1); do
    Log::displayInfo "Log rotation ${FILENAME}.${i} to ${FILENAME}.$((i + 1))"
    mv "${FILENAME}."{"${i}","$((i + 1))"} &>/dev/null || true
  done
  if mv "${FILENAME}" "${FILENAME}.1" &>/dev/null; then
    Log::displayInfo "Log rotation ${FILENAME} to ${FILENAME}.1"
  fi
}

# Retry a command several times depending on parameters
# @param {int}    $1 max retries
# @param {int}    $2 delay between attempt
# @param {String} $3 message to display to describe the attempt
# @param ...      $@ rest of parameters, the command to run
# @return 0 on success
# @return 1 if max retries count reached
# @return 2 if maxRetries invalid value
Retry::parameterized() {
  local maxRetries=$1
  shift || true
  local delayBetweenTries=$1
  shift || true
  local message="$1"
  shift || true
  local retriesCount=1
  if [[ "${maxRetries}" -lt 1 ]]; then
    Log::displayError "invalid maxRetry value"
    return 2
  fi

  while true; do
    Log::displayInfo "Attempt ${retriesCount}/${maxRetries}: ${message}"
    if "$@"; then
      break
    elif [[ "${retriesCount}" -lt "${maxRetries}" ]]; then
      Log::displayWarning "Command failed. Wait for ${delayBetweenTries} seconds"
      ((retriesCount++))
      sleep "${delayBetweenTries}"
    else
      Log::displayError "The command has failed after ${retriesCount} attempts."
      return 1
    fi
  done
  return 0
}

# Display given text and complete the rest of the line with given character
# @param {String} $1 text to display
# @param {String} $2 (default:#) character to use to complete the line
UI::textLine() {
  local text="$1"
  local character="${2:-#}"
  ((textSize = ${#text}))
  ((fullWith = $(tput cols)))
  ((remainingWidth = $((fullWith - textSize))))
  echo -n "${text}"
  printf '%*s\n' "${remainingWidth}" '' | tr ' ' "${character}"
}

Wsl::cachedWslpathFromWslVar() {
  local var="$1"
  local value
  value="$(Wsl::cachedWslvar "${var}")"
  Wsl::cachedWslpath "${value}"
}

# Internal: common log message
#
# **Arguments**:
# * $1 - message's level description
# * $2 - message
# **Output**:
# [date]|[levelMsg]|message
#
# **Examples**:
# <pre>
# 2020-01-19 19:20:21|ERROR  |log error
# 2020-01-19 19:20:21|SKIPPED|log skipped
# </pre>
Log::logMessage() {
  local levelMsg="$1"
  local msg="$2"
  local date

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    date="$(date '+%Y-%m-%d %H:%M:%S')"
    printf "%s|%7s|%s\n" "${date}" "${levelMsg}" "${msg}" >>"${BASH_FRAMEWORK_LOG_FILE}"
  fi
}

Wsl::cachedWslpath() {
  local -a args=("$@")
  local tempEnvFile key

  tempEnvFile="${TMPDIR:-/tmp}/bash_tools_wslpath_$(id -un)"
  Cache::removeCacheFileIfTooOld "${tempEnvFile}" "+1"

  key="$(Wsl::getKeyFromWslpathOptions "$@")"
  Cache::getPropertyValue "${tempEnvFile}" "${key}" originalWslpath "${args[@]}"
}

Wsl::cachedWslvar() {
  local var="$1"
  local tempEnvFile
  tempEnvFile="${TMPDIR:-/tmp}/bash_tools_wslvar_$(id -un)"

  Cache::removeCacheFileIfTooOld "${tempEnvFile}" "+1"
  Cache::getPropertyValue "${tempEnvFile}" "${var}" Wsl::originalWslvar "${var}"
}

# get property value from file,
# if not present compute it using callback
# and store it in property file
Cache::getPropertyValue() {
  local propertyFile key callback value
  propertyFile="$1"
  shift || true
  key="$(echo -E "$1" | sed -E 's#\\#/#g')"
  shift || true
  callback=$1
  shift || true

  if grep -E "^${key}=.*" "${propertyFile}" &>/dev/null; then
    grep -E "^${key}=" "${propertyFile}" | cut -d'=' -f2
  elif [[ "$(type -t "${callback}")" = "function" ]]; then
    value="$(${callback} "$@")" || return $?
    if [[ -n "${value}" ]]; then
      echo -E "${key}=${value}" >>"${propertyFile}"
    fi
    echo -E "${value}"
  fi
}

Cache::removeCacheFileIfTooOld() {
  local cacheFile expiration
  cacheFile="$1"
  expiration="$2"

  if [[ -n "$(find "${cacheFile}" -mtime "${expiration}" -print 2>/dev/null)" ]]; then
    # file too old
    rm -f "${cacheFile}" || true
  fi
}

Wsl::getKeyFromWslpathOptions() {
  local options
  options=$(getopt -o "auwm" -- "$@" 2>/dev/null) || {
    Log::displayError "invalid options specified"
    return 1
  }
  local key="wslpath"
  eval set -- "${options}"
  while true; do
    case "$1" in
      -a | -u | -w | -m)
        key="${key}$1"
        ;;
      --)
        shift || true
        break
        ;;
      *)
        shift || true
        Log::displayWarning "Unknown key $1"
        ;;
    esac
    shift || true
  done
  echo -E "${key}_$1"
}

Wsl::originalWslvar() {
  wslvar "$@"
}

# FUNCTIONS

Env::load

# disable display methods following display level
if ((BASH_FRAMEWORK_DISPLAY_LEVEL < __LEVEL_DEBUG)); then
  Log::displayDebug() { :; }
fi
if ((BASH_FRAMEWORK_DISPLAY_LEVEL < __LEVEL_INFO)); then
  Log::displayHelp() { :; }
  Log::displayInfo() { :; }
  Log::displaySkipped() { :; }
  Log::displaySuccess() { :; }
fi
if ((BASH_FRAMEWORK_DISPLAY_LEVEL < __LEVEL_WARNING)); then
  Log::displayWarning() { :; }
fi
if ((BASH_FRAMEWORK_DISPLAY_LEVEL < __LEVEL_ERROR)); then
  Log::displayError() { :; }
fi
# disable log methods following log level
if ((BASH_FRAMEWORK_LOG_LEVEL < __LEVEL_DEBUG)); then
  Log::logDebug() { :; }
fi
if ((BASH_FRAMEWORK_LOG_LEVEL < __LEVEL_INFO)); then
  Log::logHelp() { :; }
  Log::logInfo() { :; }
  Log::logSkipped() { :; }
  Log::logSuccess() { :; }
fi
if ((BASH_FRAMEWORK_LOG_LEVEL < __LEVEL_WARNING)); then
  Log::logWarning() { :; }
fi
if ((BASH_FRAMEWORK_LOG_LEVEL < __LEVEL_ERROR)); then
  Log::logError() { :; }
fi

if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
  if [[ -z "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
    BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
    export BASH_FRAMEWORK_LOG_LEVEL
  elif [[ ! -f "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
    if ! mkdir -p "$(dirname "${BASH_FRAMEWORK_LOG_FILE}")" 2>/dev/null; then
      BASH_FRAMEWORK_LOG_LEVEL=__LEVEL_OFF
      Log::displayWarning "Log dir cannot be created $(dirname "${BASH_FRAMEWORK_LOG_FILE}")"
    fi
    if ! touch --no-create "${BASH_FRAMEWORK_LOG_FILE}" 2>/dev/null; then
      BASH_FRAMEWORK_LOG_LEVEL=__LEVEL_OFF
      Log::displayWarning "Log file '${BASH_FRAMEWORK_LOG_FILE}' cannot be created"
    fi
  fi
  Log::displayInfo "Logging to file ${BASH_FRAMEWORK_LOG_FILE}"
  if ((BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION > 0)); then
    Log::rotate "${BASH_FRAMEWORK_LOG_FILE}" "${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION}"
  fi
fi

if [[ -d "${ROOT_DIR}/vendor/bash-tools-framework" ]]; then
  FRAMEWORK_DIR="$(cd "${ROOT_DIR}/vendor/bash-tools-framework" && pwd -P)"
else
  # shellcheck disable=SC2034
  FRAMEWORK_DIR="${ROOT_DIR}/vendor/bash-tools-framework"
fi
# shellcheck disable=SC2034
INSTALL_SCRIPTS_DIR="${ROOT_DIR}/installScripts"

SCRIPT="Upgrade"

# we need non root user to be sure that all variables will be correctly deduced
Assert::expectNonRootUser

showHelp() {
  # shellcheck disable=SC2154,SC2086
  engine::installScript::showHelp \
    "$("installScripts_${SCRIPT}_helpDescription")" \
    "$("installScripts_${SCRIPT}_helpVariables")" \
    "$("installScripts_${SCRIPT}_dependencies")"
}

installScripts_Upgrade_helpDescription() {
  echo "Upgrade ubuntu apt softwares"
}

installScripts_Upgrade_helpVariables() {
  # shellcheck disable=SC2317
  cat <<EOF
  ${__HELP_EXAMPLE}UPGRADE_UBUNTU_VERSION${__HELP_NORMAL}
    possible values:
    0             => no upgrade at all
    lts (default) => UPGRADE to latest ubuntu lts version
    dev           => UPGRADE to latest ubuntu dev version

EOF
}

installScripts_Upgrade_listVariables() {
  echo "UPGRADE_UBUNTU_VERSION"
}

installScripts_Upgrade_defaultVariables() {
  export UPGRADE_UBUNTU_VERSION="lts"
}

installScripts_Upgrade_checkVariables() {
  if ! Assert::varExistsAndNotEmpty "UPGRADE_UBUNTU_VERSION"; then
    return 1
  elif ! Array::contains "${UPGRADE_UBUNTU_VERSION}" "lts" "dev"; then
    Log::displayError "UPGRADE_UBUNTU_VERSION values expects to be lts or dev"
    return 1
  fi
}

installScripts_Upgrade_fortunes() {
  return 0
}

installScripts_Upgrade_dependencies() {
  return 0
}

installScripts_Upgrade_breakOnConfigFailure() {
  return 0
}

installScripts_Upgrade_breakOnTestFailure() {
  return 0
}

installScripts_Upgrade_install() {
  # Needed before do-release-upgrade because WSL doesn't support Systemd directly
  Apt::remove snapd || true
  mv /etc/apt/apt.conf.d/20snapd.conf{,.disabled} || true
  Apt::update
  Retry::default sudo apt-get upgrade -y
  Retry::default sudo apt-get dist-upgrade -y
  Retry::default sudo apt-get autoremove -y

  # add do-release-upgrade
  Apt::install ubuntu-release-upgrader-core

  # configure to upgrade to the latest LTS development release
  sudo sed -i -r 's/^Prompt=.*$/Prompt=lts/g' /etc/update-manager/release-upgrades
  if sudo do-release-upgrade -c; then
    if [[ "${UPGRADE_UBUNTU_VERSION}" = "lts" ]]; then
      Log::displayInfo "Upgrading to latest lts ubuntu - please be patient, it can take a long time"
      Retry::default sudo do-release-upgrade -f DistUpgradeViewNonInteractive --allow-third-party
      Log::displayHelp "Please restart wsl - 'wsl --shutdown'"
    else
      Log::displayHelp "An lts ubuntu upgrade is available, update UPGRADE_UBUNTU_VERSION=lts in .env file if you want to upgrade next time (use with caution)"
    fi
  fi

  # configure to upgrade to the latest non-LTS development release
  sudo sed -i -r 's/^Prompt=.*$/Prompt=normal/g' /etc/update-manager/release-upgrades
  if sudo do-release-upgrade -c; then
    if [[ "${UPGRADE_UBUNTU_VERSION}" = "dev" ]]; then
      Log::displayInfo "Upgrading to latest non-lts ubuntu - please be patient, it can take a long time"
      Retry::default sudo do-release-upgrade -f DistUpgradeViewNonInteractive --allow-third-party
      Log::displayHelp "Please restart wsl - 'wsl --shutdown'"
    else
      Log::displayHelp "A non-lts ubuntu upgrade is available, update UPGRADE_UBUNTU_VERSION=dev in .env file if you want to upgrade next time (use with caution)"
    fi
  fi

  # restore to lts development release
  sudo sed -i -r 's/^Prompt=.*$/Prompt=lts/g' /etc/update-manager/release-upgrades
}

installScripts_Upgrade_configure() {
  return 0
}

installScripts_Upgrade_test() {
  return 0
}

# parse options

export SKIP_INSTALL
export SKIP_CONFIGURE
export SKIP_TEST

SKIP_INSTALL=0
SKIP_CONFIGURE=0
SKIP_TEST=0

# read command parameters
# $@ is all command line parameters passed to the script.
# -o is for short options like -h
# -l is for long options with double dash like --help
# the comma separates different long options
LONG_OPTIONS="help,skip-test,skip-tests,skip-config,skip-configure,skip-configuration,skip-install,skip-installation"
SHORT_OPTIONS="h"

options=$(getopt -l "${LONG_OPTIONS}" -o "${SHORT_OPTIONS}" -- "$@" 2>/dev/null) || {
  showHelp
  Log::fatal "invalid options specified"
}

eval set -- "${options}"
while true; do
  case $1 in
    -h | --help)
      showHelp
      exit 0
      ;;
    --skip-installation | --skip-install)
      SKIP_INSTALL=1
      ;;
    --skip-config | --skip-configure | --skip-configuration)
      SKIP_CONFIGURE=1
      ;;
    --skip-test | --skip-tests)
      SKIP_TEST=1
      ;;
    --)
      shift || true
      break
      ;;
    *)
      showHelp
      Log::fatal "invalid argument $1"
      ;;
  esac
  shift || true
done

if [[ "$#" != "0" ]]; then
  showHelp
  Log::fatal "no fixed parameter need to be provided"
fi

# load config
if ! engine::config::checkConfigExist "${ROOT_DIR}/.env"; then
  exit 1
fi
engine::config::loadConfig "${ROOT_DIR}/.env"
engine::config::check "${ROOT_DIR}/.env"
engine::config::loadHostIp
engine::config::loadWslVariables
engine::config::createSudoerFile

CONFIG_LOGS_DIR="${CONFIG_LOGS_DIR:-${TMPDIR}}"

rm -f "${CONFIG_LOGS_DIR}/${SCRIPT}-.*" || true

# shellcheck disable=SC2317
computeStats() {
  local status="$?"
  local step="$1"
  local logFile="$2"
  local statFile="$3"
  local END
  END="$(date +%s)"
  stats::computeFromLog "${logFile}" "${status}" "$((END - START))" >"${statFile}"
  stats::statusLine "${statFile}" "${step}"
  return "${status}"
}

onInterrupt() {
  Log::displayError "${SCRIPT} aborted"
  exit 1
}
trap 'onInterrupt' INT TERM ABRT

declare installStatus="0"
if [[ "${SKIP_INSTALL}" = "0" ]]; then
  Log::headLine "INSTALL - Installing ${SCRIPT}"
  installLogFile="${CONFIG_LOGS_DIR}/${SCRIPT}-install.log"
  installStatsFile="${CONFIG_LOGS_DIR}/${SCRIPT}-install.stat"

  (
    declare START
    START="$(date +%s)"
    trap 'computeStats "Installation ${SCRIPT}" "${installLogFile}" "${installStatsFile}"' EXIT INT TERM ABRT

    "installScripts_${SCRIPT}_install" 2>&1 | tee "${installLogFile}"
  ) || installStatus="$?" || true
  if [[ "${installStatus}" != "0" ]]; then
    # break at first install error
    exit "${installStatus}"
  fi
fi

declare configStatus="0"
if [[ "${SKIP_CONFIGURE}" = "0" && "${installStatus}" = "0" ]]; then
  Log::headLine "CONFIG  - Configuring ${SCRIPT}"
  configLogFile="${CONFIG_LOGS_DIR}/${SCRIPT}-config.log"
  configStatsFile="${CONFIG_LOGS_DIR}/${SCRIPT}-config.stat"
  (
    declare START
    START="$(date +%s)"
    trap 'computeStats "Configuration ${SCRIPT}" "${configLogFile}" "${configStatsFile}"' EXIT INT TERM ABRT

    "installScripts_${SCRIPT}_configure" 2>&1 | tee "${configLogFile}"
  ) || configStatus="$?" || true

  if [[ "${configStatus}" != "0" ]] && "installScripts_${SCRIPT}_breakOnConfigFailure"; then
    # break if config script error
    exit "${configStatus}"
  fi
fi

declare testStatus="0"
if [[ "${SKIP_TEST}" = "0" && "${installStatus}" = "0" && "${configStatus}" = "0" ]]; then
  Log::headLine "TEST    - Testing ${SCRIPT}"
  testLogFile="${CONFIG_LOGS_DIR}/${SCRIPT}-test.log"
  testStatsFile="${CONFIG_LOGS_DIR}/${SCRIPT}-test.stat"
  (
    declare START
    START="$(date +%s)"
    trap 'computeStats "Test ${SCRIPT}" "${testLogFile}" "${testStatsFile}"' EXIT INT TERM ABRT

    "installScripts_${SCRIPT}_test" 2>&1 | tee "${testLogFile}"
  ) || testStatus="$?" || true
  if [[ "${testStatus}" != "0" ]] && "installScripts_${SCRIPT}_breakOnTestFailure"; then
    # break if test script error
    exit "${testStatus}"
  fi
fi
