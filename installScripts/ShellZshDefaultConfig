#!/usr/bin/env bash
###############################################################################
# GENERATED FROM https://github.com/fchastanet/bash-dev-env/tree/master/src/_installScripts/_Configs/ShellZshDefaultConfig-binary.yaml
# DO NOT EDIT IT
# @generated
###############################################################################
# shellcheck disable=SC2288,SC2034



# ensure that no user aliases could interfere with
# commands used in this script
unalias -a || true
shopt -u expand_aliases

# shellcheck disable=SC2034
((failures = 0)) || true

# Bash will remember & return the highest exit code in a chain of pipes.
# This way you can catch the error inside pipes, e.g. mysqldump | gzip
set -o pipefail
set -o errexit

# Command Substitution can inherit errexit option since bash v4.4
shopt -s inherit_errexit || true

# if set, and job control is not active, the shell runs the last command
# of a pipeline not executed in the background in the current shell
# environment.
shopt -s lastpipe

# a log is generated when a command fails
set -o errtrace

# use nullglob so that (file*.php) will return an empty array if no file
# matches the wildcard
shopt -s nullglob

# ensure regexp are interpreted without accentuated characters
export LC_ALL=POSIX

export TERM=xterm-256color

# avoid interactive install
export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true

# store command arguments for later usage
# shellcheck disable=SC2034
declare -a BASH_FRAMEWORK_ARGV=("$@")
# shellcheck disable=SC2034
declare -a ORIGINAL_BASH_FRAMEWORK_ARGV=("$@")

# @see https://unix.stackexchange.com/a/386856
# shellcheck disable=SC2317
interruptManagement() {
  # restore SIGINT handler
  trap - INT
  # ensure that Ctrl-C is trapped by this script and not by sub process
  # report to the parent that we have indeed been interrupted
  kill -s INT "$$"
}
trap interruptManagement INT

################################################
# Temp dir management
################################################

KEEP_TEMP_FILES="${KEEP_TEMP_FILES:-0}"
export KEEP_TEMP_FILES

# PERSISTENT_TMPDIR is not deleted by traps
PERSISTENT_TMPDIR="${TMPDIR:-/tmp}/bash-framework"
export PERSISTENT_TMPDIR
if [[ ! -d "${PERSISTENT_TMPDIR}" ]]; then
  mkdir -p "${PERSISTENT_TMPDIR}"
fi

# shellcheck disable=SC2034
TMPDIR="$(mktemp -d -p "${PERSISTENT_TMPDIR:-/tmp}" -t bash-framework-$$-XXXXXX)"
export TMPDIR

# temp dir cleaning
# shellcheck disable=SC2317
cleanOnExit() {
  local rc=$?
  if [[ "${KEEP_TEMP_FILES:-0}" = "1" ]]; then
    Log::displayInfo "KEEP_TEMP_FILES=1 temp files kept here '${TMPDIR}'"
  elif [[ -n "${TMPDIR+xxx}" ]]; then
    Log::displayDebug "KEEP_TEMP_FILES=0 removing temp files '${TMPDIR}'"
    rm -Rf "${TMPDIR:-/tmp/fake}" >/dev/null 2>&1
  fi
  exit "${rc}"
}
trap cleanOnExit EXIT HUP QUIT ABRT TERM


SCRIPT_NAME=${0##*/}
REAL_SCRIPT_FILE="$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")"
if [[ -n "${EMBED_CURRENT_DIR}" ]]; then
  CURRENT_DIR="${EMBED_CURRENT_DIR}"
else
  CURRENT_DIR="${REAL_SCRIPT_FILE%/*}"
fi
FRAMEWORK_ROOT_DIR="$(cd "${CURRENT_DIR}/.." && pwd -P)"
FRAMEWORK_SRC_DIR="${FRAMEWORK_ROOT_DIR}/src"
FRAMEWORK_BIN_DIR="${FRAMEWORK_ROOT_DIR}/bin"
FRAMEWORK_VENDOR_DIR="${FRAMEWORK_ROOT_DIR}/vendor"
FRAMEWORK_VENDOR_BIN_DIR="${FRAMEWORK_ROOT_DIR}/vendor/bin"

# @description Log namespace provides 2 kind of functions
# - Log::display* allows to display given message with
#   given display level
# - Log::log* allows to log given message with
#   given log level
# Log::display* functions automatically log the message too
# @see Env::requireLoad to load the display and log level from .env file

# @description log level off
export __LEVEL_OFF=0
# @description log level error
export __LEVEL_ERROR=1
# @description log level warning
export __LEVEL_WARNING=2
# @description log level info
export __LEVEL_INFO=3
# @description log level success
export __LEVEL_SUCCESS=3
# @description log level debug
export __LEVEL_DEBUG=4

# @description verbose level off
export __VERBOSE_LEVEL_OFF=0
# @description verbose level info
export __VERBOSE_LEVEL_INFO=1
# @description verbose level info
export __VERBOSE_LEVEL_DEBUG=2
# @description verbose level info
export __VERBOSE_LEVEL_TRACE=3


# @description check if an element is contained in an array
#
# @arg $1 needle:String
# @arg $@ array:String[]
# @exitcode 0 if found
# @exitcode 1 otherwise
# @example
#   Array::contains "${libPath}" "${__BASH_FRAMEWORK_IMPORTED_FILES[@]}"
Array::contains() {
  local element
  for element in "${@:2}"; do
    [[ "${element}" = "$1" ]] && return 0
  done
  return 1
}


# @description concatenate each element of an array with a separator
# but wrapping text when line length is more than provided argument
# The algorithm will try not to cut the array element if it can.
# - if an arg can be placed on current line it will be,
#   otherwise current line is printed and arg is added to the new
#   current line
# - Empty arg is interpreted as a new line.
# - Add \r to arg in order to force break line and avoid following
#   arg to be concatenated with current arg.
#
# @arg $1 glue:String
# @arg $2 maxLineLength:int
# @arg $3 indentNextLine:int
# @arg $@ array:String[]
Array::wrap2() {
  local glue="${1-}"
  local -i glueLength="${#glue}"
  shift || true
  local -i maxLineLength=$1
  shift || true
  local -i indentNextLine=$1
  shift || true
  local indentStr=""
  if ((indentNextLine > 0)); then
    indentStr="$(head -c "${indentNextLine}" </dev/zero | tr '\0' " ")"
  fi
  if (($# == 0)); then
    return 0
  fi

  printCurrentLine() {
    if ((isNewline == 0)) || ((previousLineEmpty == 1)); then
      echo
    fi
    ((isNewline = 1))
    echo -en "${indentStr}"
    ((currentLineLength = indentNextLine)) || true
  }
  appendToCurrentLine() {
    local text="$1"
    local -i length=$2
    ((currentLineLength += length)) || true
    ((isNewline = 0)) || true
    if [[ "${text: -1}" = $'\r' ]]; then
      text="${text:0:-1}"
      echo -en "${text%%+([[:blank:]])}"
      printCurrentLine
    else
      echo -en "${text%%+([[:blank:]])}"
    fi
  }

  (
    local currentLine
    local -i currentLineLength=0 isNewline=1 argLength=0
    local -a additionalLines
    local -i previousLineEmpty=0
    local arg=""

    while (($# > 0)); do
      arg="$1"
      shift || true

      # replace tab by 2 spaces
      arg="${arg//$'\t'/  }"
      # remove trailing spaces
      arg="${arg%[[:blank:]]}"
      if [[ "${arg}" = $'\n' || -z "${arg}" ]]; then
        printCurrentLine
        ((previousLineEmpty = 1))
        continue
      else
        if ((previousLineEmpty == 1)); then
          printCurrentLine
        fi
        ((previousLineEmpty = 0)) || true
      fi
      # convert eol to args
      mapfile -t additionalLines <<<"${arg}"
      if ((${#additionalLines[@]} > 1)); then
        set -- "${additionalLines[@]}" "$@"
        continue
      fi

      ((argLength = ${#arg})) || true

      # empty arg
      if ((argLength == 0)); then
        if ((isNewline == 0)); then
          # isNewline = 0 means currentLine is not empty
          printCurrentLine
        fi
        continue
      fi

      if ((isNewline == 0)); then
        glueLength="${#glue}"
      else
        glueLength="0"
      fi
      if ((currentLineLength + argLength + glueLength > maxLineLength)); then
        if ((argLength + glueLength > maxLineLength)); then
          # arg is too long to even fit on one line
          # we have to split the arg on current and next line
          local -i remainingLineLength
          ((remainingLineLength = maxLineLength - currentLineLength - glueLength))
          appendToCurrentLine "${glue:0:${glueLength}}${arg:0:${remainingLineLength}}" "$((glueLength + remainingLineLength))"
          printCurrentLine
          arg="${arg:${remainingLineLength}}"
          # remove leading spaces
          arg="${arg##[[:blank:]]}"

          set -- "${arg}" "$@"
        else
          # the arg can fit on next line
          printCurrentLine
          appendToCurrentLine "${arg}" "${argLength}"
        fi
      else
        appendToCurrentLine "${glue:0:${glueLength}}${arg}" "$((glueLength + argLength))"
      fi
    done
    if [[ "${currentLine}" != "" ]] && [[ ! "${currentLine}" =~ ^[\ \t]+$ ]]; then
      printCurrentLine
    fi
  ) | sed -E -e 's/[[:blank:]]+$//'
}


# @description check if command specified exists or return 1
# with error and message if not
#
# @arg $1 commandName:String on which existence must be checked
# @arg $2 helpIfNotExists:String a help command to display if the command does not exist
#
# @exitcode 1 if the command specified does not exist
# @stderr diagnostic information + help if second argument is provided
Assert::commandExists() {
  local commandName="$1"
  local helpIfNotExists="$2"

  "${BASH_FRAMEWORK_COMMAND:-command}" -v "${commandName}" >/dev/null 2>/dev/null || {
    Log::displayError "${commandName} is not installed, please install it"
    if [[ -n "${helpIfNotExists}" ]]; then
      Log::displayInfo "${helpIfNotExists}"
    fi
    return 1
  }
  return 0
}


# @description check if param is valid email address
# @warning it is a very simple check, no RFC validation
# @arg $1 emailAddress:String the full email address
# @exitcode 1 if invalid email address
Assert::emailAddress() {
  local expectedRegexp="^\S+@\S+$"

  [[ "$1" =~ ${expectedRegexp} ]]
}


# @description asserts that first argument is file that exists with specified ownership
# @arg $1 file:String
# @arg $2 user:String expected owner user name of the file (default: USERNAME or id -un command)
# @arg $3 group:String expected owner group name of the file (default: USERGROUP or id -gn command)
# @env USERNAME String if arg $2 is not provided
# @env USERGROUP String if arg $3 is not provided
# @env SUDO String allows to use custom sudo prefix command
# @exitcode 1 if missing file
# @exitcode 2 if incorrect user ownership
# @exitcode 3 if incorrect group ownership
# @stderr diagnostics information is displayed
Assert::fileExists() {
  local file="$1"
  local user="${2:-${USERNAME}}"
  local group="${3:-${USERGROUP}}"
  if [[ -n "${user}" ]]; then
    Log::displayInfo "Check ${file} exists with user ${user}:${group}"
  else
    Log::displayInfo "Check ${file} exists"
  fi
  if ! ${SUDO:-} test -f "${file}" &>/dev/null; then
    Log::displayError "missing file ${file}"
    return 1
  fi
  if [[ -n "${user}" && "${user}" != "$(${SUDO:-} stat -c '%U' "${file}")" ]]; then
    Log::displayError "incorrect user ownership on file ${file}"
    return 2
  fi
  if [[ -n "${group}" && "${group}" != "$(${SUDO:-} stat -c '%G' "${file}")" ]]; then
    Log::displayError "incorrect group ownership on file ${file}"
    return 3
  fi
}


# @description asserts that file does not exist
# @arg $1 file:String
# @env SUDO String allows to use custom sudo prefix command
# @exitcode 1 existing file
# @env SUDO String allows to use custom sudo prefix command
# @stderr diagnostics information is displayed
Assert::fileNotExists() {
  local file="$1"
  Log::displayInfo "Checking file ${file} does not exist"
  if ${SUDO:-} test -f "${file}" &>/dev/null; then
    Log::displayError "file ${file} still exists"
    return 1
  fi
}


# @description check if argument respects 2 or more words separated by a space
# it supports accentuated characters and names with hyphen(-)
# @arg $1 firstNameLastName:String
# @exitcode 1 if regexp not matches
# @see https://regex101.com/r/JyyfOM/1
Assert::firstNameLastName() {
  local regexp="^[^ ]+([ ][^ ]+)+$"
  [[ $1 =~ ${regexp} ]]
}


# @description checks if function name provided exists
# @arg $1 functionName:String
# @exitcode 1 if function name doesn't exist
Assert::functionExists() {
  declare -F "$1" >/dev/null
}


# @description check if argument respects ldap login naming convention
# only using lowercase characters a-z
# @arg $1 ldapLogin:String
# @exitcode 1 if regexp not matches
Assert::ldapLogin() {
  [[ $1 =~ ^[a-z]+$ ]]
}


# @description check if tty (interactive mode) is active
# @noargs
# @exitcode 1 if tty not active
# @env NON_INTERACTIVE if 1 consider as not interactive even if environment is interactive
# @env INTERACTIVE if 1 consider as interactive even if environment is not interactive
Assert::tty() {
  if [[ "${NON_INTERACTIVE:-0}" = "1" ]]; then
    return 1
  fi
  if [[ "${INTERACTIVE:-0}" = "1" ]]; then
    return 0
  fi
  tty -s
}


# @description check if argument respects this framework variable naming convention
# - if variable begins with an uppercase or underscore, following letters have to be uppercase or underscore
# - variable name can includes ':' or '_' or digits but not as first letter
# here valid variable name examples
#
# @arg $1 variableName:String
# @exitcode 1 if regexp not matches
# @see https://regex101.com/r/BUlPXS/1
Assert::validVariableName() {
  [[ "$1" =~ (^[a-z][A-Za-z_0-9:]+$)|(^[A-Z_][A-Z_0-9:]+$) ]]
}


# @description checks if variable name provided exists
# @arg $1 varName:String
# @exitcode 1 if variable doesn't exist
# @exitcode 2 if variable value empty
# @exitcode 3 if variable name invalid
# @see Assert::validVariableName
# @stderr diagnostics information is displayed
Assert::varExistsAndNotEmpty() {
  local varName="$1"
  if ! Assert::validVariableName "${varName}"; then
    Log::displayError "${varName} - invalid variable name"
    return 3
  fi
  if [[ -z "${!varName+unset}" ]]; then
    Log::displayError "${varName} - not defined"
    return 1
  elif [[ -z "${!varName}" ]]; then
    Log::displayError "${varName} - please provide a value"
    return 2
  fi
}


# @description determine if the script is executed under WSL
# cspell:disable
# @example text
#   uname GitBash windows (with wsl) => MINGW64_NT-10.0 ZOXFL-6619QN2 2.10.0(0.325/5/3) 2018-06-13 23:34 x86_64 Msys
#   uname GitBash windows (wo wsl)   => MINGW64_NT-10.0 frsa02-j5cbkc2 2.9.0(0.318/5/3) 2018-01-12 23:37 x86_64 Msys
#   uname wsl => Linux ZOXFL-6619QN2 4.4.0-17134-Microsoft #112-Microsoft Thu Jun 07 22:57:00 PST 2018 x86_64 x86_64 x86_64 GNU/Linux
# cspell:enable
#
# @exitcode 1 on error
Assert::wsl() {
  [[ "$(uname -o)" = "GNU/Linux" ]]
}


# @description Backup given file in the same directory or in BACKUP_DIR directory
# backup file name is composed by following fields separated by -:
#   - if BACKUP_DIR is not empty then escaped dir name separated by @
#   - filename(without path)
#   - date with format %Y%m%d_%H:%M:%S (Eg: 20240326_14:45:08)
# @arg $1 file:String the file to backup
# @stderr messages about backup file location
# @env SUDO String allows to use custom sudo prefix command
# @env BACKUP_DIR if not set backup the file in the same directory as original file
# @exitcode 1 on copy failure
Backup::file() {
  local file="$1"
  if [[ -f "${file}" ]]; then
    local backupFile fileDirname escapedDirname
    fileDirname="${file%/*}"
    escapedDirname=${fileDirname/\//}      # remove first slash
    escapedDirname=${escapedDirname//\//@} # replace all slashes by @
    if [[ -z "${BACKUP_DIR:-}" ]]; then
      backupFile="${fileDirname}/${file##*/}-$(date +"%Y%m%d_%H:%M:%S")"
    else
      backupFile="${BACKUP_DIR}/${escapedDirname}@${file##*/}-$(date +"%Y%m%d_%H:%M:%S")"
    fi
    Log::displayInfo "Backup file '${file}' to ${backupFile}"
    ${SUDO:-} cp "${file}" "${backupFile}"
  fi
}


# @description get property value from file
# if not present compute it using propertyNotFoundCallback (if provided) and store it in property file
# @arg $1 propertyFile:String the file in which the property will be searched
# @arg $2 key:String the property key to search in property file
# @arg $3 propertyNotFoundCallback:Function (optional) a callback to call if property key is not found in property file
# @arg $@ args:String[] (optional) the arguments to pass to the propertyNotFoundCallback
# @exitcode 1 if value is not found
# @exitcode * if propertyNotFoundCallback fails
# @stdout the property value given by property file or by the propertyNotFoundCallback
Cache::getPropertyValue2() {
  local propertyFile="$1"
  local -n propertiesMap=$2
  local -n getPropertyValue2_val=$3
  local key="$4"
  local propertyNotFoundCallback=$5
  shift 5 || true
  local -a args=("$@")

  if [[ "${#propertiesMap[@]}" = "0" && -s "${propertyFile}" ]]; then
    local line
    while IFS="" read -r line; do
      if [[ "${line}" =~ ^([^=]+)=(.+)$ ]]; then
        propertiesMap["${BASH_REMATCH[1]}"]="${BASH_REMATCH[2]}"
      fi
    done <"${propertyFile}"
  fi

  if [[ -n "${propertiesMap[${key}]+abc}" ]]; then
    getPropertyValue2_val="${propertiesMap[${key}]}"
    return 0
  elif [[ "$(type -t "${propertyNotFoundCallback}")" = "function" ]]; then
    getPropertyValue2_val="$("${propertyNotFoundCallback}" "${args[@]}")" || return $?
    propertiesMap["${key}"]="${getPropertyValue2_val}"
    echo "${key}=${getPropertyValue2_val}" >>"${propertyFile}"
    return 0
  fi
  return 1
}


# @description convert base64 encoded back to target dir
# it is advised to include the md5sum of the binFile in the path of the target dir
#
# @arg $1 targetDir:string the directory in which tar archive will be untarred
# @arg $2 base64:string the base64 encoded tar czf archive
# @stderr diagnostics information is displayed
Compiler::Embed::extractDirFromBase64() {

  if [[ "${REQUIRE_FUNCTION_LINUX_REQUIRE_TAR_COMMAND_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::requireTarCommand has not been loaded"
    exit 1
  fi

  local targetDir="$1"
  local base64="$2"

  if [[ ! -d "${targetDir}" ]]; then
    mkdir -p "${targetDir}"
    (
      cd "${targetDir}" || exit 1
      base64 -d <<<"${base64}" | tar -xzf - 2>/dev/null || {
        Log::displayError "untar failure, invalid base64 string"
        exit 1
      }
    ) || return 1
  fi
}


# @description convert base64 encoded back to target file
# if target file is executable prepend dir of target
# file to PATH to make binary available everywhere
# it is advised to include in the path of the target file
# the md5sum of the binFile
#
# @arg $1 targetFile:String the file to write
# @arg $2 binFileBase64:String the base64 encoded file
# @arg $3 fileMode:String the chmod to set on the file
# @set PATH String prepend target embedded file binary directory to PATH variable if binary executable
Compiler::Embed::extractFileFromBase64() {
  local targetFile="$1"
  local binFileBase64="$2"
  local fileMode="${3:-+x}"
  local targetDir="${targetFile%/*}"

  if [[ ! -f "${targetFile}" ]]; then
    if [[ ! -d "${targetDir}" ]]; then
      mkdir -p "${targetDir}"
    fi
    base64 -d >"${targetFile}" <<<"${binFileBase64}"
    chmod "${fileMode}" "${targetFile}"
  fi

  if [[ -x "${targetFile}" ]]; then
    Env::pathPrepend "${targetDir}"
  fi
}


# @description copy folder structure to target directory
# merge embedDir with overridden directory if provided and available
# @arg $1 embedDir:String the path embedded
# @arg $2 overrideDir:String the path overridden
# @arg $3 subDir:String the sub-directory to copy from embedDir and/or overrideDir
# @arg $4 targetDir:String the target directory (default: ${HOME}/${subDir})
# @env SUDO String allows to use custom sudo prefix command
# @env HOME used for default value of targetDir arg
# @env OVERWRITE_CONFIG_FILES indicates if target directory should be overwritten if it exists
# @env PRETTY_ROOT_DIR used to make paths relative to this directory to reduce length of messages
# @env IGNORE_MISSING_SOURCE_DIR
Conf::copyStructure() {
  local embedDir="$1"
  local overrideDir="$2"
  local subDir="$3"
  local targetDir="${4:-${HOME}/${subDir}}"

  local configDir
  # shellcheck disable=SC2154
  configDir="$(Conf::getOverriddenDir "${embedDir}" "${overrideDir}")"
  if [[ -d "${configDir}/${subDir}" ]]; then
    # shellcheck disable=SC2154
    OVERWRITE_CONFIG_FILES=${OVERWRITE_CONFIG_FILES:-1} \
      PRETTY_ROOT_DIR="${embedDir%/*}" \
      Install::structure "${configDir}/${subDir}" "${targetDir}"
  elif [[ "${IGNORE_MISSING_SOURCE_DIR:-0}" = "1" ]]; then
    return 0
  else
    Log::displayError "Directory ${subDir} does not exists in '${embedDir}' or '${overrideDir}'"
    return 1
  fi
}


# @description generate temp directory where default
# and overridden directories have been merged
#   - if overridden dir exists, create a new temp folder
#     - copy all files from default folder
#     - overwrite with files from overridden folder
#     - (Later) delete files listed in .remove$$ file
#     - return the path of this temp folder
#   - else just return the default folder path
# Then it is easier to pick overridden or default files/folders
#
# @arg $1 defaultDir:String usually the embed directory
# @arg $2 overriddenDirPath:String the path to the directory
#   that could be overridden
# @exitcode 1 if default dir does not exist
# @exitcode 2 if error during copy
Conf::getOverriddenDir() {
  local -a overriddenDirPaths=("$@")
  local overriddenDirPath

  local tempDir
  tempDir="$(mktemp -d)"
  (
    shopt -s dotglob
    for overriddenDirPath in "${overriddenDirPaths[@]}"; do
      if [[ -d "${overriddenDirPath}" && -n "$(ls -A "${overriddenDirPath}" || true)" ]]; then
        Log::displayInfo "Conf::getOverriddenDir - use overridden files from ${overriddenDirPath}"
        cp -R "${overriddenDirPath}/." "${tempDir}"
      else
        if [[ -z "${overriddenDirPath}" ]]; then
          Log::displayError "Conf::getOverriddenDir - empty overridden directory path"
        else
          Log::displayInfo "Conf::getOverriddenDir - directory ${overriddenDirPath} does not exist or is empty"
        fi
      fi
    done
  ) || {
    Log::displayError "Conf::getOverriddenDir - error during copy"
    return 2
  }
  echo "${tempDir}"
}


# @description list files of dir with given extension and display it as a list one by line
#
# @arg $1 dir:String the directory to list
# @arg $2 prefix:String the profile file prefix (default: "")
# @arg $3 ext:String the extension
# @arg $4 findOptions:String find options, eg: -type d (Default value: '-type f')
# @arg $5 indentStr:String the indentation can be any string compatible with sed not containing any / (Default value: '       - ')
# @stdout list of files without extension/directory
# @example text
#       - default.local
#       - default.remote
#       - localhost-root
# @exitcode 1 if directory does not exists
Conf::list() {
  local dir="$1"
  local prefix="${2:-}"
  local ext="${3}"
  local findOptions="${4--type f}"
  local indentStr="${5-       - }"

  if [[ ! -d "${dir}" ]]; then
    Log::displayError "Directory ${dir} does not exist"
  fi
  if [[ -n "${ext}" && "${ext:0:1}" != "." ]]; then
    ext=".${ext}"
  fi
  (
    # shellcheck disable=SC2086
    cd "${dir}" &&
      find . -maxdepth 1 ${findOptions} -name "${prefix}*${ext}" |
      sed -E "s#^\./${prefix}##g" |
        sed -E "s#${ext}\$##g" | sort | sed -E "s#^#${indentStr}#"
  )
}


# @description Load the nearest config file
# in next example will search first .framework-config file in "srcDir1"
# then if not found will go in up directories until /
# then will search in "srcDir2"
# then if not found will go in up directories until /
# source the file if found
# @example
#   Conf::loadNearestFile ".framework-config" "srcDir1" "srcDir2"
#
# @arg $1 configFileName:String config file name to search
# @arg $2 loadedFile:String (passed by reference) will return the loaded config file name
# @arg $@ srcDirs:String[] source directories in which the config file will be searched
# @exitcode 0 if file found
# @exitcode 1 if file not found
Conf::loadNearestFile() {
  local configFileName="$1"
  local -n loadedFile="$2"
  shift 2 || true
  local -a srcDirs=("$@")
  for srcDir in "${srcDirs[@]}"; do
    configFile="$(File::upFind "${srcDir}" "${configFileName}" || true)"
    if [[ -n "${configFile}" ]]; then
      # shellcheck source=/.framework-config
      source "${configFile}" || Log::fatal "error while loading config file '${configFile}'"
      Log::displayDebug "Config file ${configFile} is loaded"
      # shellcheck disable=SC2034
      loadedFile="${configFile}"
      return 0
    fi
  done

  Log::displayDebug "Config file '${configFileName}' not found in any source directories provided"
  return 1
}


# @description check validity of .env variables
# @env CHECK_ENV int 0 to avoid checking environment
# @noargs
Engine::Config::checkEnv() {
  local envFile="$1"
  if [[ "${CHECK_ENV:-1}" = "0" ]]; then
    return 0
  fi
  # avoid checks if .env file didn't changed
  local envFileMd5Cache="${PERSISTENT_TMPDIR:-/tmp}/bash-dev-env-enf-file-checksum"
  if md5sum -c "${envFileMd5Cache}" &>/dev/null; then
    return 0
  else
    md5sum "${envFile}" >"${envFileMd5Cache}"
  fi
  local errorCount=0 || true
  checkNotEmpty() {
    local var="$1"
    if ! Assert::varExistsAndNotEmpty "${var}"; then
      ((++errorCount))
      return 1
    fi
  }
  checkVarAndDir() {
    local var="$1"
    local mode="${2:-}"
    local status=0
    if checkNotEmpty "${var}"; then
      if [[ ! -d "${!var}" ]] && ! mkdir -p "${!var}"; then
        Log::displayError "variable ${var} - impossible to create the directory '${!var}'"
        ((errorCount++))
        return 1
      fi
      if [[ "${mode}" =~ w && ! -w "${!var}" ]]; then
        Log::displayError "variable ${var} - directory '${!var}' is not writable"
        ((status++))
        ((errorCount++))
      fi
      if [[ "${mode}" =~ r && ! -r "${!var}" ]]; then
        Log::displayError "variable ${var} - directory '${!var}' is not accessible"
        ((status++))
        ((errorCount++))
      fi
    fi

    return "${status}"
  }
  checkValidValues() {
    local var="$1"
    shift || true
    local -a validValues=("$@")
    if ! Array::contains "${!var}" "${validValues[@]}"; then
      Log::displayError "variable ${var} - value ${!var} is not part of the following values ${validValues[*]}"
      ((++errorCount))
    fi
  }
  checkIsArray() {
    local var="$1"
    declare -p "${var}" 2>/dev/null | grep -q 'declare \-a'
  }

  if ! echo "${ID}" | grep -qEw 'debian|ubuntu'; then
    Log::fatal "This script is built to support only Debian or Ubuntu distributions. You are using ${ID}."
  fi

  if checkNotEmpty USERNAME && ! getent passwd "${USERNAME}" 2>/dev/null >/dev/null; then
    Log::displayError "USERNAME - user '${USERNAME}' does not exist"
    ((errorCount++))
  fi

  if [[ -n "${SSH_LOGIN:-}" ]] && ! Assert::ldapLogin "${SSH_LOGIN}"; then
    Log::displayError "SSH_LOGIN - invalid ldap login (format expected firstNameLastName) in ${BASH_DEV_ENV_ROOT_DIR}/.env file"
    ((errorCount++))
  fi

  if checkNotEmpty "GIT_USERNAME" && ! Assert::firstNameLastName "${GIT_USERNAME}"; then
    Log::displayError "GIT_USERNAME - invalid format, expected : firstName lastName"
    ((errorCount++))
  fi

  if checkNotEmpty "GIT_USER_MAIL" && ! Assert::emailAddress "${GIT_USER_MAIL}"; then
    Log::displayError "GIT_USER_MAIL - invalid email address"
    ((errorCount++))
  fi

  if checkNotEmpty "AWS_USER_MAIL" && ! Assert::emailAddress "${AWS_USER_MAIL}"; then
    Log::displayError "AWS_USER_MAIL - invalid email address"
    ((errorCount++))
  fi

  if ! checkIsArray "CONF_OVERRIDE_DIRS"; then
    Log::displayError "CONF_OVERRIDE_DIRS - invalid format, expected : array of strings"
    ((errorCount++))
  fi
  ((i = 0)) || true
  local dir
  for dir in "${CONF_OVERRIDE_DIRS[@]}"; do
    if [[ ! -d "${dir}" ]]; then
      Log::displayError "CONF_OVERRIDE_DIRS[${i}] - directory '${dir}' does not exist"
      ((errorCount++))
    fi
    if [[ ! -r "${dir}" ]]; then
      Log::displayError "CONF_OVERRIDE_DIRS[${i}] - directory '${dir}' is not readable"
      ((errorCount++))
    fi
    ((++i))
  done
  checkVarAndDir PROJECTS_DIR r || true
  checkVarAndDir BACKUP_DIR rw || true
  checkVarAndDir LOGS_DIR rw || true
  checkVarAndDir INSTALL_SCRIPTS_ROOT_DIR r || true
  checkVarAndDir HOME rw || true

  checkValidValues UPGRADE_UBUNTU_VERSION 0 lts dev
  checkValidValues PREFERRED_SHELL ShellBash ShellZsh
  checkValidValues ZSH_PREFERRED_THEME ohmyposh powerlevel10k/powerlevel10k sindresorhus/pure starship/starship

  checkValidValues SHOW_FORTUNES 0 1
  checkValidValues SHOW_MOTD 0 1
  checkValidValues OVERWRITE_CONFIG_FILES 0 1
  checkValidValues CHANGE_WINDOWS_FILES 0 1
  checkValidValues CAN_TALK_DURING_INSTALLATION 0 1
  checkValidValues INSTALL_INTERACTIVE 0 1

  checkNotEmpty WSLCONFIG_MAX_MEMORY
  checkValidValues WSLCONFIG_SWAP 0 1
  export CHECK_ENV=0
  return "${errorCount}"
}


# @description if .env does not exist, initialize it with .env.template
Engine::Config::createEnvFileFromTemplate() {
  local envFile="$1"
  local envFileTemplate="$2"

  if [[ ! -f "${envFile}" ]]; then
    echo "${envFileTemplate}" >"${envFile}"
    Log::displayError "a default env file has been created, please edit ${envFile}"
    return 1
  fi
}


# @description load .env file
# @arg $1 envFile:String the file to load
Engine::Config::loadConfig() {
  if [[ "${BASH_DEV_ENV_CONFIG_LOADED:-0}" = "1" ]]; then
    return 0
  fi
Linux::requireTarCommand
Compiler::Embed::extractFileFromBase64 \
  "${PERSISTENT_TMPDIR:-/tmp}/e45723bdbf29adda89f24f72a94da7e21df12389872dca4558684132a580a936/envFileTemplate" \
  "IyEvYmluL2Jhc2gKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0CgojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiMgR2VuZXJhbCBpbmZvcm1hdGlvbgojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgojIHdzbCB1c2VybmFtZSB3aXRoIGRlZmF1bHQgcGFzc3dvcmQgd3NsClVTRVJOQU1FPSJ3c2wiCgpIT01FPSIvaG9tZS93c2wiCgpXSU5ET1dTX1VTRVJOQU1FPSJGcmFuY29pc0NoYXN0YW5ldCIKCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KIyBHaXQgJiBTU0ggaW5mb3JtYXRpb24KIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyBpZiAxLCBpdCBpbmRpY2F0ZXMgeW91IGFjY2VwdCB0aGF0IHlvdXIgZ2l0IGtleSB3aWxsIGJlIGxvYWRlZC4KIyBpZiAwLCBjb25maWd1cmF0aW9ucyB0aGF0IG5lZWQgdG8gYmUgYXV0aGVudGljYXRlZCB3aWxsIGJlIHNraXBwZWQuCiMgRGlzdHJvIG1vZGU6IGluIGFueSBjYXNlLCB5b3VyIGtleSBpcyBub3QgY29waWVkLgpBVVRIT1JJWkVfU1NIX0tFWV9VU0FHRT0xCgojIHlvdXIgbG9naW4gdG8gY29ubmVjdCB0byBzc2ggc2VydmVycyBpZiBhbnkKU1NIX0xPR0lOPSIiCgojIHlvdXIgZ2l0IGZ1bGwgbmFtZSAnRmlyc3ROYW1lIExhc3ROYW1lJwpHSVRfVVNFUk5BTUU9IiIKCiMgZW1haWwgdXNlZCBmb3IgZ2l0ICdsZGFwQGRvbWFpbi5jb20nCkdJVF9VU0VSX01BSUw9IiIKCiMgZGVmYXVsdCBnaXQgbWVyZ2UgdG9vbCB0byB1c2UKR0lUX01FUkdFX1RPT0w9InZzY29kZSIKCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KIyBBV1MgaW5mb3JtYXRpb24KIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyBlbWFpbCB1c2VkIHRvIGNvbm5lY3QgdG8gYXdzCkFXU19VU0VSX01BSUw9ImZjaGFzdGFuZXRAZ21haWwuY29tIgoKIyBhcHAgaWQgdG8gY29ubmVjdCB0byBhd3MgYWNjb3VudApBV1NfQVBQX0lEPSIiCgpBV1NfUFJPRklMRT0iIgpBV1NfREVGQVVMVF9SRUdJT049IiIKQVdTX1RFU1RfU0VDUkVUX0lEPSIiCkFXU19ERUZBVUxUX0RPQ0tFUl9SRUdJU1RSWV9JRD0iIgoKIyB3aWxsIHVzZSBhd3MgY29uZmlndXJlIHNzbyB0byBjb25uZWN0IHRvIGF3cyAoaW5zdGVhZCBvZiBzYW1sMmF3cykKVVNFX0FXU19DT05GSUdVUkVfU1NPPTEKCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KIyBLOFMgaW5mb3JtYXRpb24KIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyBLdWJlRGVmYXVsdENvbmZpZyB+Ly5rdWJlL2NvbmZpZyBnZW5lcmF0aW9uCiMgYXdzIHJlZ2lvbiBvZiB0aGUgY2x1c3RlciAoRWc6IHVzLWVhc3QtMSkKS1VCRV9DT05GSUdfUkVHSU9OX0NPREU9CgojIGF3cyBhcm4gb2YgdGhlIGNsdXN0ZXIuCiMgRWc6IGFybjphd3M6ZWNzOnJlZ2lvbjphd3NfYWNjb3VudF9pZDpjbHVzdGVyL015Q2x1c3RlcgpLVUJFX0NPTkZJR19DTFVTVEVSX0FSTj0KCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KIyBEaXJlY3RvcmllcwojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgojIG92ZXJyaWRkZW4gY29uZiBkaXJlY3RvcnkgdGhhdCB3aWxsIGJlIHVzZWQgdG8gb3ZlcnJpZGUKIyB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHRoYXQgYXJlIGVtYmVkZGVkIGluIGJpbmFyaWVzCkNPTkZfT1ZFUlJJREVfRElSUz0oCiAgIiR7QkFTSF9ERVZfRU5WX1JPT1RfRElSfS9jb25mLm92ZXJyaWRlIgopCgojIHdoZXJlIHRvIGluc3RhbGwgYmFzaC10b29scywgLi4uCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjE1MwpQUk9KRUNUU19ESVI9IiR7SE9NRX0vcHJvamVjdHMiCgojIHdoZXJlIG92ZXJyaWRkZW4gY29uZmlnIGZpbGVzIHdpbGwgYmUgYmFja2VkIHVwCkJBQ0tVUF9ESVI9IiR7QkFTSF9ERVZfRU5WX1JPT1RfRElSfS9iYWNrdXAiCiMgYmFja3VwIGZpbGVzL2RpcnMgYmVmb3JlIGluc3RhbGxpbmcgbmV3IGZpbGUgKHVzdWFsbHkgMSwgYnV0IDAgaWYgdXNpbmcgZGlzdHJvKQpCQUNLVVBfQkVGT1JFX0lOU1RBTEw9MQoKIyBsb2dzIGRpcmVjdG9yeQpMT0dTX0RJUj0iJHtCQVNIX0RFVl9FTlZfUk9PVF9ESVJ9L2xvZ3MiCgojIGluc3RhbGxTY3JpcHRzIHJvb3QgZGlyCklOU1RBTExfU0NSSVBUU19ST09UX0RJUj0iJHtCQVNIX0RFVl9FTlZfUk9PVF9ESVJ9L2luc3RhbGxTY3JpcHRzIgoKIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQojIEluc3RhbGxhdGlvbiBjb25maWd1cmF0aW9uCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiMgQ29uZmlndXJhdGlvbiBmaWxlcyBhcmUgb3ZlcndyaXR0ZW4gZXZlbiBpZiBleGlzdHMKIyAhISEhIEZpcnN0IHRpbWUgaW5pdGlhbGl6YXRpb246IGxldCB0aGlzIHZhbHVlIHRvIDEgISEhIQojIFZhbHVlIDA6CiMgLSBJZiB0YXJnZXQgY29uZmlndXJhdGlvbiBmaWxlIGV4aXN0cywgZGlzcGxheXMgYSBtZXNzYWdlIGFuZCBkbyBub3Qgb3ZlcndyaXRlIHRoZSBmaWxlCiMgLSBJZiB0YXJnZXQgY29uZmlndXJhdGlvbiBmaWxlIGRvZXNuJ3QgZXhpc3QsIGluc3RhbGxzIHRoZSBmaWxlCiMgVmFsdWUgMQojIC0gaW5zdGFsbCBvciBvdmVyd3JpdGUgdGhlIGZpbGUgd2l0aG91dCBjaGVja2luZyBleGlzdGVuY2UKT1ZFUldSSVRFX0NPTkZJR19GSUxFUz0xCgojIFdpbmRvd3MgZmlsZXMgY2FuIGJlIG92ZXJyaWRkZW4gaWYgMQojIGlmIDAKIyAtIHNraXAgY2hhbmdlcyB0byAlVVNFUlBST0ZJTEUlLy53c2xjb25maWcKIyAtIHNraXAgY29weWluZyBmb250cwpDSEFOR0VfV0lORE9XU19GSUxFUz0xCgojIEluZGljYXRlIHRoYXQgaW5zdGFsbCBzY3JpcHQgY2FuIHdhcm4geW91IHVzaW5nIHNwZWFrZXIgd2hlbiB5b3VyIGlucHV0IGlzIG5lZWRlZApDQU5fVEFMS19EVVJJTkdfSU5TVEFMTEFUSU9OPTEKCiMgaWYgMCBpbnN0YWxsIHNjcmlwdCB3aWxsIHNraXAgYWxsIGludGVyYWN0aXZlIGFjdGl2aXR5IChzYW1sMmF3cywgLi4uKSwKIyBzbyBkZXBlbmRlbnQgaW5zdGFsbGF0aW9uIHdpbGwgYmUgc2tpcHBlZCBhcyB3ZWxsCklOU1RBTExfSU5URVJBQ1RJVkU9MQoKIyBkaXNwbGF5IGVsYXBzZWQgdGltZSBzaW5jZSBsYXN0IGxvZwpESVNQTEFZX0RVUkFUSU9OPTEKCiMgMCAgID0+IG5vIHVwZ3JhZGUgYXQgYWxsCiMgbHRzID0+IFVQR1JBREUgdG8gbGF0ZXN0IHVidW50dSBsdHMgdmVyc2lvbgojIGRldiA9PiBVUEdSQURFIHRvIGxhdGVzdCB1YnVudHUgZGV2IHZlcnNpb24KIyBVc2UgaWYgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLAojIGNvdWxkIGNhdXNlIHNvbWUgcGFja2FnZXMgdG8gbm90IGJlaW5nIGF2YWlsYWJsZSB5ZXQKVVBHUkFERV9VQlVOVFVfVkVSU0lPTj0wCgojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiMgUHJvZmlsZSBjb25maWd1cmF0aW9uCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiMgQ2hvb3NlIHlvdXIgcHJlZmVycmVkIHNoZWxsCiMgcG9zc2libGUgY2hvaWNlczogU2hlbGxCYXNoIChMZWdhY3kgZXhwZXJpZW5jZSksIFNoZWxsWnNoIChSZWNvbW1lbmRlZCBleHBlcmllbmNlKQpQUkVGRVJSRURfU0hFTEw9IlNoZWxsWnNoIgoKIyBac2ggdGhlbWUgdG8gdXNlCiMgcG9zc2libGUgY2hvaWNlczogcG93ZXJsZXZlbDEway9wb3dlcmxldmVsMTBrLCBvaG15cG9zaCwgc2luZHJlc29yaHVzL3B1cmUsIHN0YXJzaGlwL3N0YXJzaGlwClpTSF9QUkVGRVJSRURfVEhFTUU9InBvd2VybGV2ZWwxMGsvcG93ZXJsZXZlbDEwayIKCiMgaWYgcHJlZmVycmVkIHRoZW1lIGlzIG9obXlwb3NoLCB0aGUgcGF0aCB0byB0aGUgdGhlbWUgZmlsZQpQT1NIX1RIRU1FX1BBVEg9IiR7SE9NRX0vLmJhc2gtZGV2LWVudi90aGVtZXMuZC9vaG15cG9zaFRoZW1lcy9qYW5kZWRvYmJlbGVlci55YW1sIgoKIyBpZiBwcmVmZXJyZWQgdGhlbWUgaXMgc3RhcnNoaXAKU1RBUlNISVBfVEhFTUU9IiR7SE9NRX0vLmJhc2gtZGV2LWVudi90aGVtZXMuZC9zdGFyc2hpcFRoZW1lcy9kZWZhdWx0LnRvbWwiClNUQVJTSElQX0NBQ0hFPSIke0hPTUV9Ly5jYWNoZS8uc3RhcnNoaXAiCgojIERpc3BsYXkgRm9ydHVuZSB0b29sdGlwIGF0IGJhc2gvenNoIHNlc3Npb24gb3BlbgpTSE9XX0ZPUlRVTkVTPTEKCiMgRGlzcGxheSBNT1REIGF0IGJhc2gvenNoIHNlc3Npb24gb3BlbgpTSE9XX01PVEQ9MQoKIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQojIFdTTENPTkZJRwojIFRoZXNlIHBhcmFtZXRlcnMgYXV0b21hdGljYWxseSBjb25maWd1cmUgJVVTRVJQUk9GSUxFJS8ud3NsY29uZmlnIGZpbGUuCiMgQHNlZSBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy93aW5kb3dzL3dzbC93c2wtY29uZmlnCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiMgUmVjb21tZW5kZWQgNTAlIG9mIHRvdGFsIG1lbW9yeQpXU0xDT05GSUdfTUFYX01FTU9SWT04R0IKCiMgcGVyc29uYWxseSBJIHByZWZlciBydW4gb3V0IG9mIG1lbW9yeSBpbnN0ZWFkIG9mIGJlZ2lubmluZyBzd2FwcGluZwojIFNvIEkga25vdyBpbW1lZGlhdGVseSBpZiBzb21lIHByb2Nlc3NlcyBoYXZlIHRvIGJlIHN0b3BwZWQKV1NMQ09ORklHX1NXQVA9MAoKIyBpZiAxIGl0IHdpbGwgY29tcHV0ZSBhdXRvbWF0aWNhbGx5IHRoZSBtYXggdmhkIHNpemUKIyBkZWZhdWx0ICgxLzMgb2YgZGlzayBzaXplLCBtaW4gMTUwR0IpCiMgaWYgMCBpdCB3aWxsIHVzZSB3c2wgZGVmYXVsdCB2YWx1ZSAoMVRCKQpXU0xDT05GSUdfQ09NUFVURV9NQVhfVkhEX1NJWkU9MQoKIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQojIEhhY2tzCiMgb24gc29tZSBjb25maWd1cmF0aW9ucyB3ZSBoYXZlIHRvIGZvcmNlIHBhdGggb2Ygc29tZSB3aW5kb3dzIGNvbW1hbmRzCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiNQT1dFUlNIRUxMX0JJTj0vbW50L2MvV2luZG93cy9TeXN0ZW0zMi9XaW5kb3dzUG93ZXJTaGVsbC92MS4wL3Bvd2Vyc2hlbGwuZXhlCiNJUENPTkZJR19CSU49L21udC9jL1dpbmRvd3Mvc3lzdGVtMzIvaXBjb25maWcuZXhlCiNXU0xfRVhFX0JJTj0vbW50L2MvV2luZG93cy9zeXN0ZW0zMi93c2wuZXhlCgojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiMgR2VuZXJhbCBkaXN0cmlidXRpb24gaW5mb3JtYXRpb24KIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyBob3N0bmFtZSBvZiB0aGUgZGlzdHJvCkRJU1RST19IT1NUTkFNRT0id3NsSG9zdCIK" \
  "755"

declare -gx embed_file_envFileTemplate="${PERSISTENT_TMPDIR:-/tmp}/e45723bdbf29adda89f24f72a94da7e21df12389872dca4558684132a580a936/envFileTemplate"

  local envFile="${BASH_DEV_ENV_ROOT_DIR}/.env"
  # shellcheck disable=SC2154
  Engine::Config::createEnvFileFromTemplate \
    "${envFile}" "${embed_file_envFileTemplate}" || exit 1
  set -o allexport
  # shellcheck source=/.env.template
  source <(echo "${embed_file_envFileTemplate}")
  # shellcheck source=/.env
  source "${BASH_DEV_ENV_ROOT_DIR}/.env"
  set +o allexport
  export STATS_DIR="${LOGS_DIR}/stats"
  if [[ ! -d "${STATS_DIR}" ]]; then
    mkdir -p "${STATS_DIR}" || true
  fi
  export LOGS_INSTALL_SCRIPTS_DIR="${LOGS_DIR}/installScripts"
  if [[ ! -d "${LOGS_INSTALL_SCRIPTS_DIR}" ]]; then
    mkdir -p "${LOGS_INSTALL_SCRIPTS_DIR}" || true
  fi

  # load environment variables ID, VERSION_CODENAME
  Engine::Config::loadOsRelease
  Engine::Config::loadUserVariables

  if ! Engine::Config::checkEnv "${BASH_DEV_ENV_ROOT_DIR}/.env"; then
    Log::displayError "one or more variables are invalid, check above logs and fix '${envFile}' file accordingly"
    return 1
  fi

  Engine::Config::loadHostIp

  Engine::Config::requireWslu

  #Linux::Wsl::initEnv
  Engine::Config::loadWslVariables

  Log::requireLoad

  Engine::Config::loadSshKey

  Engine::Config::loadLocaleConfig

  export BASH_DEV_ENV_CONFIG_LOADED=1
}


# @description deduce wsl host ip
# @set HOST_IP exported env containing the IP
Engine::Config::loadHostIp() {
  HOST_IP="$(/sbin/ip route | awk '/default/ { print $3 }')"

  export HOST_IP
}


# @description load locale configuration
Engine::Config::loadLocaleConfig() {
  if [[ "${BASH_DEV_ENV_CONFIG_LOADED:-0}" = "1" ]]; then
    return 0
  fi
  if [[ "${LOAD_LOCALE_CONFIG:-1}" = "1" && ! -f "${PERSISTENT_TMPDIR}/localeConfig.initialized" ]]; then
    Log::displayInfo "Initializing locale en_US.UTF-8"
    export PATH="${PATH}:${HOME}/.local/bin"
    sudo sed -E -i -e 's/# en_US.UTF-8 UTF-8/en_US.UTF-8 UTF-8/' /etc/locale.gen
    echo 'LANG="en_US.UTF-8"' | sudo tee /etc/default/locale >/dev/null
    echo "LANG=en_US.UTF-8" | sudo tee /etc/locale.conf >/dev/null
    sudo locale-gen en_US.UTF-8
    sudo dpkg-reconfigure --frontend=noninteractive locales
    export LC_ALL=C
    export LANG=en_US.UTF-8
    export LC_MESSAGES=en_US.UTF-8
    touch "${PERSISTENT_TMPDIR}/localeConfig.initialized"
  fi
}


# @description load /etc/os-release file
# @set NAME
# @set VERSION
# @set ID
# @set ID_LIKE
# @set PRETTY_NAME
# @set VERSION_ID
# @set HOME_URL
# @set SUPPORT_URL
# @set BUG_REPORT_URL
# @set PRIVACY_POLICY_URL
# @set VERSION_CODENAME
# @set UBUNTU_CODENAME
Engine::Config::loadOsRelease() {
  if [[ ! -f /etc/os-release ]]; then
    Log::displayError "file /etc/os-release does not exists"
    return 1
  fi
  # This will load environment variables ID, VERSION_CODENAME, ...
  set -o allexport
  source /etc/os-release
  set +o allexport
}


# @description load pageant and ssh key
# you can provide ssh key by env variable SSH_PRIVATE_KEY
# or if empty, file ~/.ssh/id_rsa will be used if present
# @env SSH_PRIVATE_KEY ssh key provided by env variable
# @env AUTHORIZE_SSH_KEY_USAGE if 0, no ssh key is loaded
# @env LOAD_SSH_KEY feature flag used in distro mode
# @env SKIP_REQUIRES ignore loading if set to 1
Engine::Config::loadSshKey() {
  if [[ "${LOAD_SSH_KEY:-1}" = "0" || "${SKIP_REQUIRES:-0}" = "1" ]]; then
    # ignore in distro mode
    return 0
  fi
  if [[ "${AUTHORIZE_SSH_KEY_USAGE:-0}" = "0" ]]; then
    Log::displaySkipped "Ssh key will not be loaded as you set AUTHORIZE_SSH_KEY_USAGE to 0"
    return 0
  fi
  if [[ -n "${SSH_AUTH_SOCK}" && -n "${SSH_AGENT_PID}" ]]; then
    Log::displaySkipped "Ssh agent skipped as variables SSH_AUTH_SOCK and SSH_AGENT_PID are set"
    return 0
  fi

  if [[ -z "${SSH_PRIVATE_KEY}" && ! -f "${HOME}/.ssh/id_rsa" ]]; then
    Log::displayError "File '${HOME}/.ssh/id_rsa' is missing and env variable SSH_PRIVATE_KEY is empty"
    return 1
  fi
  local errorCode=0
  ssh-add -l &>/dev/null || errorCode=$?
  if [[ "${errorCode}" = "2" ]]; then
    # ssh agent is not started
    Log::displayInfo "Starting ssh agent"
    eval "$(ssh-agent)" || return 2
    export SSH_AUTH_SOCK
    export SSH_AGENT_PID
  fi

  if [[ -n "${SSH_PRIVATE_KEY}" ]]; then
    base64 -d <<<"${SSH_PRIVATE_KEY}" >"${HOME}/.ssh/id_rsa" || {
      Log::displayError "Failed to decode SSH_PRIVATE_KEY"
      return 2
    }
    chmod 600 "${HOME}/.ssh/id_rsa" || {
      Log::displayError "Failed to set permissions on SSH key"
      return 3
    }
  fi
  ssh-keygen -f ~/.ssh/id_rsa -y >~/.ssh/id_rsa.pub || {
    Log::displayError "Failed to generate public key from private key"
    return 4
  }
  ssh-add "${HOME}/.ssh/id_rsa" || return 5

  # Check key has been added to ssh agent
  ssh-add -l &>/dev/null || {
    Log::displayError "Your ssh key has not been loaded"
    return 6
  }
}


# @description deduce HOME, USER_ID, USERGROUP_ID and USERGROUP from USERNAME
# @env USERNAME String the name of the user
# @set USER_ID String
# @set USERGROUP String
# @set USERGROUP_ID String
# @set USER_SHELL String current user shell
# @set HOME String
# @env REMOTE String prefix command to run commands remotely
Engine::Config::loadUserVariables() {
  # deduce user home and group
  local -a split
  local IFS=':'
  # shellcheck disable=SC2207
  split=($(${REMOTE:-} getent passwd "${USERNAME}"))
  USER_ID="${split[2]}"
  USERGROUP_ID="${split[3]}"
  HOME="${split[5]}"
  USER_SHELL="${split[6]}"
  USERGROUP="$(${REMOTE:-} id -gn "${USERNAME}")"

  if [[ -z "${USERGROUP}" || -z "${HOME}" ]]; then
    Log::displayError "USERNAME - unable to deduce USERGROUP, HOME from USERNAME"
    return 1
  fi

  export HOME
  export USER_ID
  export USERGROUP_ID
  export USERGROUP
  export USER_SHELL
}


# @description load wsl env variables
# @set BASE_MNT_C
# @set WINDOWS_DIR
# @set WINDOWS_PROFILE_DIR
# @set LOCAL_APP_DATA
# @set WINDOW_PATH
# @set WSL_EXE_BIN
# @set IPCONFIG_BIN
# @set POWERSHELL_BIN
# @env WSL_EXE_BIN
# @env IPCONFIG_BIN
# @env POWERSHELL_BIN
Engine::Config::loadWslVariables() {
  if ! Assert::wsl; then
    # skip
    return 0
  fi

  local IFS=' '
  local -a split=()
  # shellcheck disable=SC2207
  split=($(grep -m 1 -E 'C:\\[^ ]+ ([^ ]+) ' /proc/mounts 2>/dev/null)) || {
    # probably not wsl after all
    return 0
  }
  # shellcheck disable=SC1003
  BASE_MNT_C="${split[1]}"
  export BASE_MNT_C

  Linux::Wsl::cachedWslpathFromWslVar2 WINDOWS_DIR SystemRoot
  WINDOWS_DIR="${WINDOWS_DIR:-${BASE_MNT_C:-/mnt/c}/Windows}"
  export WINDOWS_DIR

  Linux::Wsl::cachedWslpathFromWslVar2 WINDOWS_PROFILE_DIR USERPROFILE
  WINDOWS_PROFILE_DIR="${WINDOWS_PROFILE_DIR:-${BASE_MNT_C:-/mnt/c}/Users/${WINDOWS_USERNAME}}"
  export WINDOWS_PROFILE_DIR

  Linux::Wsl::cachedWslpathFromWslVar2 LOCAL_APP_DATA LOCALAPPDATA
  export LOCAL_APP_DATA

  # WINDOW_PATH
  Linux::Wsl::cachedWslvar2 WINDOW_PATH PATH
  WINDOW_PATH="${WINDOW_PATH//;/:}"
  WINDOW_PATH="${WINDOW_PATH//\\//}"
  WINDOW_PATH="${WINDOW_PATH//C:/${BASE_MNT_C:-/mnt/c}}"

  deduceBin() {
    local var="$1"
    local expectedFullPath="$2"
    local expectedBin="$3"
    if [[ -z "${!var+xxx}" ]]; then
      eval "${var}=${expectedFullPath}"
      if ! command -v "${!var}" >/dev/null 2>&1; then
        eval "${var}=$(command -v "${expectedBin}" 2>/dev/null)"
      fi
    fi
    if [[ -z "${!var:-}" ]] || ! command -v "${!var}" >/dev/null 2>&1; then
      Log::fatal "variable ${var} - command ${expectedBin} not found"
    fi
    # shellcheck disable=SC2163
    export "${var}"
  }

  checkBinary() {
    local var="$1"
    if [[ -z "${var}" || ! -x "${!var}" ]]; then
      Log::displayError "variable ${var} - binary '${!var}' does not exist or not executable"
      ((errorCount++))
    fi
  }

  local errorCount=0
  # IPCONFIG_BIN - which ipconfig.exe does not work when executed as root
  deduceBin IPCONFIG_BIN "${WINDOWS_DIR}/System32/ipconfig.exe" "ipconfig.exe"
  checkBinary IPCONFIG_BIN

  deduceBin WSL_EXE_BIN "${WINDOWS_DIR}/System32/wsl.exe" "wsl.exe"
  checkBinary WSL_EXE_BIN

  deduceBin POWERSHELL_BIN "${WINDOWS_DIR}/System32/WindowsPowerShell/v1.0/powershell.exe" "powershell.exe"
  checkBinary POWERSHELL_BIN

  return "${errorCount}"
}


# @description install apt wslu if necessary providing wslvar, wslpath
Engine::Config::requireWslu() {
  if [[ "${LOAD_WSLU:-1}" = "0" ]]; then
    return 0
  fi
  if ! command -v wslvar &>/dev/null; then
    Log::displayInfo "Installing pre-requisite Wslu : wslvar, wslpath, ... commands"
    Linux::Apt::installIfNecessary --no-install-recommends wslu

    # @see https://github.com/microsoft/WSL/issues/8843#issuecomment-1792256894
    Log::displayInfo "Fix wsl interoperability due to wsl bug"
    if [[ ! -f /usr/lib/binfmt.d/WSLInterop.conf &&
      ! -f /etc/systemd/system/wsl-binfmt.service &&
      -f /run/systemd/generator.early/wsl-binfmt.service ]]; then
      sudo sh -c 'echo :WSLInterop:M::MZ::/init:PF > /usr/lib/binfmt.d/WSLInterop.conf'
      sudo ln -s /run/systemd/generator.early/wsl-binfmt.service /etc/systemd/system/wsl-binfmt.service
    fi
  fi
}


# @description default env file with all default values
# @stdout the default env filepath
Env::createDefaultEnvFile() {
  local envFile
  envFile="$(Framework::createTempFile "createDefaultEnvFileEnvFile")" || return 2

  (
    echo "BASH_FRAMEWORK_THEME=${BASH_FRAMEWORK_THEME:-default}"
    echo "BASH_FRAMEWORK_LOG_LEVEL=${BASH_FRAMEWORK_LOG_LEVEL:-${__LEVEL_OFF}}"
    echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${BASH_FRAMEWORK_DISPLAY_LEVEL:-${__LEVEL_INFO}}"
    # shellcheck disable=SC2016
    echo 'BASH_FRAMEWORK_LOG_FILE="${BASH_FRAMEWORK_LOG_FILE:-"${FRAMEWORK_ROOT_DIR}/logs/${SCRIPT_NAME}.log"}"'
    echo "BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION=${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION:-5}"
  ) >"${envFile}"
  echo "${envFile}"
}


# @description prepend directories to the PATH environment variable
# @arg $@ args:String[] list of directories to prepend
# @set PATH update PATH with the directories prepended
Env::pathPrepend() {
  local arg
  for arg in "$@"; do
    if [[ -d "${arg}" && ":${PATH}:" != *":${arg}:"* ]]; then
      PATH="$(realpath "${arg}"):${PATH}"
    fi
  done
}


# @description ensure env files are loaded
# @arg $@ list of default files to load at the end
# @exitcode 1 if one of env files fails to load
# @stderr diagnostics information is displayed
# shellcheck disable=SC2120
Env::requireLoad() {
  export REQUIRE_FUNCTION_ENV_REQUIRE_LOAD_LOADED=1

  local -a defaultFiles=("$@")
  # get list of possible config files
  local -a configFiles=()
  local defaultEnvFile
  defaultEnvFile="$(Env::createDefaultEnvFile)" || return 1
  configFiles+=("${defaultEnvFile}")
  if [[ -n "${BASH_FRAMEWORK_ENV_FILES[0]+1}" ]]; then
    # BASH_FRAMEWORK_ENV_FILES is an array
    configFiles+=("${BASH_FRAMEWORK_ENV_FILES[@]}")
  fi
  if [[ -f "${FRAMEWORK_ROOT_DIR}/.framework-config" ]]; then
    configFiles+=("${FRAMEWORK_ROOT_DIR}/.framework-config")
  fi
  local localFrameworkConfigFile
  BASH_FRAMEWORK_DISPLAY_LEVEL="${__LEVEL_INFO}" \
    BASH_FRAMEWORK_LOG_LEVEL="${__LEVEL_OFF}" \
    Conf::loadNearestFile ".framework-config" localFrameworkConfigFile "$(pwd)" || true
  if [[ -f "${localFrameworkConfigFile}" ]]; then
    configFiles+=("${localFrameworkConfigFile}")
  fi
  configFiles+=("${optionEnvFiles[@]}")
  configFiles+=("${defaultFiles[@]}")

  while IFS='' read -r file; do
    # shellcheck source=/src/Env/createDefaultEnvFile.sh
    CURRENT_LOADED_ENV_FILE="${file}" source "${file}" || {
      Log::displayError "while loading config file: ${file}"
      return 1
    }
  done < <(printf '%s\n' "${configFiles[@]}" | awk '!x[$0]++')
}


# @description get number of seconds since last modification of the file
# @arg $1 file:String file path
# @exitcode 1 if file does not exist
# @stdout number of seconds since last modification of the file
File::elapsedTimeSinceLastModification() {
  local file="$1"
  if [[ ! -f "${file}" ]]; then
    return 1
  fi
  local lastModificationTimeSeconds diff
  lastModificationTimeSeconds="$(stat -c %Y "${file}")"
  ((diff = $(date +%s) - lastModificationTimeSeconds))
  echo -n "${diff}"
}


# @description delete files older than n days in given path
# @warning use this function with caution as it will delete all files in given path without any prompt
# @arg $1 path:String the directory in which files will be deleted or the file to delete
# @arg $2 mtime:String expiration time in days (eg: 1 means 1 day) (default value: 1). Eg: +1 match files that have been accessed at least two days ago (rounding effect)
# @arg $3 maxdepth:int Descend at most levels (a non-negative integer) levels of directories below the starting-points. (default value: 1)
# @exitcode 1 if path not provided or empty
# @exitcode * find command failure code
# @stderr find output on error or diagnostics logs
# @see man find atime
File::garbageCollect() {
  local path="$1"
  local mtime="$2"
  local maxdepth="${3:-1}"

  if [[ -z "${path}" ]]; then
    return 1
  fi

  if [[ ! -e "${path}" ]]; then
    # path already removed
    return 0
  fi

  Log::displayInfo "Garbage collect files older than ${mtime} days in path ${path} with max depth ${maxdepth}"
  find "${path}" -depth -maxdepth "${maxdepth}" -type f -mtime "${mtime}" -print -delete
}


# @description print the resolved path relative to DIR
# do not check for path existence
# @arg $1 srcFile:String the file to resolve
# @arg $2 relativeTo:String the directory
# @stdout the resolved path relative to DIR
File::relativeToDir() {
  local srcFile="$1"
  local relativeTo="$2"

  realpath -m --relative-to="${relativeTo}" "${srcFile}"
}


# @description search a file in parent directories
#
# @arg $1 fromPath:String path
# @arg $2 fileName:String
# @arg $3 untilInclusivePath:String (optional) find for given file until reaching this folder (default value: /)
# @arg $@ untilInclusivePaths:String[] list of untilInclusivePath
# @stdout The filename if found
# @exitcode 1 if the command failed or file not found
File::upFind() {
  local fromPath="$1"
  shift || true
  local fileName="$1"
  shift || true
  local untilInclusivePath="${1:-/}"
  shift || true

  if [[ -f "${fromPath}" ]]; then
    fromPath="${fromPath%/*}"
  fi
  while true; do
    if [[ -f "${fromPath}/${fileName}" ]]; then
      echo "${fromPath}/${fileName}"
      return 0
    fi
    if Array::contains "${fromPath}" "${untilInclusivePath}" "$@" "/"; then
      return 1
    fi
    fromPath="$(readlink -f "${fromPath}"/..)"
  done
  return 1
}

# shellcheck disable=SC2120

# @description uniq command need input file to be sorted
# here We are using awk that do not need file to be sorted
# to get uniq values
# iterates over each file and prints (default awk behavior)
# each unique line; only takes first value and ignores duplicates
# Note ! be careful of memory usage as each unique $0 is stored in an array
# @exitcode * if one of the filter command fails
# @stdin you can use stdin as alternative to str argument
# @stdout the filtered content
# shellcheck disable=SC2120
Filters::uniqUnsorted() {
  awk '!seen[$0]++' "$@"
}


# @description create a temp file using default TMPDIR variable
# @env TMPDIR String (default value /tmp)
# @arg $1 templateName:String template name to use(optional)
Framework::createTempFile() {
  mktemp -p "${TMPDIR:-/tmp}" -t "${1:-}.XXXXXXXXXXXX"
}


# @description installs file to given directory
#
# callbacks parameters `${fromFile} ${targetFile} $@`
# @arg $1 fromFile - original file to copy
# @arg $2 targetFile - target file
# @arg $3 userName:String (optional) (default: ${USERNAME}) the user name that will be used to set target files ownership
# @arg $4 userGroup:String (optional) (default: ${USERNAME}) the group name that will be used to set target files ownership
# @arg $5 successCallback:Function the callback to call when file is installed successfully, by default setUserRights callback is called
# @arg $6 failureCallback:Function the callback to call when file installation has failed, by default unableToCopyCallback callback is called
# @arg $@ callbacksParams:String[] additional parameters passed to callbacks
# @exitcode 1 if fromFile is not readable
# @exitcode 2 if backup file failure
# @exitcode 3 if copy failure
# @exitcode 0 on success or if OVERWRITE_CONFIG_FILES=0
# @exitcode 0 on success or if CHANGE_WINDOWS_FILES=0 and target file is a windows file
# @env OVERWRITE_CONFIG_FILES Boolean (default:0) if 1 will overwrite existing directory
# @env CHANGE_WINDOWS_FILES Boolean (default:0) if 1 and target file is in windows file system, overwrite it
# @env USERNAME (default: root) the user name that will be used to set target files ownership
# @env USERGROUP (default: root) the group name that will be used to set target files ownership
# @env BASE_MNT_C String windows C drive base PATH
# @env FRAMEWORK_ROOT_DIR used to make paths relative to this directory to reduce length of messages
# @env SUDO String allows to use custom sudo prefix command
# @env BACKUP_BEFORE_INSTALL Boolean (default: 1) backup file before installing the file
Install::file() {
  local fromFile="$1"
  local targetFile="$2"
  local userName="${3:-${USERNAME:-root}}"
  local userGroup="${4:-${USERGROUP:-root}}"
  local successCallback=${5:-Install::setUserRightsCallback}
  local failureCallback=${6:-Install::unableToCopyCallback}
  shift 6 || true

  if [[ ! -f "${fromFile}" || ! -r "${fromFile}" ]]; then
    Log::displayError "cannot read source file '${fromFile}'"
    return 1
  fi

  # skip if OVERWRITE_CONFIG_FILES is 0 and target file exists
  if [[ "${OVERWRITE_CONFIG_FILES}" = "0" && -f "${targetFile}" ]]; then
    Log::displayWarning "File '${targetFile}' exists - Skip install (because OVERWRITE_CONFIG_FILES=0 in .env file)"
    return 0
  fi

  # skip if CHANGE_WINDOWS_FILES is 0 and target dir is c drive
  if [[ "${CHANGE_WINDOWS_FILES}" = "0" && "${targetFile}" =~ ^${BASE_MNT_C} ]]; then
    Log::displayWarning "File '${targetFile}' - Skip install (because CHANGE_WINDOWS_FILES=0 in .env file)"
    return 0
  fi

  local targetDir="${targetFile%/*}"
  if ! ${SUDO} test -d "${targetDir}"; then
    ${SUDO:-} mkdir -p "${targetDir}"
    ${SUDO:-} chown "${userName}":"${userGroup}" "${targetDir}"
  fi
  local fromDir="${fromFile%/*}"
  local fromFilename="${fromFile##*/}"

  local prettyFromDir
  # shellcheck disable=SC2295
  prettyFromDir="${fromDir#${PRETTY_ROOT_DIR:-${FRAMEWORK_ROOT_DIR}}/}"
  if diff -q "${fromFile}" "${targetFile}" &>/dev/null; then
    Log::displayStatus "No changes detected. No need to update '${targetFile}' from '${prettyFromDir}/${fromFilename}'"
    return 0
  fi

  if [[ "${BACKUP_BEFORE_INSTALL:-1}" = "1" ]]; then
    Backup::file "${targetFile}" || return 2
  fi

  if ${SUDO:-} cp "${fromFile}" "${targetFile}"; then
    # shellcheck disable=SC2295
    Log::displaySuccess "Installed file '${targetFile}' from '${prettyFromDir}/${fromFilename}'"
    ${successCallback} "${fromFile}" "${targetFile}" "${userName}" "${userGroup}" "${prettyFromDir}" "${fromFilename}"
  else
    # shellcheck disable=SC2295
    Log::displayError "unable to copy file '${targetFile}' from '${fromDir#${FRAMEWORK_ROOT_DIR}/}/${fromFilename}'"
    ${failureCallback} "${fromFile}" "${targetFile}" "${userName}" "${userGroup}" "${prettyFromDir}" "${fromFilename}"
    return 3
  fi
}


# @description install callback
#   set file with root ownership and execution bit
# @arg $1 fromFile:String
# @arg $2 targetFile:String
# @arg $3 userName:String (optional) (default: ${USERNAME}) the user name that will be used to set target files ownership
# @arg $4 userGroup:String (optional) (default: ${USERNAME}) the group name that will be used to set target files ownership
# @env USERNAME (default: root) the user name that will be used to set target files ownership
# @env USERGROUP (default: root) the group name that will be used to set target files ownership
# @env SUDO String allows to use custom sudo prefix command
# @exitcode 1 on any failure
# @see Install::file
Install::setUserRightsCallback() {
  # shellcheck disable=SC2034 # $1 not used
  local fromFile="$1"
  local targetFile="$2"
  local userName="${3:-${USERNAME:-root}}"
  local userGroup="${4:-${USERGROUP:-root}}"

  ${SUDO:-} chown "${userName}":"${userGroup}" "${targetFile}"
}


# @description install dir to given directory but backup it before
# @arg $1 fromDir:String the source base directory
# @arg $2 toDir:String the target base directory
# @env OVERWRITE_CONFIG_FILES Boolean (default:0) if 1 will overwrite existing files
# @env CHANGE_WINDOWS_FILES Boolean (default:0) if 1 and target directory is in windows file system, overwrite it
# @env USERNAME (default: ${USERNAME} if SUDO empty else root) the user name that will be used to set target files ownership
# @env USERGROUP (default: ${USERGROUP} if SUDO empty else root) the group name that will be used to set target files ownership
# @env BASE_MNT_C String windows C drive base PATH
# @env PRETTY_ROOT_DIR used to make paths relative to this directory to reduce length of messages
# @env SUDO String allows to use custom sudo prefix command
# @env BACKUP_BEFORE_INSTALL Boolean (default:1) backup directory before installing the dir
# @exitcode 1 if source directory is not readable
# @exitcode 2 if error during structure replication
# @exitcode 2 if error during file copy
# @exitcode 0 if copy successful
# @exitcode 0 with warning message if CHANGE_WINDOWS_FILES=0 and target directory in C drive
# @stderr diagnostics information is displayed, skipped information if OVERWRITE_CONFIG_FILES or CHANGE_WINDOWS_FILES are set to 1
Install::structure() {
  local fromDir="$1"
  local toDir="$2"
  local userName="root"
  local userGroup="root"
  if [[ -z "${SUDO:-}" ]]; then
    userName="${USERNAME:-root}"
    userGroup="${USERGROUP:-root}"
  fi

  if [[ ! -d "${fromDir}" || ! -r "${fromDir}" ]]; then
    Log::displayError "Install::structure - cannot read source directory '${fromDir}'"
    return 1
  fi

  # skip if CHANGE_WINDOWS_FILES is 0 and target dir is c drive
  if [[ "${CHANGE_WINDOWS_FILES:-0}" = "0" && "${toDir}" =~ ^${BASE_MNT_C:-/mnt/c} ]]; then
    Log::displayWarning "Install::structure - Directory '${fromDir}' - Skip install (because CHANGE_WINDOWS_FILES=0 in .env file)"
    return 0
  fi

  # first replicate directory structure
  # shellcheck disable=SC2317
  createStructure() {
    local dir="$1"
    if ! ${SUDO} test -d "${dir}"; then
      if ! ${SUDO:-} mkdir -p "${dir}"; then
        Log::displayError "Install::structure - impossible to create directory '${dir}'"
        exit 1
      fi
    fi

    if ! ${SUDO:-} chown "${userName}":"${userGroup}" "${dir}"; then
      Log::displayError "Install::structure - impossible to update directory owner '${dir}' with ${userName}:${userGroup}"
      exit 1
    fi
  }
  local dir

  (
    local dir
    shopt -s lastpipe
    # -links 2 allows to exclude empty directories
    ${SUDO:-} find "${fromDir}" -depth -type d -links 2 -print0 |
      while read -rd '' dir; do
        if ! createStructure "${toDir}/${dir#"${fromDir}"}"; then
          # error already reported by createStructure
          exit 1
        fi
      done || {
      if [[ "${PIPESTATUS[0]}" != "0" ]]; then
        Log::displayError "Install::structure - replicated directory structure - find directories on '${fromDir}' resulted in an error"
        exit 2
      fi
    }
  ) || return 2

  # for each file, copy it
  (
    local file
    shopt -s lastpipe
    ${SUDO:-} find "${fromDir}" -depth -type f -print0 |
      while read -rd '' file; do
        local localFile="${file#"${fromDir}/"}"
        if ! Install::file "${fromDir}/${localFile}" "${toDir}/${localFile}"; then
          # error already reported by Install::file
          exit 1
        fi
      done || {
      if [[ "${PIPESTATUS[0]}" != "0" ]]; then
        Log::displayError "Install::structure - replicated file structure - find files on '${fromDir}' resulted in an error"
        exit 2
      fi
    }
  ) || return 3

  # shellcheck disable=SC2295
  Log::displaySuccess "Installed directory '${toDir#${PRETTY_ROOT_DIR}/}' from '${fromDir#${PRETTY_ROOT_DIR}/}'"
}


# @description install callback
#   default callback used called when file copy has failed
# @arg $1 fromFile:String
# @arg $2 targetFile:String
# @env FRAMEWORK_ROOT_DIR used to make paths relative to this directory to reduce length of messages
# @exitcode 1 always fail
# @stderr diagnostics information is displayed
# @see Install::file
Install::unableToCopyCallback() {
  local fromDir="$1"
  local fileName="$2"
  local targetFile="$3"
  Log::fatal "unable to copy file '${fromDir#"${FRAMEWORK_ROOT_DIR}/"}/${fileName}' to '${targetFile}'"
}


# @description the command launch different actions(install, configure, test)
# depending on the options selected
# @env SKIP_INSTALL
# @env SKIP_CONFIGURE
# @env SKIP_TEST
# @env STATS_DIR
# @env LOGS_INSTALL_SCRIPTS_DIR
InstallScripts::command() {
  local logsDir="${LOGS_INSTALL_SCRIPTS_DIR:-#}"
  local statsDir="${STATS_DIR:-#}"
  local fullScriptName
  fullScriptName="$(fullScriptName)"
  local scriptName="${fullScriptName//\//@}"
  rm -f "${statsDir}/${scriptName}-"* || true

  # shellcheck disable=SC2317
  onInterrupt() {
    Log::displayError "${scriptName} aborted"
    exit 1
  }
  trap onInterrupt INT TERM ABRT

  local startDate logFile statsFile
  local installStatus="0"
  sourceHook() {
    local hookName="$1"
    local configDir
    # shellcheck disable=SC2154
    local -a overriddenDirs=()
    # shellcheck disable=SC2154
    if [[ -d "${embed_dir_hooks_dir}" ]]; then
      overriddenDirs+=("${embed_dir_hooks_dir}")
    fi
    local dir
    for dir in "${CONF_OVERRIDE_DIRS[@]}"; do
      overriddenDirs+=("${dir}/${scriptName//\//@}")
    done
    configDir="$(Conf::getOverriddenDir "${overriddenDirs[@]}")" || return 0

    # ensure necessary functions are imported
    # Assert::dirExists
    # Assert::fileExists
    hook="${configDir}/${hookName}.sh"
    if [[ -n "${hook}" && -f "${hook}" && -x "${hook}" ]]; then
      Log::displayInfo "Running hook ${hook}"
      # shellcheck source=src/_installScripts/_Defaults/SimpleTest-hooks/preInstall.sh
      source "${hook}" || {
        Log::displayError "${scriptName} - unable to load hook '${hook}'"
        exit 1
      }
    fi
  }
  local globalStatsFile="${statsDir}/${scriptName}-global.stat"
  local hook
  if [[ "${SKIP_INSTALL}" = "0" ]] && ! InstallScripts::scriptFunctionEmpty install; then
    LOG_CONTEXT="${scriptName} - " Log::headLine "INSTALL" "Installing ${scriptName}"
    logFile="${logsDir}/${scriptName}-install.log"
    statsFile="${statsDir}/${scriptName}-install.stat"

    # break at first install error
    (
      startDate="$(date +%s)"
      # shellcheck disable=SC2317
      computeStats() {
        local rc=$1
        LOG_CONTEXT="${scriptName} - " Stats::statusLine "${statsFile}" "Installation"
        Stats::computeFromLog \
          "${logFile}" "${rc}" "${statsFile}" "${startDate}"
        Stats::aggregateGlobalStats \
          "${globalStatsFile}" "1" "${statsFile}"
        exit "${rc}"
      }
      trap 'computeStats "$?"' EXIT INT TERM ABRT

      local -i failures=0
      sourceHook preInstall || ((++failures))
      install || ((++failures))
      sourceHook postInstall || ((++failures))
      exit "${failures}"
    ) 2>&1 | tee "${logFile}"
  fi

  local testInstallStatus="0"
  if [[ "${SKIP_TEST}" = "0" && "${installStatus}" = "0" ]] &&
    ! InstallScripts::scriptFunctionEmpty testInstall; then
    Log::headLine "TEST" "Testing ${scriptName} installation"
    logFile="${logsDir}/${scriptName}-test-install.log"
    statsFile="${statsDir}/${scriptName}-test-install.stat"
    (
      startDate="$(date +%s)"
      # shellcheck disable=SC2317
      computeStats() {
        local rc=$1
        Stats::statusLine "${statsFile}" "Test Install ${scriptName}"
        Stats::computeFromLog \
          "${logFile}" "${rc}" "${statsFile}" "${startDate}"
        Stats::aggregateGlobalStats \
          "${globalStatsFile}" "1" "${statsFile}"
        exit "${rc}"
      }
      trap 'computeStats "$?"' EXIT INT TERM ABRT

      local -i failures=0
      sourceHook preTestInstall || ((++failures))
      testInstall || ((++failures))
      sourceHook postTestInstall || ((++failures))
      exit "${failures}"
    ) 2>&1 | tee "${logFile}" || testInstallStatus="$?" || true
    if [[ "${testInstallStatus}" != "0" ]] && breakOnTestFailure; then
      # break if test script error
      exit "${testInstallStatus}"
    fi
  fi

  local configStatus="0"
  if [[ "${SKIP_CONFIGURE}" = "0" && "${installStatus}" = "0" ]] &&
    ! InstallScripts::scriptFunctionEmpty configure; then
    Log::headLine "CONFIG" "Configuring ${scriptName}"
    logFile="${logsDir}/${scriptName}-config.log"
    statsFile="${statsDir}/${scriptName}-config.stat"
    (
      startDate="$(date +%s)"
      # shellcheck disable=SC2317
      computeStats() {
        local rc=$1
        Stats::statusLine "${statsFile}" "Configuration ${scriptName}"
        Stats::computeFromLog \
          "${logFile}" "${rc}" "${statsFile}" "${startDate}"
        Stats::aggregateGlobalStats \
          "${globalStatsFile}" "1" "${statsFile}"
        exit "${rc}"
      }
      trap 'computeStats "$?"' EXIT INT TERM ABRT

      local -i failures=0
      sourceHook preConfigure || ((++failures))
      configure || ((++failures))
      sourceHook postConfigure || ((++failures))
      exit "${failures}"
    ) 2>&1 | tee "${logFile}" || configStatus="$?" || true

    if [[ "${configStatus}" != "0" ]] && breakOnConfigFailure; then
      # break if config script error
      exit "${configStatus}"
    fi
  fi

  local testConfigStatus="0"
  if [[ "${SKIP_TEST}" = "0" && "${installStatus}" = "0" && "${configStatus}" = "0" ]] &&
    ! InstallScripts::scriptFunctionEmpty configure; then
    Log::headLine "TEST" "Testing ${scriptName} configuration"
    logFile="${logsDir}/${scriptName}-test-configuration.log"
    statsFile="${statsDir}/${scriptName}-test-configuration.stat"
    (
      startDate="$(date +%s)"
      # shellcheck disable=SC2317
      computeStats() {
        local rc=$1
        Stats::statusLine "${statsFile}" "Test Configuration ${scriptName}"
        Stats::computeFromLog \
          "${logFile}" "${rc}" "${statsFile}" "${startDate}"
        Stats::aggregateGlobalStats \
          "${globalStatsFile}" "1" "${statsFile}"
        exit "${rc}"
      }
      trap 'computeStats "$?"' EXIT INT TERM ABRT

      local -i failures=0
      sourceHook preTestConfigure || ((++failures))
      testConfigure || ((++failures))
      sourceHook postTestConfigure || ((++failures))
      exit "${failures}"
    ) 2>&1 | tee "${logFile}" || testConfigStatus="$?" || true
    if [[ "${testConfigStatus}" != "0" ]] && breakOnTestFailure; then
      # break if test script error
      exit "${testConfigStatus}"
    fi
  fi

  local cleanBeforeExportStatus="0"
  if [[ "${PREPARE_EXPORT}" = "1" && "${installStatus}" = "0" ]] &&
    ! InstallScripts::scriptFunctionEmpty cleanBeforeExport; then
    Log::headLine "CLEAN" "Cleaning ${scriptName}"
    logFile="${logsDir}/${scriptName}-clean-before-export.log"
    statsFile="${statsDir}/${scriptName}-clean-before-export.stat"
    (
      startDate="$(date +%s)"
      # shellcheck disable=SC2317
      computeStats() {
        local rc=$1
        Stats::statusLine "${statsFile}" "Cleaning ${scriptName}"
        Stats::computeFromLog \
          "${logFile}" "${rc}" "${statsFile}" "${startDate}"
        Stats::aggregateGlobalStats \
          "${globalStatsFile}" "1" "${statsFile}"
        exit "${rc}"
      }
      trap 'computeStats "$?"' EXIT INT TERM ABRT

      local -i failures=0
      if ! InstallScripts::scriptFunctionEmpty cleanBeforeExport; then
        cleanBeforeExport || ((++failures))
        if [[ "${failures}" = "0" ]] && ! InstallScripts::scriptFunctionEmpty testCleanBeforeExport; then
          testCleanBeforeExport || ((++failures))
        fi
      fi
      exit "${failures}"
    ) 2>&1 | tee "${logFile}" || cleanBeforeExportStatus="$?" || true

    if [[ "${cleanBeforeExportStatus}" != "0" ]]; then
      # break if config script error
      exit "${cleanBeforeExportStatus}"
    fi
  fi
}


# @description check that function is implemented
InstallScripts::isFunctionImplemented() {
  local functionName="$1"
  if ! Assert::functionExists "${functionName}"; then
    Log::displayError "$(scriptName) - Function ${functionName} is not implemented"
    return 1
  fi
}


# @description check that all needed functions are implemented
InstallScripts::isInterfaceMandatoryFunctionImplemented() {
  local -i failures=0
  InstallScripts::isFunctionImplemented helpDescription || ((++failures))
  InstallScripts::isFunctionImplemented helpLongDescription || ((++failures))
  InstallScripts::isFunctionImplemented scriptName || ((++failures))
  InstallScripts::isFunctionImplemented dependencies || ((++failures))
  InstallScripts::isFunctionImplemented listVariables || ((++failures))
  InstallScripts::isFunctionImplemented fortunes || ((++failures))
  InstallScripts::isFunctionImplemented helpVariables || ((++failures))
  InstallScripts::isFunctionImplemented defaultVariables || ((++failures))
  InstallScripts::isFunctionImplemented checkVariables || ((++failures))
  InstallScripts::isFunctionImplemented breakOnConfigFailure || ((++failures))
  InstallScripts::isFunctionImplemented breakOnTestFailure || ((++failures))
  InstallScripts::isFunctionImplemented install || ((++failures))
  InstallScripts::isFunctionImplemented testInstall || ((++failures))
  InstallScripts::isFunctionImplemented configure || ((++failures))
  InstallScripts::isFunctionImplemented testConfigure || ((++failures))
  return "${failures}"
}


# @description check if function is empty
# @arg $1 function:Function
# @exitcode 0 if function is considered empty (body with : or true)
InstallScripts::scriptFunctionEmpty() {
  local pattern="^[ \t]+(:|true)"
  if ! declare -f "$1" &>/dev/null; then
    return 0
  fi
  local functionBody
  functionBody=$(declare -f "$1")
  local line3 line4
  line3=$(sed '3q;d' <<<"${functionBody}")
  line4=$(sed '4q;d' <<<"${functionBody}")
  [[ "${line3}" =~ ${pattern} && "${line4}" = "}" ]]
}


# @description apt-get install
# @arg $@ softwares:String[] list of softwares to install
# @feature Retry::default
# Linux::requireSudoCommand
# @stdout diagnostics logs
Linux::Apt::install() {

  if [[ "${REQUIRE_FUNCTION_LINUX_REQUIRE_UBUNTU_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::requireUbuntu has not been loaded"
    exit 1
  fi

  Log::displayInfo "Apt install $*"
  Retry::default sudo apt-get install -y -q "$@"
}


# @description apt-get install if package is not installed yet
# @arg $@ packages:String[] list of packages to install
# @feature Retry::default
# Linux::requireSudoCommand
# @env SKIP_APT_GET_UPDATE
# @stdout diagnostics logs
Linux::Apt::installIfNecessary() {

  if [[ "${REQUIRE_FUNCTION_LINUX_REQUIRE_UBUNTU_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::requireUbuntu has not been loaded"
    exit 1
  fi

  local -a packages=("$@")
  local package
  local -i installNeeded=0
  for package in "${packages[@]}"; do
    if [[ "${package}" =~ ^[-]{1,2} ]]; then
      continue
    fi
    if ! Linux::Apt::isPackageInstalled "${package}"; then
      Log::displayInfo "Package ${package} is not installed"
      installNeeded=1
    fi
  done
  if ((installNeeded == 1)); then
    if [[ "${SKIP_APT_GET_UPDATE:-0}" = "0" ]]; then
      Linux::Apt::update
    fi
    Linux::Apt::install "${packages[@]}"
    for package in "${packages[@]}"; do
      if [[ "${package}" =~ ^-- ]]; then
        continue
      fi
      if ! Linux::Apt::isPackageInstalled "${package}"; then
        Log::displayWarning "Package ${package} does not appear to have been installed, check if you could have chosen the wrong package name (Eg: python3.9-distutils instead of python3-distutils)"
      fi
    done
  else
    Log::displayInfo "Apt install avoided as packages are already installed : ${packages[*]}"
  fi
}


# @description check if apt package is installed
# @arg $1 package:String the package name to check
# @stdout diagnostics logs
Linux::Apt::isPackageInstalled() {

  if [[ "${REQUIRE_FUNCTION_LINUX_REQUIRE_UBUNTU_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::requireUbuntu has not been loaded"
    exit 1
  fi

  local package="$1"
  dpkg -l "${package}" | grep -Eq "^ii  ${package}"
}


# @description update apt packages list
# @feature Retry::default
# Linux::requireSudoCommand
# @stdout diagnostics logs
Linux::Apt::update() {

  if [[ "${REQUIRE_FUNCTION_LINUX_REQUIRE_UBUNTU_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::requireUbuntu has not been loaded"
    exit 1
  fi

  Log::displayInfo "Apt update ..."
  Retry::default sudo apt-get update -y --fix-missing -o Acquire::ForceIPv4=true
}


declare -Agx bash_tools_wslpath=()
# @description retrieve wslpath using cache (cache is refreshed every day)
# @arg $@ args:String[] arguments to pass to wslpath
# @env WSL_TMPDIR String temp directory to store the wslpath cache (default value: PERSISTENT_TMPDIR), you can use TMPDIR instead
# @exitcode * if Linux::Wsl::originalWslpath cannot find the path
# @stderr diagnostics information is displayed
# @feature cache
Linux::Wsl::cachedWslpath2() {

  if [[ "${REQUIRE_FUNCTION_LINUX__WSL_REQUIRE_WSL_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::Wsl::requireWsl has not been loaded"
    exit 1
  fi

  # shellcheck disable=SC2034
  local -n cachedWslpath2_value=$1
  shift || true
  local tempEnvFile key
  tempEnvFile="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}/bash_tools_wslpath"

  key="$(Linux::Wsl::getKeyFromWslpathOptions "$@")"
  Cache::getPropertyValue2 \
    "${tempEnvFile}" \
    bash_tools_wslpath \
    cachedWslpath2_value \
    "${key}" \
    Linux::Wsl::originalWslpath "$@"
}


# @description retrieve path from wslvar and then use wslpath to resolve it
# using cache (cache is refreshed every day)
# @arg $1 var:String the var to retrieve using wslvar
# @arg $@ args:String[] (optional) additional arguments to pass to wslvar
# @env WSL_TMPDIR String temp directory to store the wslpath cache (default value: PERSISTENT_TMPDIR), you can use TMPDIR instead
# @exitcode 1 if var cannot be found in cache nor using Linux::Wsl::originalWslvar
# @exitcode 2 if path cannot be found in cache nor using Linux::Wsl::originalWslpath
# @stderr diagnostics information is displayed
# @feature cache
Linux::Wsl::cachedWslpathFromWslVar2() {

  if [[ "${REQUIRE_FUNCTION_LINUX__WSL_REQUIRE_WSL_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::Wsl::requireWsl has not been loaded"
    exit 1
  fi

  # shellcheck disable=SC2034
  local -n cachedWslpathFromWslVar2_value=$1
  shift || true
  local value
  Linux::Wsl::cachedWslvar2 value "$@" || return 1
  Linux::Wsl::cachedWslpath2 cachedWslpathFromWslVar2_value "${value}" || return 2
}


declare -Agx bash_tools_wslvar=()
# @description retrieve wslvar using cache (cache is refreshed every day)
# @arg $1 cachedWslvar2_var:&String the variable to set by reference if the value is found
# @arg $@ args:String[] arguments to pass to wslvar
# @env WSL_TMPDIR String temp directory to store the wslvar cache (default value: PERSISTENT_TMPDIR), you can use TMPDIR instead
# @exitcode * if Linux::Wsl::originalWslvar cannot find the variable
# @stderr diagnostics information is displayed
# @feature cache
Linux::Wsl::cachedWslvar2() {

  if [[ "${REQUIRE_FUNCTION_LINUX__WSL_REQUIRE_WSL_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::Wsl::requireWsl has not been loaded"
    exit 1
  fi

  # shellcheck disable=SC2034
  local -n cachedWslvar2_var="$1"
  shift || true
  local -a args=("$@")
  local tempWslvarFile="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}/bash_tools_wslvar"
  local key
  key="$(Linux::Wsl::getKeyFromWslpathOptions "${args[@]}")"
  Cache::getPropertyValue2 \
    "${tempWslvarFile}" \
    bash_tools_wslvar \
    cachedWslvar2_var \
    "${key}" \
    Linux::Wsl::originalWslvar "${args[@]}"
}


# @description Compute a cache from wslpath options
# @arg $@ args:String[] arguments passed to wslpath
# @stderr diagnostics information is displayed
# @stdout the cache key deduced from the options
# @feature cache
# @internal
Linux::Wsl::getKeyFromWslpathOptions() {

  if [[ "${REQUIRE_FUNCTION_LINUX__WSL_REQUIRE_WSL_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::Wsl::requireWsl has not been loaded"
    exit 1
  fi

  local options
  options=$(getopt -o "auwm" -- "$@" 2>/dev/null) || {
    Log::displayError "invalid options specified"
    return 1
  }
  local key="wslpath"
  eval set -- "${options}"
  while true; do
    case "$1" in
      -a | -u | -w | -m)
        key="${key}$1"
        ;;
      --)
        shift || true
        break
        ;;
      *)
        shift || true
        Log::displayWarning "Unknown key $1"
        ;;
    esac
    shift || true
  done
  key="${key}_$1"
  # replace some characters \:/
  key="${key//\\//}"
  key="${key//:/_}"
  key="${key////_}"
  echo "${key}"
}


# @description call simply original wslpath command
# @arg $@ args:String[] args to pass to wslpath
# @exitcode * wslpath exit code
# @stdout wslpath stdout
Linux::Wsl::originalWslpath() {

  if [[ "${REQUIRE_FUNCTION_LINUX__WSL_REQUIRE_WSL_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::Wsl::requireWsl has not been loaded"
    exit 1
  fi

  wslpath "$@" | sed -z '$ s/[\r\n]$//'
}


# @description call simply original wslvar command
# @arg $@ args:String[] args to pass to wslvar
# @exitcode * wslvar exit code
# @stdout wslvar stdout
Linux::Wsl::originalWslvar() {

  if [[ "${REQUIRE_FUNCTION_LINUX__WSL_REQUIRE_WSL_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::Wsl::requireWsl has not been loaded"
    exit 1
  fi

  wslvar "$@" | sed -z '$ s/[\r\n]$//'
}


# @description ensure linux runs under wsl
# @env WSL_GARBAGE_COLLECT int 0 to disable garbage collect of cache files
# @exitcode 1 if linux does not run under wsl
Linux::Wsl::requireWsl() {
  export REQUIRE_FUNCTION_LINUX__WSL_REQUIRE_WSL_LOADED=1

  Assert::wsl || return 1
  if [[ "${WSL_GARBAGE_COLLECT:-1}" = "1" ]]; then
    local tempEnvDir
    tempEnvDir="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}"
    File::garbageCollect "${tempEnvDir}/bash_tools_wslpath_${USER_ID:-$(id -un)}" "1"
    tempEnvDir="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}"
    File::garbageCollect "${tempEnvDir}/bash_tools_wslvar_${USER_ID:-$(id -un)}" "1"
  fi
}


# @description retrieve linux distributor id
# @noargs
# @exitcode 1 if lsb_release fails or not found
# @stdout the linux distributor id
Linux::getDistributorId() {
  (
    source /etc/os-release
    echo "${ID}"
  )
}


# @description ensure command tar is available
# @exitcode 1 if tar command not available
# @stderr diagnostics information is displayed
Linux::requireTarCommand() {
  export REQUIRE_FUNCTION_LINUX_REQUIRE_TAR_COMMAND_LOADED=1

  Assert::commandExists tar
}


# @description ensure linux distribution is ubuntu
# @exitcode 1 if linux distribution is not ubuntu
Linux::requireUbuntu() {
  export REQUIRE_FUNCTION_LINUX_REQUIRE_UBUNTU_LOADED=1

  if ! Array::contains "$(Linux::getDistributorId)" "ubuntu" "debian"; then
    Log::fatal "this script should be executed under Ubuntu or Debian OS"
  fi
}


declare -g FIRST_LOG_DATE LOG_LAST_LOG_DATE LOG_LAST_LOG_DATE_INIT LOG_LAST_DURATION_STR
FIRST_LOG_DATE="${EPOCHREALTIME/[^0-9]/}"
LOG_LAST_LOG_DATE="${FIRST_LOG_DATE}"
LOG_LAST_LOG_DATE_INIT=1
LOG_LAST_DURATION_STR=""

# @description compute duration since last call to this function
# the result is set in following env variables.
# in ss.sss (seconds followed by milliseconds precision 3 decimals)
# @noargs
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @set LOG_LAST_LOG_DATE_INIT int (default 1) set to 0 at first call, allows to detect reference log
# @set LOG_LAST_DURATION_STR String the last duration displayed
# @set LOG_LAST_LOG_DATE String the last log date that will be used to compute next diff
Log::computeDuration() {
  if ((${DISPLAY_DURATION:-0} == 1)); then
    local -i duration=0
    local -i delta=0
    local durationStr deltaStr
    local -i currentLogDate
    currentLogDate="${EPOCHREALTIME/[^0-9]/}"
    if ((LOG_LAST_LOG_DATE_INIT == 1)); then
      LOG_LAST_LOG_DATE_INIT=0
      LOG_LAST_DURATION_STR="Ref"
    else
      duration=$(((currentLogDate - FIRST_LOG_DATE) / 1000000))
      delta=$(((currentLogDate - LOG_LAST_LOG_DATE) / 1000000))
      if ((duration > 59)); then
        durationStr=$(date -ud "@${duration}" +'%H:%M:%S')
      else
        durationStr="${duration}s"
      fi
      if ((delta > 59)); then
        deltaStr=$(date -ud "@${delta}" +'%H:%M:%S')
      else
        deltaStr="${delta}s"
      fi
      LOG_LAST_DURATION_STR="${durationStr}/+${deltaStr}"
    fi
    LOG_LAST_LOG_DATE="${currentLogDate}"
    # shellcheck disable=SC2034
    local microSeconds="${EPOCHREALTIME#*.}"
    LOG_LAST_DURATION_STR="$(printf '%(%T)T.%03.0f\n' "${EPOCHSECONDS}" "${microSeconds:0:3}")(${LOG_LAST_DURATION_STR}) - "
  else
    # shellcheck disable=SC2034
    LOG_LAST_DURATION_STR=""
  fi
}


# @description Display message using debug color (gray)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayDebug() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_DEBUG)); then
    Log::computeDuration
    echo -e "${__DEBUG_COLOR}DEBUG   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logDebug "$1"
}


# @description Display message using error color (red)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayError() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_ERROR)); then
    Log::computeDuration
    echo -e "${__ERROR_COLOR}ERROR   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logError "$1"
}


# @description Display message using info color (bg light blue/fg white)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayHelp() {
  local type="${2:-HELP}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__HELP_COLOR}${type}    - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logHelp "$1" "${type}"
}


# @description Display message using info color (bg light blue/fg white)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayInfo() {
  local type="${2:-INFO}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__INFO_COLOR}${type}    - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logInfo "$1" "${type}"
}


# @description Display message using skip color (yellow)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displaySkipped() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__SKIPPED_COLOR}SKIPPED - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logSkipped "$1"
}


# @description Display message using info color (blue) but warning level
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayStatus() {
  local type="${2:-STATUS}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_WARNING)); then
    Log::computeDuration
    echo -e "${__INFO_COLOR}${type}  - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logStatus "$1" "${type}"
}


# @description Display message using success color (bg green/fg white)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displaySuccess() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__SUCCESS_COLOR}SUCCESS - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logSuccess "$1"
}


# @description Display message using warning color (yellow)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayWarning() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_WARNING)); then
    Log::computeDuration
    echo -e "${__WARNING_COLOR}WARN    - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logWarning "$1"
}


# @description Display message using error color (red) and exit immediately with error status 1
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::fatal() {
  Log::computeDuration
  echo -e "${__ERROR_COLOR}FATAL   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  Log::logFatal "$1"
  exit 1
}


# @description Get the text representation of a log level
# @arg $1 level:String the log level to convert
# @exitcode 1 if the level is invalid
Log::getLevelText() {
  local level="$1"
  case "${level}" in
    "${__LEVEL_OFF}")
      echo OFF
      ;;
    "${__LEVEL_ERROR}")
      echo ERROR
      ;;
    "${__LEVEL_WARNING}")
      echo WARNING
      ;;
    "${__LEVEL_INFO}")
      echo INFO
      ;;
    "${__LEVEL_DEBUG}")
      echo DEBUG
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
      ;;
  esac
}


# @description Display given text on full line with TEST_COLOR style
# @arg $1 text:String text to display
Log::headLine() {
  local type="$1"
  local text="$2"
  local message="${type}   - ${text}"
  if [[ -z "${type}" ]]; then
    message="${text}"
  else
    Log::computeDuration
    message="$(printf '%-7s - %s%s' "${type}" "${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}" "${text}")"
  fi
  echo -e "${__TEST_COLOR}$(UI::textLine "${message}" " ")${__RESET_COLOR}" >&2
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logDebug() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_DEBUG)); then
    Log::logMessage "${2:-DEBUG}" "$1"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logError() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_ERROR)); then
    Log::logMessage "${2:-ERROR}" "$1"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logFatal() {
  Log::logMessage "${2:-FATAL}" "$1"
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logHelp() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-HELP}" "$1"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logInfo() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-INFO}" "$1"
  fi
}


# @description Internal: common log message
# @example text
#   [date]|[levelMsg]|message
#
# @example text
#   2020-01-19 19:20:21|ERROR  |log error
#   2020-01-19 19:20:21|SKIPPED|log skipped
#
# @arg $1 levelMsg:String message's level description (eg: STATUS, ERROR, ...)
# @arg $2 msg:String the message to display
# @env BASH_FRAMEWORK_LOG_FILE String log file to use, do nothing if empty
# @env BASH_FRAMEWORK_LOG_LEVEL int log level log only if > OFF or fatal messages
# @stderr diagnostics information is displayed
Log::logMessage() {

  if [[ "${REQUIRE_FUNCTION_ENV_REQUIRE_LOAD_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Env::requireLoad has not been loaded"
    exit 1
  fi

  if [[ "${REQUIRE_FUNCTION_LOG_REQUIRE_LOAD_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Log::requireLoad has not been loaded"
    exit 1
  fi

  local levelMsg="$1"
  local msg="$2"
  local date

  if [[ -n "${BASH_FRAMEWORK_LOG_FILE}" ]] && ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    date="$(date '+%Y-%m-%d %H:%M:%S')"
    touch "${BASH_FRAMEWORK_LOG_FILE}"
    printf "%s|%7s|%s\n" "${date}" "${levelMsg}" "${msg}" >>"${BASH_FRAMEWORK_LOG_FILE}"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logSkipped() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-SKIPPED}" "$1"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logStatus() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_WARNING)); then
    Log::logMessage "${2:-STATUS}" "$1"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logSuccess() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-SUCCESS}" "$1"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logWarning() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_WARNING)); then
    Log::logMessage "${2:-WARNING}" "$1"
  fi
}


# @description activate or not Log::display* and Log::log* functions
# based on BASH_FRAMEWORK_DISPLAY_LEVEL and BASH_FRAMEWORK_LOG_LEVEL
# environment variables loaded by Env::requireLoad
# try to create log file and rotate it if necessary
# @noargs
# @set BASH_FRAMEWORK_LOG_LEVEL int to OFF level if BASH_FRAMEWORK_LOG_FILE is empty or not writable
# @env BASH_FRAMEWORK_DISPLAY_LEVEL int
# @env BASH_FRAMEWORK_LOG_LEVEL int
# @env BASH_FRAMEWORK_LOG_FILE String
# @env BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION int do log rotation if > 0
# @exitcode 0 always successful
# @stderr diagnostics information about log file is displayed
Log::requireLoad() {
  export REQUIRE_FUNCTION_LOG_REQUIRE_LOAD_LOADED=1


  if [[ "${REQUIRE_FUNCTION_ENV_REQUIRE_LOAD_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Env::requireLoad has not been loaded"
    exit 1
  fi

  if [[ "${REQUIRE_FUNCTION_UI_REQUIRE_THEME_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement UI::requireTheme has not been loaded"
    exit 1
  fi

  if [[ -z "${BASH_FRAMEWORK_LOG_FILE:-}" ]]; then
    BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
    export BASH_FRAMEWORK_LOG_LEVEL
  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    if [[ ! -f "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      if [[ ! -d "${BASH_FRAMEWORK_LOG_FILE%/*}" ]]; then
        if ! mkdir -p "${BASH_FRAMEWORK_LOG_FILE%/*}" 2>/dev/null; then
          BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
          echo -e "${__ERROR_COLOR}ERROR   - directory ${BASH_FRAMEWORK_LOG_FILE%/*} is not writable${__RESET_COLOR}" >&2
        fi
      elif ! touch --no-create "${BASH_FRAMEWORK_LOG_FILE}" 2>/dev/null; then
        BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
        echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
      fi
    elif [[ ! -w "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
      echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
    fi
  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    # will always be created even if not in info level
    Log::logMessage "INFO" "Logging to file ${BASH_FRAMEWORK_LOG_FILE} - Log level ${BASH_FRAMEWORK_LOG_LEVEL}"
    if ((BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION > 0)); then
      Log::rotate "${BASH_FRAMEWORK_LOG_FILE}" "${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION}"
    fi
  fi
}


# @description To be called before logging in the log file
# @arg $1 file:string log file name
# @arg $2 maxLogFilesCount:int maximum number of log files
Log::rotate() {
  local file="$1"
  local maxLogFilesCount="${2:-5}"

  if [[ ! -f "${file}" ]]; then
    Log::displayDebug "Log file ${file} doesn't exist yet"
    return 0
  fi
  local i
  for ((i = maxLogFilesCount - 1; i > 0; i--)); do
    Log::displayInfo "Log rotation ${file}.${i} to ${file}.$((i + 1))"
    mv "${file}."{"${i}","$((i + 1))"} &>/dev/null || true
  done
  if cp "${file}" "${file}.1" &>/dev/null; then
    echo >"${file}" # reset log file
    Log::displayInfo "Log rotation ${file} to ${file}.1"
  fi
}


declare -Ag allDepsResultSeen=()
declare -ag allDepsResult=()

# @description get recursively all the dependencies of each config from configs arg
#
# The parent argument must be set to "your software selection" when you call it,
# then the value will change when this function will be called recursively with the
# parent dependency
#
# Algorithm
#   For each config in configs
#     - load config definition
#     - mark this config as seen to avoid to recompute it later, in the case where another
#       definition depends on it
#     - call installScripts_${config}_dependencies function if exists (skipped if not)
#     - add these new dependencies if any to current dependencies list
#     - call recursively Profiles::allDepsRecursive with these dependencies
#     - add in allDepsResult the current config if it was not seen yet
#   This has constructed a tree with the most deep dependency present in the first items
#
# @warning allDepsResultSeen and allDepsResult global variables have to reset to empty array every time you call this function
#
# @arg $1 scriptsDir:String base directory where dependencies can be retrieved
# @arg $2 parent:String set to "your software selection" when you call it
# @arg $@ configs:String[] list of configurations to load, each config can depend on an other one
# @exitcode 1 if one of the dependency cannot be found
# @exitcode 2 if error while loading one of the dependency definition
# @exitcode 3 if error while calling dependencies function of the dependency's definition
# @set allDepsResultSeen String[] list of dependencies already seen
# @set allDepsResult String[] the final list of dependencies sorted by the most to less dependent
# @stderr diagnostics information is displayed
Profiles::allDepsRecursive() {
  local scriptsDir="$1"
  local parent="$2"
  shift 2 || true
  local i
  local addDep=0
  local -a deps=()
  local -a newDeps

  for i in "$@"; do
    if [[ "${allDepsResultSeen["${i}"]}" = 'stored' ]]; then
      continue
    fi
    if [[ ! -f "${scriptsDir}/${i}" ]]; then
      Log::displayError "Dependency ${i} doesn't exist"
      return 1
    fi

    if ! readarray -t newDeps < <(SKIP_REQUIRES=1 "${scriptsDir}/${i}" dependencies); then
      Log::displayError "Dependency ${i} - ${scriptsDir}/${i} dependencies failure"
      return 3
    fi
    if [[ -z "${allDepsResultSeen[${i}]+exists}" ]]; then
      addDep=1
      allDepsResultSeen["${i}"]='stored'
    fi
    # remove duplicates from deps preserving order
    mapfile -t deps < <(
      IFS=$'\n'
      printf "%s\n" "${deps[@]}" | awk '!x[$0]++'
    )
    if ((${#newDeps} > 0)); then
      Log::displayInfo "${i} depends on ${newDeps[*]}"
      Profiles::allDepsRecursive "${scriptsDir}" "${i}" "${newDeps[@]}" || return $?
    fi
    if [[ "${addDep}" = "1" ]]; then
      Log::displayInfo "${i} is a dependency of ${parent}"
      allDepsResult+=("${i}")
    fi
    addDep=0
  done
}


# @description deduce profile path from given profile name
# if 2 profiles are named identically the first existing profile
# will be used beginning with srcAlt profiles
# @arg $1 profileName:String
# @stdout the path of the profile, no output if profile not found
# @exitcode 1 if profile not found
Profiles::getProfilePath() {
  local profileName="$1"
  local dir
  for dir in "${BASH_DEV_ENV_ROOT_DIR}/srcAlt/"*; do
    profilePath="${dir}/profiles/profile.${profileName}.sh"
    if [[ -f "${profilePath}" ]]; then
      echo "${profilePath}"
      return 0
    fi
  done
  local profilePath="${BASH_DEV_ENV_ROOT_DIR}/profiles/profile.${profileName}.sh"
  if [[ -f "${profilePath}" ]]; then
    echo "${profilePath}"
    return 0
  fi

  return 1
}


# @description load profile file based on profileFile argument
# The profile file is profileDir/profile.profile.sh
# This file should define the variable CONFIG_LIST with array type
# @arg $1 profileFile:String full profile path
# @exitcode 1 if argument is not provided
# @exitcode 2 if profile not found
# @exitcode 3 if profile found but CONFIG_LIST variable unset
# @exitcode 4 if profile found but CONFIG_LIST variable empty
# @exitcode 5 if error occurs during profile loading
# @stderr diagnostics information is displayed
# @see Profiles::allDepsRecursive in order to load all the dependencies recursively based on this list
# @set CONFIG_LIST
Profiles::loadProfile() {
  local profileFile="$1"

  if [[ -z "${profileFile}" ]]; then
    Log::displayError "This method needs exactly 1 parameter"
    return 1
  fi

  # load the profile
  Log::displayInfo "Loading profile '${profileFile}'"
  if [[ ! -f "${profileFile}" ]]; then
    Log::displayError "profile ${profileFile} not found"
    return 2
  fi

  # shellcheck source=src/Profiles/testsData/profile.test1.sh
  source "${profileFile}" || return 5

  if [[ ! -v CONFIG_LIST ]]; then
    Log::displayError "Profile ${profileFile} missing variable CONFIG_LIST"
    return 3
  fi
  if [[ ${#CONFIG_LIST[@]} -eq 0 ]]; then
    Log::displayError "Profile ${profileFile} variable CONFIG_LIST cannot be empty"
    return 4
  fi

  # remove duplicates from profile preserving order
  mapfile -t CONFIG_LIST < <(
    IFS=$'\n' printf '%s\n' "${CONFIG_LIST[@]}" | Filters::uniqUnsorted
  )
}


# @description Retry a command 5 times with a delay of 15 seconds between each attempt
# @arg $@ command:String[] the command to run
# @exitcode 0 on success
# @exitcode 1 if max retries count reached
# @env RETRY_MAX_RETRY int max retries
# @env RETRY_DELAY_BETWEEN_RETRIES int delay between attempts
Retry::default() {
  Retry::parameterized "${RETRY_MAX_RETRY:-5}" "${RETRY_DELAY_BETWEEN_RETRIES:-15}" "" "$@"
}


# @description Retry a command several times depending on parameters
# @arg $1 maxRetries:int    $1 max retries
# @arg $2 delay:int between attempt
# @arg $3 message:String to display to describe the attempt
# @arg $@ rest of parameters, the command to run
# @exitcode 0 on success
# @exitcode 1 if max retries count reached
# @exitcode 2 if maxRetries invalid value
Retry::parameterized() {
  local maxRetries=$1
  shift || true
  local delayBetweenTries=$1
  shift || true
  local message="$1"
  shift || true
  local retriesCount=1
  if [[ "${maxRetries}" -lt 1 ]]; then
    Log::displayError "invalid maxRetry value"
    return 2
  fi

  while true; do
    Log::displayInfo "Attempt ${retriesCount}/${maxRetries}: ${message}"
    if "$@"; then
      break
    elif [[ "${retriesCount}" -lt "${maxRetries}" ]]; then
      Log::displayDebug "Command failed. Wait for ${delayBetweenTries} seconds"
      ((retriesCount++))
      sleep "${delayBetweenTries}"
    else
      Log::displayError "The command has failed after ${retriesCount} attempts."
      return 1
    fi
  done
  return 0
}


# @description aggregate number of skip/error/... log messages
# and export the result in aggregateStatFile
# @arg $1 statFile:String the current stat file to add to aggregateStatFile
# @arg $2 appCount:int number of app requested to be installed
# @arg $@ statFiles:String[] the files in which each step stats have been aggregated aggregated
# if it doesn't exist, the file is created with needed variables set to 0
# stats will be saved
Stats::aggregateGlobalStats() {
  local aggregateStatFile="$1"
  local appCount="$2"
  shift 2 || true
  local -a statFiles=("$@")

  (
    if [[ ! -f "${aggregateStatFile}" ]]; then
      Stats::aggregateStatsInitialContent "${appCount}" >"${aggregateStatFile}"
    fi
    # shellcheck source=src/Stats/aggregateStats.example
    source "${aggregateStatFile}"

    local -i globalError=0
    local -i globalWarning=0
    local -i globalSkipped=0
    local -i globalHelp=0
    local -i globalSuccess=0
    local -i globalStatus=0
    ((globalDuration = duration)) || true
    for statFile in "${statFiles[@]}"; do
      if [[ ! -f "${statFile}" ]]; then
        continue
      fi
      # shellcheck source=src/Stats/logStats.example
      source "${statFile}"

      # all statuses need to be 0 for global status to be O
      globalError=$((globalError || error))
      globalWarning=$((globalWarning || warning))
      globalSkipped=$((globalSkipped || skipped))
      globalHelp=$((globalHelp || help))
      globalSuccess=$((globalSuccess || success))
      globalStatus=$((globalStatus || status))
      globalDuration=$((globalDuration + duration))
    done
    # shellcheck source=src/Stats/aggregateStats.example
    source "${aggregateStatFile}"
    ((count++)) || true
    if ((globalStatus == 0)); then
      ((statusSuccess++)) || true
    fi
    if ((globalStatus > 0 || globalError > 0)); then
      ((error++)) || true
    fi
    if ((globalWarning > 0)); then
      ((warning++)) || true
    fi
    if ((globalSkipped > 0)); then
      ((skipped++)) || true
    fi
    if ((globalHelp > 0)); then
      ((help++)) || true
    fi
    if ((globalSuccess > 0)); then
      ((success++)) || true
    fi
    (
      echo "count=${count}"
      echo "appCount=${appCount}"
      echo "error=${error}"
      echo "warning=${warning}"
      echo "skipped=${skipped}"
      echo "help=${help}"
      echo "success=${success}"
      echo "duration=${globalDuration}"
      echo "statusSuccess=${statusSuccess}"
    ) >"${aggregateStatFile}"
  )
}


# @description default aggregateStats file Content
Stats::aggregateStatsInitialContent() {
  local appCount="$1"
  echo "count=0"
  echo "appCount=${appCount}"
  echo "error=0"
  echo "warning=0"
  echo "skipped=0"
  echo "help=0"
  echo "success=0"
  echo "duration=0"
  echo "statusSuccess=0"
}


# @description extract stats form log
# @arg $1 logFile:String the log file to parse
# @arg $2 status:int the status of the command associated to that log file
# @arg $3 statsFile:String where to write stats
# @arg $4 startDate:String date at which log started
# @stdout output with the format provided by this example src/Stats/aggregateStats.example
# @see src/Stats/aggregateStats.example
Stats::computeFromLog() {
  local logFile="$1"
  local status="$2"
  local statsFile="$3"
  local startDate="$4"
  local endDate
  endDate="$(date +%s)"
  local duration="$((endDate - startDate))"

  local logStatsAwkScript
  logStatsAwkScript="$(
    cat <<'EOF'
BEGIN {
  error=0
  warning=0
  skipped=0
  help=0
  success=0
}
{
  buffer = substr($0, 1, 20)
  if(match(buffer, /(ERROR)[ ]+- /, arr) != 0) {
    error+=1
  } else if(match(buffer, /(WARNING)[ ]+- /, arr) != 0) {
    warning+=1
  } else if(match(buffer, /(SKIPPED)[ ]+- /, arr) != 0) {
    skipped+=1
  } else if(match(buffer, /(ERROR)[ ]+- /, arr) != 0) {
    error+=1
  } else if(match(buffer, /(HELP)[ ]+- /, arr) != 0) {
    help+=1
  } else if(match(buffer, /(SUCCESS)[ ]+- /, arr) != 0) {
    success+=1
  }

}
END {
  error = (stat != 0) || error
  print "error=" error
  print "warning=" warning
  print "skipped=" skipped
  print "help=" help
  success = (stat == 0) || success
  print "success=" success
}

EOF
  )"

  (
    if [[ -f "${logFile}" ]]; then
      awk -v status="${status}" --source "${logStatsAwkScript}" "${logFile}"
      echo "status=${status}"
      echo "duration=${duration}"
    else
      # not executed
      echo "status=-1"
    fi
  ) >"${statsFile}"
}


# @description display message to reflect last installation status
# @arg $1:statFile
# @arg $2:msg
Stats::statusLine() {
  local statFile="$1"
  local msg="$2"
  if [[ ! -f "${statFile}" ]]; then
    return 0
  fi
  Log::computeDuration
  (
    # shellcheck source=src/Stats/logStats.example
    source "${statFile}" || exit 1

    local color="${__TEST_ERROR_COLOR}"
    local statusMsg
    if [[ "${status}" = "0" ]]; then
      if [[ "${skipped}" = "0" ]]; then
        color="${__SUCCESS_COLOR}"
        statusMsg="SUCCESS - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR}${msg} successful"
      fi
    elif [[ "${status}" = "-1" ]]; then
      statusMsg="ABORTED - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR}${msg} not executed"
    else
      statusMsg="ERROR   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR}${msg} in error"
    fi
    # overwrite final TEST line
    echo -e "${color}${statusMsg}${__RESET_COLOR}"
  )
}


# @description draw a line with the character passed in parameter repeated depending on terminal width
# @arg $1 character:String character to use as separator (default value #)
UI::drawLine() {
  local character="${1:-#}"
  local -i width=${COLUMNS:-0}
  if ((width == 0)) && [[ -t 1 ]]; then
    width=$(tput cols)
  fi
  if ((width == 0)); then
    width=80
  fi
  printf -- "${character}%.0s" $(seq "${COLUMNS:-$([[ -t 1 ]] && tput cols || echo '80')}")
  echo
}


# @description load color theme
# @noargs
# @env BASH_FRAMEWORK_THEME String theme to use
# @env LOAD_THEME int 0 to avoid loading theme
# @exitcode 0 always successful
UI::requireTheme() {
  export REQUIRE_FUNCTION_UI_REQUIRE_THEME_LOADED=1

  if [[ "${LOAD_THEME:-1}" = "1" ]]; then
    UI::theme "${BASH_FRAMEWORK_THEME-default}"
  fi
}


# @description Display given text and complete the rest of the line with given character
# @arg $1 text:String text to display
# @arg $2 character:String (default:#) character to use to complete the line
UI::textLine() {
  local text="$1"
  local character="${2:-#}"
  ((textSize = ${#text}))
  ((fullWith = $(tput cols)))
  ((remainingWidth = $((fullWith - textSize))))
  echo -n "${text}"
  printf '%*s\n' "${remainingWidth}" '' | tr ' ' "${character}"
}


# @description load colors theme constants
# @warning if tty not opened, noColor theme will be chosen
# @arg $1 theme:String the theme to use (default, noColor)
# @arg $@ args:String[]
# @set __ERROR_COLOR String indicate error status
# @set __INFO_COLOR String indicate info status
# @set __SUCCESS_COLOR String indicate success status
# @set __WARNING_COLOR String indicate warning status
# @set __SKIPPED_COLOR String indicate skipped status
# @set __DEBUG_COLOR String indicate debug status
# @set __HELP_COLOR String indicate help status
# @set __TEST_COLOR String not used
# @set __TEST_ERROR_COLOR String not used
# @set __HELP_TITLE_COLOR String used to display help title in help strings
# @set __HELP_OPTION_COLOR String used to display highlight options in help strings
#
# @set __RESET_COLOR String reset default color
#
# @set __HELP_EXAMPLE String to remove
# @set __HELP_TITLE String to remove
# @set __HELP_NORMAL String to remove
# shellcheck disable=SC2034
UI::theme() {
  local theme="${1-default}"
  if [[ ! "${theme}" =~ -force$ ]] && ! Assert::tty; then
    theme="noColor"
  fi
  case "${theme}" in
    default | default-force)
      theme="default"
      ;;
    noColor) ;;
    *)
      Log::fatal "invalid theme provided"
      ;;
  esac
  if [[ "${theme}" = "default" ]]; then
    BASH_FRAMEWORK_THEME="default"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR='\e[31m'         # Red
    __INFO_COLOR='\e[44m'          # white on lightBlue
    __SUCCESS_COLOR='\e[32m'       # Green
    __WARNING_COLOR='\e[33m'       # Yellow
    __SKIPPED_COLOR='\e[33m'       # Yellow
    __DEBUG_COLOR='\e[37m'         # Gray
    __HELP_COLOR='\e[7;49;33m'     # Black on Gold
    __TEST_COLOR='\e[100m'         # Light magenta
    __TEST_ERROR_COLOR='\e[41m'    # white on red
    __HELP_TITLE_COLOR="\e[1;37m"  # Bold
    __HELP_OPTION_COLOR="\e[1;34m" # Blue
    # Internal: reset color
    __RESET_COLOR='\e[0m' # Reset Color
    # shellcheck disable=SC2155,SC2034
    __HELP_EXAMPLE="$(echo -e "\e[2;97m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_TITLE="$(echo -e "\e[1;37m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_NORMAL="$(echo -e "\033[0m")"
  else
    BASH_FRAMEWORK_THEME="noColor"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR=''
    __INFO_COLOR=''
    __SUCCESS_COLOR=''
    __WARNING_COLOR=''
    __SKIPPED_COLOR=''
    __DEBUG_COLOR=''
    __HELP_COLOR=''
    __TEST_COLOR=''
    __TEST_ERROR_COLOR=''
    __HELP_TITLE_COLOR=''
    __HELP_OPTION_COLOR=''
    # Internal: reset color
    __RESET_COLOR=''
    __HELP_EXAMPLE=''
    __HELP_TITLE=''
    __HELP_NORMAL=''
  fi
}
# FUNCTIONS

# shellcheck disable=SC2034
declare commandFunctionName="installScriptCommand"

defaultBeforeParseCallback() {
  Env::requireLoad
  UI::requireTheme
  Log::requireLoad
  Linux::requireUbuntu
  Linux::Wsl::requireWsl
  InstallScripts::isInterfaceMandatoryFunctionImplemented
}

scriptName() {
  echo "ShellZshDefaultConfig"
}

beforeParseCallback() {
  defaultBeforeParseCallback
}

commandHelpFunction() {
  echo "Available commands:"
  echo ""
}

listOrNone() {
  local string="$1"
  if [[ -z "${string:-}" ]]; then
    echo -e "${__HELP_EXAMPLE}None${__HELP_NORMAL}" | sed 's/^/    /'
  else
    echo -ne "${__HELP_OPTION_COLOR}"
    echo -e "${string}" | sed 's/^/    - /'
    echo -ne "${__HELP_NORMAL}"
  fi
}

helpDescriptionFunction() {
  helpDescription
  echo
}

helpLongDescription() {
  helpDescription
}

helpLongDescriptionFunction() {
  helpLongDescription | sed 's/^/  /'
  echo
  echo -e "  ${__HELP_TITLE}List of needed variables:${__HELP_NORMAL}"
  listOrNone "$(listVariables)"
  echo
  local variables
  variables="$(helpVariables)"
  if [[ -n "${variables}" ]]; then
    echo -e "${variables}" | sed 's/^/    /'
    echo
  fi
  echo -e "  ${__HELP_TITLE}List of dependencies:${__HELP_NORMAL}"
  listOrNone "$(dependencies)"
}

isInstallImplemented() {
  ! InstallScripts::scriptFunctionEmpty install
}

isTestInstallImplemented() {
  ! InstallScripts::scriptFunctionEmpty testInstall
}

isConfigureImplemented() {
  ! InstallScripts::scriptFunctionEmpty configure
}

isTestConfigureImplemented() {
  ! InstallScripts::scriptFunctionEmpty testConfigure
}

isCleanBeforeExportImplemented() {
  ! InstallScripts::scriptFunctionEmpty cleanBeforeExport
}

fullScriptName() {
  File::relativeToDir "${REAL_SCRIPT_FILE}" "${BASH_DEV_ENV_ROOT_DIR}"
}

fullScriptOverrideDir() {
  local confDir
  confDir="$(fullScriptName)"
  local dir
  for dir in "${CONF_OVERRIDE_DIRS[@]}"; do
    if [[ -d "${dir}/${confDir//\//@}" ]]; then
      echo "${dir}/${confDir//\//@}"
      return
    fi
  done
  echo "${CONF_OVERRIDE_DIRS[0]}/${confDir//\//@}"
}

argsInstallScriptCommandCallback() {
  if [[ -n "${command}" ]]; then
    case "${command}" in
      isInterfaceImplemented)
        InstallScripts::isInterfaceMandatoryFunctionImplemented
        exit $?
        ;;
      install | testInstall | configure | testConfigure)
        afterParseCallback
        ;;
      *) ;;
    esac
    "${command}"
    exit $?
  fi
}



declare -a BASH_FRAMEWORK_ARGV_FILTERED=()

beforeParseCallback() {
  Env::requireLoad
  UI::requireTheme
  Log::requireLoad
}

copyrightCallback() {
  #
  # shellcheck disable=SC2155,SC2154,SC2250
  echo "Copyright (c) 2024-now Franois Chastanet"
}

# shellcheck disable=SC2317 # if function is overridden
updateArgListInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--verbose)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListTraceVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vvv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListEnvFileCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListLogLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListDisplayLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListNoColorCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--no-color)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListThemeCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListQuietCallback() { :; }

# shellcheck disable=SC2317 # if function is overridden
optionHelpCallback() {
  Log::displayError "optionHelpCallback needs to be overridden"
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionVersionCallback() {
  # shellcheck disable=SC2154
  echo "${SCRIPT_NAME} version 3.0"
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='--verbose'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_INFO}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_INFO}" >>"${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_DEBUG}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}" >>"${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionTraceVerboseCallback() {
  # shellcheck disable=SC2034
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vvv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_TRACE}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}" >>"${overrideEnvFile}"
}

getLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__LEVEL_OFF}"
      ;;
    ERR | ERROR)
      echo "${__LEVEL_ERROR}"
      ;;
    WARN | WARNING)
      echo "${__LEVEL_WARNING}"
      ;;
    INFO)
      echo "${__LEVEL_INFO}"
      ;;
    DEBUG | TRACE)
      echo "${__LEVEL_DEBUG}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${levelName}"
      return 1
      ;;
  esac
}

getVerboseLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__VERBOSE_LEVEL_OFF}"
      ;;
    ERR | ERROR | WARN | WARNING | INFO)
      echo "${__VERBOSE_LEVEL_INFO}"
      ;;
    DEBUG)
      echo "${__VERBOSE_LEVEL_DEBUG}"
      ;;
    TRACE)
      echo "${__VERBOSE_LEVEL_TRACE}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
      ;;
  esac
}

# shellcheck disable=SC2317 # if function is overridden
optionDisplayLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${logLevel}" >>"${overrideEnvFile}"
}

optionDisplayLevelDefaultValueFunction() {
  Log::getLevelText "${BASH_FRAMEWORK_DISPLAY_LEVEL:-${__LEVEL_INFO}}"
}

# shellcheck disable=SC2317 # if function is overridden
optionLogLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  # shellcheck disable=SC2034
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  echo "BASH_FRAMEWORK_LOG_LEVEL=${logLevel}" >>"${overrideEnvFile}"
}

optionLogLevelDefaultValueFunction() {
  Log::getLevelText "${BASH_FRAMEWORK_LOG_LEVEL:-${__LEVEL_OFF}}"
}

# shellcheck disable=SC2317 # if function is overridden
optionLogFileCallback() {
  local logFile="$2"
  echo "BASH_FRAMEWORK_LOG_FILE='${logFile}'" >>"${overrideEnvFile}"
}

optionLogFileDefaultValueFunction() {
  # shellcheck disable=SC2016
  echo "${BASH_FRAMEWORK_LOG_FILE:-"${FRAMEWORK_ROOT_DIR}/logs/${SCRIPT_NAME}.log"}"
}

# shellcheck disable=SC2317 # if function is overridden
optionQuietCallback() {
  echo "BASH_FRAMEWORK_QUIET_MODE=1" >>"${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionNoColorCallback() {
  UI::theme "noColor"
}

# shellcheck disable=SC2317 # if function is overridden
optionThemeCallback() {
  UI::theme "$2"
}

displayConfig() {
  echo "Config"
  UI::drawLine "-"
  local var
  while read -r var; do
    printf '%-40s = %s\n' "${var}" "$(declare -p "${var}" | sed -E -e 's/^[^=]+=(.*)/\1/')"
  done < <(typeset -p | awk 'match($3, "^(BASH_FRAMEWORK_[^=]+)=", m) { print m[1] }' | sort)
  exit 0
}

optionBashFrameworkConfigCallback() {
  if [[ ! -f "$2" ]]; then
    Log::fatal "Command ${SCRIPT_NAME} - Bash framework config file '$2' does not exists"
  fi
}

overrideEnvFile="$(Framework::createTempFile "overrideEnvFile")"

commandOptionParseFinished() {
  # shellcheck disable=SC2154
  if [[ -f "${optionBashFrameworkConfig}" ]]; then
    files+=("${optionBashFrameworkConfig}")
  fi
  files+=("${overrideEnvFile}")
  Env::requireLoad "${files[@]}"
  Log::requireLoad
  # shellcheck disable=SC2154
  if [[ "${optionConfig}" = "1" ]]; then
    displayConfig
  fi
}


Linux::requireTarCommand
Compiler::Embed::extractDirFromBase64 \
  "${PERSISTENT_TMPDIR:-/tmp}/eed8485b2cd690250b47b9b2c39bfdee4b1a334e1d24f12d3e635059a24bdd00/conf_dir" \
  "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"

declare -gx embed_dir_conf_dir="${PERSISTENT_TMPDIR:-/tmp}/eed8485b2cd690250b47b9b2c39bfdee4b1a334e1d24f12d3e635059a24bdd00/conf_dir"

Linux::requireTarCommand
Compiler::Embed::extractFileFromBase64 \
  "${PERSISTENT_TMPDIR:-/tmp}/4499845f13fbf1e1951f61dc971232e41f02dabc81c92d6f64706fb1f9bfc542/findConfigFiles" \
  "IyEvdXNyL2Jpbi9lbnYgYmFzaAojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMgR0VORVJBVEVEIEZST00gaHR0cHM6Ly9naXRodWIuY29tL2ZjaGFzdGFuZXQvYmFzaC1kZXYtZW52L3RyZWUvbWFzdGVyL3NyYy9fdG9vbHMvZmluZENvbmZpZ0ZpbGVzLWJpbmFyeS55YW1sCiMgRE8gTk9UIEVESVQgSVQKIyBAZ2VuZXJhdGVkCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMjg4LFNDMjAzNAoKCgojIGVuc3VyZSB0aGF0IG5vIHVzZXIgYWxpYXNlcyBjb3VsZCBpbnRlcmZlcmUgd2l0aAojIGNvbW1hbmRzIHVzZWQgaW4gdGhpcyBzY3JpcHQKdW5hbGlhcyAtYSB8fCB0cnVlCnNob3B0IC11IGV4cGFuZF9hbGlhc2VzCgojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKKChmYWlsdXJlcyA9IDApKSB8fCB0cnVlCgojIEJhc2ggd2lsbCByZW1lbWJlciAmIHJldHVybiB0aGUgaGlnaGVzdCBleGl0IGNvZGUgaW4gYSBjaGFpbiBvZiBwaXBlcy4KIyBUaGlzIHdheSB5b3UgY2FuIGNhdGNoIHRoZSBlcnJvciBpbnNpZGUgcGlwZXMsIGUuZy4gbXlzcWxkdW1wIHwgZ3ppcApzZXQgLW8gcGlwZWZhaWwKc2V0IC1vIGVycmV4aXQKCiMgQ29tbWFuZCBTdWJzdGl0dXRpb24gY2FuIGluaGVyaXQgZXJyZXhpdCBvcHRpb24gc2luY2UgYmFzaCB2NC40CnNob3B0IC1zIGluaGVyaXRfZXJyZXhpdCB8fCB0cnVlCgojIGlmIHNldCwgYW5kIGpvYiBjb250cm9sIGlzIG5vdCBhY3RpdmUsIHRoZSBzaGVsbCBydW5zIHRoZSBsYXN0IGNvbW1hbmQKIyBvZiBhIHBpcGVsaW5lIG5vdCBleGVjdXRlZCBpbiB0aGUgYmFja2dyb3VuZCBpbiB0aGUgY3VycmVudCBzaGVsbAojIGVudmlyb25tZW50LgpzaG9wdCAtcyBsYXN0cGlwZQoKIyBhIGxvZyBpcyBnZW5lcmF0ZWQgd2hlbiBhIGNvbW1hbmQgZmFpbHMKc2V0IC1vIGVycnRyYWNlCgojIHVzZSBudWxsZ2xvYiBzbyB0aGF0IChmaWxlKi5waHApIHdpbGwgcmV0dXJuIGFuIGVtcHR5IGFycmF5IGlmIG5vIGZpbGUKIyBtYXRjaGVzIHRoZSB3aWxkY2FyZApzaG9wdCAtcyBudWxsZ2xvYgoKIyBlbnN1cmUgcmVnZXhwIGFyZSBpbnRlcnByZXRlZCB3aXRob3V0IGFjY2VudHVhdGVkIGNoYXJhY3RlcnMKZXhwb3J0IExDX0FMTD1QT1NJWAoKZXhwb3J0IFRFUk09eHRlcm0tMjU2Y29sb3IKCiMgYXZvaWQgaW50ZXJhY3RpdmUgaW5zdGFsbApleHBvcnQgREVCSUFOX0ZST05URU5EPW5vbmludGVyYWN0aXZlCmV4cG9ydCBERUJDT05GX05PTklOVEVSQUNUSVZFX1NFRU49dHJ1ZQoKIyBzdG9yZSBjb21tYW5kIGFyZ3VtZW50cyBmb3IgbGF0ZXIgdXNhZ2UKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0CmRlY2xhcmUgLWEgQkFTSF9GUkFNRVdPUktfQVJHVj0oIiRAIikKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0CmRlY2xhcmUgLWEgT1JJR0lOQUxfQkFTSF9GUkFNRVdPUktfQVJHVj0oIiRAIikKCiMgQHNlZSBodHRwczovL3VuaXguc3RhY2tleGNoYW5nZS5jb20vYS8zODY4NTYKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMzE3CmludGVycnVwdE1hbmFnZW1lbnQoKSB7CiAgIyByZXN0b3JlIFNJR0lOVCBoYW5kbGVyCiAgdHJhcCAtIElOVAogICMgZW5zdXJlIHRoYXQgQ3RybC1DIGlzIHRyYXBwZWQgYnkgdGhpcyBzY3JpcHQgYW5kIG5vdCBieSBzdWIgcHJvY2VzcwogICMgcmVwb3J0IHRvIHRoZSBwYXJlbnQgdGhhdCB3ZSBoYXZlIGluZGVlZCBiZWVuIGludGVycnVwdGVkCiAga2lsbCAtcyBJTlQgIiQkIgp9CnRyYXAgaW50ZXJydXB0TWFuYWdlbWVudCBJTlQKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojIFRlbXAgZGlyIG1hbmFnZW1lbnQKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgpLRUVQX1RFTVBfRklMRVM9IiR7S0VFUF9URU1QX0ZJTEVTOi0wfSIKZXhwb3J0IEtFRVBfVEVNUF9GSUxFUwoKIyBQRVJTSVNURU5UX1RNUERJUiBpcyBub3QgZGVsZXRlZCBieSB0cmFwcwpQRVJTSVNURU5UX1RNUERJUj0iJHtUTVBESVI6LS90bXB9L2Jhc2gtZnJhbWV3b3JrIgpleHBvcnQgUEVSU0lTVEVOVF9UTVBESVIKaWYgW1sgISAtZCAiJHtQRVJTSVNURU5UX1RNUERJUn0iIF1dOyB0aGVuCiAgbWtkaXIgLXAgIiR7UEVSU0lTVEVOVF9UTVBESVJ9IgpmaQoKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0ClRNUERJUj0iJChta3RlbXAgLWQgLXAgIiR7UEVSU0lTVEVOVF9UTVBESVI6LS90bXB9IiAtdCBiYXNoLWZyYW1ld29yay0kJC1YWFhYWFgpIgpleHBvcnQgVE1QRElSCgojIHRlbXAgZGlyIGNsZWFuaW5nCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjMxNwpjbGVhbk9uRXhpdCgpIHsKICBsb2NhbCByYz0kPwogIGlmIFtbICIke0tFRVBfVEVNUF9GSUxFUzotMH0iID0gIjEiIF1dOyB0aGVuCiAgICBMb2c6OmRpc3BsYXlJbmZvICJLRUVQX1RFTVBfRklMRVM9MSB0ZW1wIGZpbGVzIGtlcHQgaGVyZSAnJHtUTVBESVJ9JyIKICBlbGlmIFtbIC1uICIke1RNUERJUit4eHh9IiBdXTsgdGhlbgogICAgTG9nOjpkaXNwbGF5RGVidWcgIktFRVBfVEVNUF9GSUxFUz0wIHJlbW92aW5nIHRlbXAgZmlsZXMgJyR7VE1QRElSfSciCiAgICBybSAtUmYgIiR7VE1QRElSOi0vdG1wL2Zha2V9IiA+L2Rldi9udWxsIDI+JjEKICBmaQogIGV4aXQgIiR7cmN9Igp9CnRyYXAgY2xlYW5PbkV4aXQgRVhJVCBIVVAgUVVJVCBBQlJUIFRFUk0KCgpTQ1JJUFRfTkFNRT0kezAjIyovfQpSRUFMX1NDUklQVF9GSUxFPSIkKHJlYWRsaW5rIC1lICIkKHJlYWxwYXRoICIke0JBU0hfU09VUkNFWzBdfSIpIikiCmlmIFtbIC1uICIke0VNQkVEX0NVUlJFTlRfRElSfSIgXV07IHRoZW4KICBDVVJSRU5UX0RJUj0iJHtFTUJFRF9DVVJSRU5UX0RJUn0iCmVsc2UKICBDVVJSRU5UX0RJUj0iJHtSRUFMX1NDUklQVF9GSUxFJS8qfSIKZmkKRlJBTUVXT1JLX1JPT1RfRElSPSIkKGNkICIke0NVUlJFTlRfRElSfS8uIiAmJiBwd2QgLVApIgpGUkFNRVdPUktfU1JDX0RJUj0iJHtGUkFNRVdPUktfUk9PVF9ESVJ9L3NyYyIKRlJBTUVXT1JLX0JJTl9ESVI9IiR7RlJBTUVXT1JLX1JPT1RfRElSfS9iaW4iCkZSQU1FV09SS19WRU5ET1JfRElSPSIke0ZSQU1FV09SS19ST09UX0RJUn0vdmVuZG9yIgpGUkFNRVdPUktfVkVORE9SX0JJTl9ESVI9IiR7RlJBTUVXT1JLX1JPT1RfRElSfS92ZW5kb3IvYmluIgoKIyBAZGVzY3JpcHRpb24gTG9nIG5hbWVzcGFjZSBwcm92aWRlcyAyIGtpbmQgb2YgZnVuY3Rpb25zCiMgLSBMb2c6OmRpc3BsYXkqIGFsbG93cyB0byBkaXNwbGF5IGdpdmVuIG1lc3NhZ2Ugd2l0aAojICAgZ2l2ZW4gZGlzcGxheSBsZXZlbAojIC0gTG9nOjpsb2cqIGFsbG93cyB0byBsb2cgZ2l2ZW4gbWVzc2FnZSB3aXRoCiMgICBnaXZlbiBsb2cgbGV2ZWwKIyBMb2c6OmRpc3BsYXkqIGZ1bmN0aW9ucyBhdXRvbWF0aWNhbGx5IGxvZyB0aGUgbWVzc2FnZSB0b28KIyBAc2VlIEVudjo6cmVxdWlyZUxvYWQgdG8gbG9hZCB0aGUgZGlzcGxheSBhbmQgbG9nIGxldmVsIGZyb20gLmVudiBmaWxlCgojIEBkZXNjcmlwdGlvbiBsb2cgbGV2ZWwgb2ZmCmV4cG9ydCBfX0xFVkVMX09GRj0wCiMgQGRlc2NyaXB0aW9uIGxvZyBsZXZlbCBlcnJvcgpleHBvcnQgX19MRVZFTF9FUlJPUj0xCiMgQGRlc2NyaXB0aW9uIGxvZyBsZXZlbCB3YXJuaW5nCmV4cG9ydCBfX0xFVkVMX1dBUk5JTkc9MgojIEBkZXNjcmlwdGlvbiBsb2cgbGV2ZWwgaW5mbwpleHBvcnQgX19MRVZFTF9JTkZPPTMKIyBAZGVzY3JpcHRpb24gbG9nIGxldmVsIHN1Y2Nlc3MKZXhwb3J0IF9fTEVWRUxfU1VDQ0VTUz0zCiMgQGRlc2NyaXB0aW9uIGxvZyBsZXZlbCBkZWJ1ZwpleHBvcnQgX19MRVZFTF9ERUJVRz00CgojIEBkZXNjcmlwdGlvbiB2ZXJib3NlIGxldmVsIG9mZgpleHBvcnQgX19WRVJCT1NFX0xFVkVMX09GRj0wCiMgQGRlc2NyaXB0aW9uIHZlcmJvc2UgbGV2ZWwgaW5mbwpleHBvcnQgX19WRVJCT1NFX0xFVkVMX0lORk89MQojIEBkZXNjcmlwdGlvbiB2ZXJib3NlIGxldmVsIGluZm8KZXhwb3J0IF9fVkVSQk9TRV9MRVZFTF9ERUJVRz0yCiMgQGRlc2NyaXB0aW9uIHZlcmJvc2UgbGV2ZWwgaW5mbwpleHBvcnQgX19WRVJCT1NFX0xFVkVMX1RSQUNFPTMKCgojIEBkZXNjcmlwdGlvbiBjaGVjayBpZiBhbiBlbGVtZW50IGlzIGNvbnRhaW5lZCBpbiBhbiBhcnJheQojCiMgQGFyZyAkMSBuZWVkbGU6U3RyaW5nCiMgQGFyZyAkQCBhcnJheTpTdHJpbmdbXQojIEBleGl0Y29kZSAwIGlmIGZvdW5kCiMgQGV4aXRjb2RlIDEgb3RoZXJ3aXNlCiMgQGV4YW1wbGUKIyAgIEFycmF5Ojpjb250YWlucyAiJHtsaWJQYXRofSIgIiR7X19CQVNIX0ZSQU1FV09SS19JTVBPUlRFRF9GSUxFU1tAXX0iCkFycmF5Ojpjb250YWlucygpIHsKICBsb2NhbCBlbGVtZW50CiAgZm9yIGVsZW1lbnQgaW4gIiR7QDoyfSI7IGRvCiAgICBbWyAiJHtlbGVtZW50fSIgPSAiJDEiIF1dICYmIHJldHVybiAwCiAgZG9uZQogIHJldHVybiAxCn0KCgojIEBkZXNjcmlwdGlvbiBjb25jYXRlbmF0ZSBlYWNoIGVsZW1lbnQgb2YgYW4gYXJyYXkgd2l0aCBhIHNlcGFyYXRvcgojIGJ1dCB3cmFwcGluZyB0ZXh0IHdoZW4gbGluZSBsZW5ndGggaXMgbW9yZSB0aGFuIHByb3ZpZGVkIGFyZ3VtZW50CiMgVGhlIGFsZ29yaXRobSB3aWxsIHRyeSBub3QgdG8gY3V0IHRoZSBhcnJheSBlbGVtZW50IGlmIGl0IGNhbi4KIyAtIGlmIGFuIGFyZyBjYW4gYmUgcGxhY2VkIG9uIGN1cnJlbnQgbGluZSBpdCB3aWxsIGJlLAojICAgb3RoZXJ3aXNlIGN1cnJlbnQgbGluZSBpcyBwcmludGVkIGFuZCBhcmcgaXMgYWRkZWQgdG8gdGhlIG5ldwojICAgY3VycmVudCBsaW5lCiMgLSBFbXB0eSBhcmcgaXMgaW50ZXJwcmV0ZWQgYXMgYSBuZXcgbGluZS4KIyAtIEFkZCBcciB0byBhcmcgaW4gb3JkZXIgdG8gZm9yY2UgYnJlYWsgbGluZSBhbmQgYXZvaWQgZm9sbG93aW5nCiMgICBhcmcgdG8gYmUgY29uY2F0ZW5hdGVkIHdpdGggY3VycmVudCBhcmcuCiMKIyBAYXJnICQxIGdsdWU6U3RyaW5nCiMgQGFyZyAkMiBtYXhMaW5lTGVuZ3RoOmludAojIEBhcmcgJDMgaW5kZW50TmV4dExpbmU6aW50CiMgQGFyZyAkQCBhcnJheTpTdHJpbmdbXQpBcnJheTo6d3JhcDIoKSB7CiAgbG9jYWwgZ2x1ZT0iJHsxLX0iCiAgbG9jYWwgLWkgZ2x1ZUxlbmd0aD0iJHsjZ2x1ZX0iCiAgc2hpZnQgfHwgdHJ1ZQogIGxvY2FsIC1pIG1heExpbmVMZW5ndGg9JDEKICBzaGlmdCB8fCB0cnVlCiAgbG9jYWwgLWkgaW5kZW50TmV4dExpbmU9JDEKICBzaGlmdCB8fCB0cnVlCiAgbG9jYWwgaW5kZW50U3RyPSIiCiAgaWYgKChpbmRlbnROZXh0TGluZSA+IDApKTsgdGhlbgogICAgaW5kZW50U3RyPSIkKGhlYWQgLWMgIiR7aW5kZW50TmV4dExpbmV9IiA8L2Rldi96ZXJvIHwgdHIgJ1wwJyAiICIpIgogIGZpCiAgaWYgKCgkIyA9PSAwKSk7IHRoZW4KICAgIHJldHVybiAwCiAgZmkKCiAgcHJpbnRDdXJyZW50TGluZSgpIHsKICAgIGlmICgoaXNOZXdsaW5lID09IDApKSB8fCAoKHByZXZpb3VzTGluZUVtcHR5ID09IDEpKTsgdGhlbgogICAgICBlY2hvCiAgICBmaQogICAgKChpc05ld2xpbmUgPSAxKSkKICAgIGVjaG8gLWVuICIke2luZGVudFN0cn0iCiAgICAoKGN1cnJlbnRMaW5lTGVuZ3RoID0gaW5kZW50TmV4dExpbmUpKSB8fCB0cnVlCiAgfQogIGFwcGVuZFRvQ3VycmVudExpbmUoKSB7CiAgICBsb2NhbCB0ZXh0PSIkMSIKICAgIGxvY2FsIC1pIGxlbmd0aD0kMgogICAgKChjdXJyZW50TGluZUxlbmd0aCArPSBsZW5ndGgpKSB8fCB0cnVlCiAgICAoKGlzTmV3bGluZSA9IDApKSB8fCB0cnVlCiAgICBpZiBbWyAiJHt0ZXh0OiAtMX0iID0gJCdccicgXV07IHRoZW4KICAgICAgdGV4dD0iJHt0ZXh0OjA6LTF9IgogICAgICBlY2hvIC1lbiAiJHt0ZXh0JSUrKFtbOmJsYW5rOl1dKX0iCiAgICAgIHByaW50Q3VycmVudExpbmUKICAgIGVsc2UKICAgICAgZWNobyAtZW4gIiR7dGV4dCUlKyhbWzpibGFuazpdXSl9IgogICAgZmkKICB9CgogICgKICAgIGxvY2FsIGN1cnJlbnRMaW5lCiAgICBsb2NhbCAtaSBjdXJyZW50TGluZUxlbmd0aD0wIGlzTmV3bGluZT0xIGFyZ0xlbmd0aD0wCiAgICBsb2NhbCAtYSBhZGRpdGlvbmFsTGluZXMKICAgIGxvY2FsIC1pIHByZXZpb3VzTGluZUVtcHR5PTAKICAgIGxvY2FsIGFyZz0iIgoKICAgIHdoaWxlICgoJCMgPiAwKSk7IGRvCiAgICAgIGFyZz0iJDEiCiAgICAgIHNoaWZ0IHx8IHRydWUKCiAgICAgICMgcmVwbGFjZSB0YWIgYnkgMiBzcGFjZXMKICAgICAgYXJnPSIke2FyZy8vJCdcdCcvICB9IgogICAgICAjIHJlbW92ZSB0cmFpbGluZyBzcGFjZXMKICAgICAgYXJnPSIke2FyZyVbWzpibGFuazpdXX0iCiAgICAgIGlmIFtbICIke2FyZ30iID0gJCdcbicgfHwgLXogIiR7YXJnfSIgXV07IHRoZW4KICAgICAgICBwcmludEN1cnJlbnRMaW5lCiAgICAgICAgKChwcmV2aW91c0xpbmVFbXB0eSA9IDEpKQogICAgICAgIGNvbnRpbnVlCiAgICAgIGVsc2UKICAgICAgICBpZiAoKHByZXZpb3VzTGluZUVtcHR5ID09IDEpKTsgdGhlbgogICAgICAgICAgcHJpbnRDdXJyZW50TGluZQogICAgICAgIGZpCiAgICAgICAgKChwcmV2aW91c0xpbmVFbXB0eSA9IDApKSB8fCB0cnVlCiAgICAgIGZpCiAgICAgICMgY29udmVydCBlb2wgdG8gYXJncwogICAgICBtYXBmaWxlIC10IGFkZGl0aW9uYWxMaW5lcyA8PDwiJHthcmd9IgogICAgICBpZiAoKCR7I2FkZGl0aW9uYWxMaW5lc1tAXX0gPiAxKSk7IHRoZW4KICAgICAgICBzZXQgLS0gIiR7YWRkaXRpb25hbExpbmVzW0BdfSIgIiRAIgogICAgICAgIGNvbnRpbnVlCiAgICAgIGZpCgogICAgICAoKGFyZ0xlbmd0aCA9ICR7I2FyZ30pKSB8fCB0cnVlCgogICAgICAjIGVtcHR5IGFyZwogICAgICBpZiAoKGFyZ0xlbmd0aCA9PSAwKSk7IHRoZW4KICAgICAgICBpZiAoKGlzTmV3bGluZSA9PSAwKSk7IHRoZW4KICAgICAgICAgICMgaXNOZXdsaW5lID0gMCBtZWFucyBjdXJyZW50TGluZSBpcyBub3QgZW1wdHkKICAgICAgICAgIHByaW50Q3VycmVudExpbmUKICAgICAgICBmaQogICAgICAgIGNvbnRpbnVlCiAgICAgIGZpCgogICAgICBpZiAoKGlzTmV3bGluZSA9PSAwKSk7IHRoZW4KICAgICAgICBnbHVlTGVuZ3RoPSIkeyNnbHVlfSIKICAgICAgZWxzZQogICAgICAgIGdsdWVMZW5ndGg9IjAiCiAgICAgIGZpCiAgICAgIGlmICgoY3VycmVudExpbmVMZW5ndGggKyBhcmdMZW5ndGggKyBnbHVlTGVuZ3RoID4gbWF4TGluZUxlbmd0aCkpOyB0aGVuCiAgICAgICAgaWYgKChhcmdMZW5ndGggKyBnbHVlTGVuZ3RoID4gbWF4TGluZUxlbmd0aCkpOyB0aGVuCiAgICAgICAgICAjIGFyZyBpcyB0b28gbG9uZyB0byBldmVuIGZpdCBvbiBvbmUgbGluZQogICAgICAgICAgIyB3ZSBoYXZlIHRvIHNwbGl0IHRoZSBhcmcgb24gY3VycmVudCBhbmQgbmV4dCBsaW5lCiAgICAgICAgICBsb2NhbCAtaSByZW1haW5pbmdMaW5lTGVuZ3RoCiAgICAgICAgICAoKHJlbWFpbmluZ0xpbmVMZW5ndGggPSBtYXhMaW5lTGVuZ3RoIC0gY3VycmVudExpbmVMZW5ndGggLSBnbHVlTGVuZ3RoKSkKICAgICAgICAgIGFwcGVuZFRvQ3VycmVudExpbmUgIiR7Z2x1ZTowOiR7Z2x1ZUxlbmd0aH19JHthcmc6MDoke3JlbWFpbmluZ0xpbmVMZW5ndGh9fSIgIiQoKGdsdWVMZW5ndGggKyByZW1haW5pbmdMaW5lTGVuZ3RoKSkiCiAgICAgICAgICBwcmludEN1cnJlbnRMaW5lCiAgICAgICAgICBhcmc9IiR7YXJnOiR7cmVtYWluaW5nTGluZUxlbmd0aH19IgogICAgICAgICAgIyByZW1vdmUgbGVhZGluZyBzcGFjZXMKICAgICAgICAgIGFyZz0iJHthcmcjI1tbOmJsYW5rOl1dfSIKCiAgICAgICAgICBzZXQgLS0gIiR7YXJnfSIgIiRAIgogICAgICAgIGVsc2UKICAgICAgICAgICMgdGhlIGFyZyBjYW4gZml0IG9uIG5leHQgbGluZQogICAgICAgICAgcHJpbnRDdXJyZW50TGluZQogICAgICAgICAgYXBwZW5kVG9DdXJyZW50TGluZSAiJHthcmd9IiAiJHthcmdMZW5ndGh9IgogICAgICAgIGZpCiAgICAgIGVsc2UKICAgICAgICBhcHBlbmRUb0N1cnJlbnRMaW5lICIke2dsdWU6MDoke2dsdWVMZW5ndGh9fSR7YXJnfSIgIiQoKGdsdWVMZW5ndGggKyBhcmdMZW5ndGgpKSIKICAgICAgZmkKICAgIGRvbmUKICAgIGlmIFtbICIke2N1cnJlbnRMaW5lfSIgIT0gIiIgXV0gJiYgW1sgISAiJHtjdXJyZW50TGluZX0iID1+IF5bXCBcdF0rJCBdXTsgdGhlbgogICAgICBwcmludEN1cnJlbnRMaW5lCiAgICBmaQogICkgfCBzZWQgLUUgLWUgJ3MvW1s6Ymxhbms6XV0rJC8vJwp9CgoKIyBAZGVzY3JpcHRpb24gY2hlY2sgaWYgY29tbWFuZCBzcGVjaWZpZWQgZXhpc3RzIG9yIHJldHVybiAxCiMgd2l0aCBlcnJvciBhbmQgbWVzc2FnZSBpZiBub3QKIwojIEBhcmcgJDEgY29tbWFuZE5hbWU6U3RyaW5nIG9uIHdoaWNoIGV4aXN0ZW5jZSBtdXN0IGJlIGNoZWNrZWQKIyBAYXJnICQyIGhlbHBJZk5vdEV4aXN0czpTdHJpbmcgYSBoZWxwIGNvbW1hbmQgdG8gZGlzcGxheSBpZiB0aGUgY29tbWFuZCBkb2VzIG5vdCBleGlzdAojCiMgQGV4aXRjb2RlIDEgaWYgdGhlIGNvbW1hbmQgc3BlY2lmaWVkIGRvZXMgbm90IGV4aXN0CiMgQHN0ZGVyciBkaWFnbm9zdGljIGluZm9ybWF0aW9uICsgaGVscCBpZiBzZWNvbmQgYXJndW1lbnQgaXMgcHJvdmlkZWQKQXNzZXJ0Ojpjb21tYW5kRXhpc3RzKCkgewogIGxvY2FsIGNvbW1hbmROYW1lPSIkMSIKICBsb2NhbCBoZWxwSWZOb3RFeGlzdHM9IiQyIgoKICAiJHtCQVNIX0ZSQU1FV09SS19DT01NQU5EOi1jb21tYW5kfSIgLXYgIiR7Y29tbWFuZE5hbWV9IiA+L2Rldi9udWxsIDI+L2Rldi9udWxsIHx8IHsKICAgIExvZzo6ZGlzcGxheUVycm9yICIke2NvbW1hbmROYW1lfSBpcyBub3QgaW5zdGFsbGVkLCBwbGVhc2UgaW5zdGFsbCBpdCIKICAgIGlmIFtbIC1uICIke2hlbHBJZk5vdEV4aXN0c30iIF1dOyB0aGVuCiAgICAgIExvZzo6ZGlzcGxheUluZm8gIiR7aGVscElmTm90RXhpc3RzfSIKICAgIGZpCiAgICByZXR1cm4gMQogIH0KICByZXR1cm4gMAp9CgoKIyBAZGVzY3JpcHRpb24gY2hlY2sgaWYgdHR5IChpbnRlcmFjdGl2ZSBtb2RlKSBpcyBhY3RpdmUKIyBAbm9hcmdzCiMgQGV4aXRjb2RlIDEgaWYgdHR5IG5vdCBhY3RpdmUKIyBAZW52IE5PTl9JTlRFUkFDVElWRSBpZiAxIGNvbnNpZGVyIGFzIG5vdCBpbnRlcmFjdGl2ZSBldmVuIGlmIGVudmlyb25tZW50IGlzIGludGVyYWN0aXZlCiMgQGVudiBJTlRFUkFDVElWRSBpZiAxIGNvbnNpZGVyIGFzIGludGVyYWN0aXZlIGV2ZW4gaWYgZW52aXJvbm1lbnQgaXMgbm90IGludGVyYWN0aXZlCkFzc2VydDo6dHR5KCkgewogIGlmIFtbICIke05PTl9JTlRFUkFDVElWRTotMH0iID0gIjEiIF1dOyB0aGVuCiAgICByZXR1cm4gMQogIGZpCiAgaWYgW1sgIiR7SU5URVJBQ1RJVkU6LTB9IiA9ICIxIiBdXTsgdGhlbgogICAgcmV0dXJuIDAKICBmaQogIHR0eSAtcwp9CgoKIyBAZGVzY3JpcHRpb24gY29udmVydCBiYXNlNjQgZW5jb2RlZCBiYWNrIHRvIHRhcmdldCBmaWxlCiMgaWYgdGFyZ2V0IGZpbGUgaXMgZXhlY3V0YWJsZSBwcmVwZW5kIGRpciBvZiB0YXJnZXQKIyBmaWxlIHRvIFBBVEggdG8gbWFrZSBiaW5hcnkgYXZhaWxhYmxlIGV2ZXJ5d2hlcmUKIyBpdCBpcyBhZHZpc2VkIHRvIGluY2x1ZGUgaW4gdGhlIHBhdGggb2YgdGhlIHRhcmdldCBmaWxlCiMgdGhlIG1kNXN1bSBvZiB0aGUgYmluRmlsZQojCiMgQGFyZyAkMSB0YXJnZXRGaWxlOlN0cmluZyB0aGUgZmlsZSB0byB3cml0ZQojIEBhcmcgJDIgYmluRmlsZUJhc2U2NDpTdHJpbmcgdGhlIGJhc2U2NCBlbmNvZGVkIGZpbGUKIyBAYXJnICQzIGZpbGVNb2RlOlN0cmluZyB0aGUgY2htb2QgdG8gc2V0IG9uIHRoZSBmaWxlCiMgQHNldCBQQVRIIFN0cmluZyBwcmVwZW5kIHRhcmdldCBlbWJlZGRlZCBmaWxlIGJpbmFyeSBkaXJlY3RvcnkgdG8gUEFUSCB2YXJpYWJsZSBpZiBiaW5hcnkgZXhlY3V0YWJsZQpDb21waWxlcjo6RW1iZWQ6OmV4dHJhY3RGaWxlRnJvbUJhc2U2NCgpIHsKICBsb2NhbCB0YXJnZXRGaWxlPSIkMSIKICBsb2NhbCBiaW5GaWxlQmFzZTY0PSIkMiIKICBsb2NhbCBmaWxlTW9kZT0iJHszOi0reH0iCiAgbG9jYWwgdGFyZ2V0RGlyPSIke3RhcmdldEZpbGUlLyp9IgoKICBpZiBbWyAhIC1mICIke3RhcmdldEZpbGV9IiBdXTsgdGhlbgogICAgaWYgW1sgISAtZCAiJHt0YXJnZXREaXJ9IiBdXTsgdGhlbgogICAgICBta2RpciAtcCAiJHt0YXJnZXREaXJ9IgogICAgZmkKICAgIGJhc2U2NCAtZCA+IiR7dGFyZ2V0RmlsZX0iIDw8PCIke2JpbkZpbGVCYXNlNjR9IgogICAgY2htb2QgIiR7ZmlsZU1vZGV9IiAiJHt0YXJnZXRGaWxlfSIKICBmaQoKICBpZiBbWyAteCAiJHt0YXJnZXRGaWxlfSIgXV07IHRoZW4KICAgIEVudjo6cGF0aFByZXBlbmQgIiR7dGFyZ2V0RGlyfSIKICBmaQp9CgoKIyBAZGVzY3JpcHRpb24gTG9hZCB0aGUgbmVhcmVzdCBjb25maWcgZmlsZQojIGluIG5leHQgZXhhbXBsZSB3aWxsIHNlYXJjaCBmaXJzdCAuZnJhbWV3b3JrLWNvbmZpZyBmaWxlIGluICJzcmNEaXIxIgojIHRoZW4gaWYgbm90IGZvdW5kIHdpbGwgZ28gaW4gdXAgZGlyZWN0b3JpZXMgdW50aWwgLwojIHRoZW4gd2lsbCBzZWFyY2ggaW4gInNyY0RpcjIiCiMgdGhlbiBpZiBub3QgZm91bmQgd2lsbCBnbyBpbiB1cCBkaXJlY3RvcmllcyB1bnRpbCAvCiMgc291cmNlIHRoZSBmaWxlIGlmIGZvdW5kCiMgQGV4YW1wbGUKIyAgIENvbmY6OmxvYWROZWFyZXN0RmlsZSAiLmZyYW1ld29yay1jb25maWciICJzcmNEaXIxIiAic3JjRGlyMiIKIwojIEBhcmcgJDEgY29uZmlnRmlsZU5hbWU6U3RyaW5nIGNvbmZpZyBmaWxlIG5hbWUgdG8gc2VhcmNoCiMgQGFyZyAkMiBsb2FkZWRGaWxlOlN0cmluZyAocGFzc2VkIGJ5IHJlZmVyZW5jZSkgd2lsbCByZXR1cm4gdGhlIGxvYWRlZCBjb25maWcgZmlsZSBuYW1lCiMgQGFyZyAkQCBzcmNEaXJzOlN0cmluZ1tdIHNvdXJjZSBkaXJlY3RvcmllcyBpbiB3aGljaCB0aGUgY29uZmlnIGZpbGUgd2lsbCBiZSBzZWFyY2hlZAojIEBleGl0Y29kZSAwIGlmIGZpbGUgZm91bmQKIyBAZXhpdGNvZGUgMSBpZiBmaWxlIG5vdCBmb3VuZApDb25mOjpsb2FkTmVhcmVzdEZpbGUoKSB7CiAgbG9jYWwgY29uZmlnRmlsZU5hbWU9IiQxIgogIGxvY2FsIC1uIGxvYWRlZEZpbGU9IiQyIgogIHNoaWZ0IDIgfHwgdHJ1ZQogIGxvY2FsIC1hIHNyY0RpcnM9KCIkQCIpCiAgZm9yIHNyY0RpciBpbiAiJHtzcmNEaXJzW0BdfSI7IGRvCiAgICBjb25maWdGaWxlPSIkKEZpbGU6OnVwRmluZCAiJHtzcmNEaXJ9IiAiJHtjb25maWdGaWxlTmFtZX0iIHx8IHRydWUpIgogICAgaWYgW1sgLW4gIiR7Y29uZmlnRmlsZX0iIF1dOyB0aGVuCiAgICAgICMgc2hlbGxjaGVjayBzb3VyY2U9Ly5mcmFtZXdvcmstY29uZmlnCiAgICAgIHNvdXJjZSAiJHtjb25maWdGaWxlfSIgfHwgTG9nOjpmYXRhbCAiZXJyb3Igd2hpbGUgbG9hZGluZyBjb25maWcgZmlsZSAnJHtjb25maWdGaWxlfSciCiAgICAgIExvZzo6ZGlzcGxheURlYnVnICJDb25maWcgZmlsZSAke2NvbmZpZ0ZpbGV9IGlzIGxvYWRlZCIKICAgICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0CiAgICAgIGxvYWRlZEZpbGU9IiR7Y29uZmlnRmlsZX0iCiAgICAgIHJldHVybiAwCiAgICBmaQogIGRvbmUKCiAgTG9nOjpkaXNwbGF5RGVidWcgIkNvbmZpZyBmaWxlICcke2NvbmZpZ0ZpbGVOYW1lfScgbm90IGZvdW5kIGluIGFueSBzb3VyY2UgZGlyZWN0b3JpZXMgcHJvdmlkZWQiCiAgcmV0dXJuIDEKfQoKCiMgQGRlc2NyaXB0aW9uIGRlZmF1bHQgZW52IGZpbGUgd2l0aCBhbGwgZGVmYXVsdCB2YWx1ZXMKIyBAc3Rkb3V0IHRoZSBkZWZhdWx0IGVudiBmaWxlcGF0aApFbnY6OmNyZWF0ZURlZmF1bHRFbnZGaWxlKCkgewogIGxvY2FsIGVudkZpbGUKICBlbnZGaWxlPSIkKEZyYW1ld29yazo6Y3JlYXRlVGVtcEZpbGUgImNyZWF0ZURlZmF1bHRFbnZGaWxlRW52RmlsZSIpIiB8fCByZXR1cm4gMgoKICAoCiAgICBlY2hvICJCQVNIX0ZSQU1FV09SS19USEVNRT0ke0JBU0hfRlJBTUVXT1JLX1RIRU1FOi1kZWZhdWx0fSIKICAgIGVjaG8gIkJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTD0ke0JBU0hfRlJBTUVXT1JLX0xPR19MRVZFTDotJHtfX0xFVkVMX09GRn19IgogICAgZWNobyAiQkFTSF9GUkFNRVdPUktfRElTUExBWV9MRVZFTD0ke0JBU0hfRlJBTUVXT1JLX0RJU1BMQVlfTEVWRUw6LSR7X19MRVZFTF9JTkZPfX0iCiAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMTYKICAgIGVjaG8gJ0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFPSIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFOi0iJHtGUkFNRVdPUktfUk9PVF9ESVJ9L2xvZ3MvJHtTQ1JJUFRfTkFNRX0ubG9nIn0iJwogICAgZWNobyAiQkFTSF9GUkFNRVdPUktfTE9HX0ZJTEVfTUFYX1JPVEFUSU9OPSR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEVfTUFYX1JPVEFUSU9OOi01fSIKICApID4iJHtlbnZGaWxlfSIKICBlY2hvICIke2VudkZpbGV9Igp9CgoKIyBAZGVzY3JpcHRpb24gcHJlcGVuZCBkaXJlY3RvcmllcyB0byB0aGUgUEFUSCBlbnZpcm9ubWVudCB2YXJpYWJsZQojIEBhcmcgJEAgYXJnczpTdHJpbmdbXSBsaXN0IG9mIGRpcmVjdG9yaWVzIHRvIHByZXBlbmQKIyBAc2V0IFBBVEggdXBkYXRlIFBBVEggd2l0aCB0aGUgZGlyZWN0b3JpZXMgcHJlcGVuZGVkCkVudjo6cGF0aFByZXBlbmQoKSB7CiAgbG9jYWwgYXJnCiAgZm9yIGFyZyBpbiAiJEAiOyBkbwogICAgaWYgW1sgLWQgIiR7YXJnfSIgJiYgIjoke1BBVEh9OiIgIT0gKiI6JHthcmd9OiIqIF1dOyB0aGVuCiAgICAgIFBBVEg9IiQocmVhbHBhdGggIiR7YXJnfSIpOiR7UEFUSH0iCiAgICBmaQogIGRvbmUKfQoKCiMgQGRlc2NyaXB0aW9uIGVuc3VyZSBlbnYgZmlsZXMgYXJlIGxvYWRlZAojIEBhcmcgJEAgbGlzdCBvZiBkZWZhdWx0IGZpbGVzIHRvIGxvYWQgYXQgdGhlIGVuZAojIEBleGl0Y29kZSAxIGlmIG9uZSBvZiBlbnYgZmlsZXMgZmFpbHMgdG8gbG9hZAojIEBzdGRlcnIgZGlhZ25vc3RpY3MgaW5mb3JtYXRpb24gaXMgZGlzcGxheWVkCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjEyMApFbnY6OnJlcXVpcmVMb2FkKCkgewogIGV4cG9ydCBSRVFVSVJFX0ZVTkNUSU9OX0VOVl9SRVFVSVJFX0xPQURfTE9BREVEPTEKCiAgbG9jYWwgLWEgZGVmYXVsdEZpbGVzPSgiJEAiKQogICMgZ2V0IGxpc3Qgb2YgcG9zc2libGUgY29uZmlnIGZpbGVzCiAgbG9jYWwgLWEgY29uZmlnRmlsZXM9KCkKICBsb2NhbCBkZWZhdWx0RW52RmlsZQogIGRlZmF1bHRFbnZGaWxlPSIkKEVudjo6Y3JlYXRlRGVmYXVsdEVudkZpbGUpIiB8fCByZXR1cm4gMQogIGNvbmZpZ0ZpbGVzKz0oIiR7ZGVmYXVsdEVudkZpbGV9IikKICBpZiBbWyAtbiAiJHtCQVNIX0ZSQU1FV09SS19FTlZfRklMRVNbMF0rMX0iIF1dOyB0aGVuCiAgICAjIEJBU0hfRlJBTUVXT1JLX0VOVl9GSUxFUyBpcyBhbiBhcnJheQogICAgY29uZmlnRmlsZXMrPSgiJHtCQVNIX0ZSQU1FV09SS19FTlZfRklMRVNbQF19IikKICBmaQogIGlmIFtbIC1mICIke0ZSQU1FV09SS19ST09UX0RJUn0vLmZyYW1ld29yay1jb25maWciIF1dOyB0aGVuCiAgICBjb25maWdGaWxlcys9KCIke0ZSQU1FV09SS19ST09UX0RJUn0vLmZyYW1ld29yay1jb25maWciKQogIGZpCiAgbG9jYWwgbG9jYWxGcmFtZXdvcmtDb25maWdGaWxlCiAgQkFTSF9GUkFNRVdPUktfRElTUExBWV9MRVZFTD0iJHtfX0xFVkVMX0lORk99IiBcCiAgICBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUw9IiR7X19MRVZFTF9PRkZ9IiBcCiAgICBDb25mOjpsb2FkTmVhcmVzdEZpbGUgIi5mcmFtZXdvcmstY29uZmlnIiBsb2NhbEZyYW1ld29ya0NvbmZpZ0ZpbGUgIiQocHdkKSIgfHwgdHJ1ZQogIGlmIFtbIC1mICIke2xvY2FsRnJhbWV3b3JrQ29uZmlnRmlsZX0iIF1dOyB0aGVuCiAgICBjb25maWdGaWxlcys9KCIke2xvY2FsRnJhbWV3b3JrQ29uZmlnRmlsZX0iKQogIGZpCiAgY29uZmlnRmlsZXMrPSgiJHtvcHRpb25FbnZGaWxlc1tAXX0iKQogIGNvbmZpZ0ZpbGVzKz0oIiR7ZGVmYXVsdEZpbGVzW0BdfSIpCgogIHdoaWxlIElGUz0nJyByZWFkIC1yIGZpbGU7IGRvCiAgICAjIHNoZWxsY2hlY2sgc291cmNlPS9zcmMvRW52L2NyZWF0ZURlZmF1bHRFbnZGaWxlLnNoCiAgICBDVVJSRU5UX0xPQURFRF9FTlZfRklMRT0iJHtmaWxlfSIgc291cmNlICIke2ZpbGV9IiB8fCB7CiAgICAgIExvZzo6ZGlzcGxheUVycm9yICJ3aGlsZSBsb2FkaW5nIGNvbmZpZyBmaWxlOiAke2ZpbGV9IgogICAgICByZXR1cm4gMQogICAgfQogIGRvbmUgPCA8KHByaW50ZiAnJXNcbicgIiR7Y29uZmlnRmlsZXNbQF19IiB8IGF3ayAnIXhbJDBdKysnKQp9CgoKIyBAZGVzY3JpcHRpb24gc2VhcmNoIGEgZmlsZSBpbiBwYXJlbnQgZGlyZWN0b3JpZXMKIwojIEBhcmcgJDEgZnJvbVBhdGg6U3RyaW5nIHBhdGgKIyBAYXJnICQyIGZpbGVOYW1lOlN0cmluZwojIEBhcmcgJDMgdW50aWxJbmNsdXNpdmVQYXRoOlN0cmluZyAob3B0aW9uYWwpIGZpbmQgZm9yIGdpdmVuIGZpbGUgdW50aWwgcmVhY2hpbmcgdGhpcyBmb2xkZXIgKGRlZmF1bHQgdmFsdWU6IC8pCiMgQGFyZyAkQCB1bnRpbEluY2x1c2l2ZVBhdGhzOlN0cmluZ1tdIGxpc3Qgb2YgdW50aWxJbmNsdXNpdmVQYXRoCiMgQHN0ZG91dCBUaGUgZmlsZW5hbWUgaWYgZm91bmQKIyBAZXhpdGNvZGUgMSBpZiB0aGUgY29tbWFuZCBmYWlsZWQgb3IgZmlsZSBub3QgZm91bmQKRmlsZTo6dXBGaW5kKCkgewogIGxvY2FsIGZyb21QYXRoPSIkMSIKICBzaGlmdCB8fCB0cnVlCiAgbG9jYWwgZmlsZU5hbWU9IiQxIgogIHNoaWZ0IHx8IHRydWUKICBsb2NhbCB1bnRpbEluY2x1c2l2ZVBhdGg9IiR7MTotL30iCiAgc2hpZnQgfHwgdHJ1ZQoKICBpZiBbWyAtZiAiJHtmcm9tUGF0aH0iIF1dOyB0aGVuCiAgICBmcm9tUGF0aD0iJHtmcm9tUGF0aCUvKn0iCiAgZmkKICB3aGlsZSB0cnVlOyBkbwogICAgaWYgW1sgLWYgIiR7ZnJvbVBhdGh9LyR7ZmlsZU5hbWV9IiBdXTsgdGhlbgogICAgICBlY2hvICIke2Zyb21QYXRofS8ke2ZpbGVOYW1lfSIKICAgICAgcmV0dXJuIDAKICAgIGZpCiAgICBpZiBBcnJheTo6Y29udGFpbnMgIiR7ZnJvbVBhdGh9IiAiJHt1bnRpbEluY2x1c2l2ZVBhdGh9IiAiJEAiICIvIjsgdGhlbgogICAgICByZXR1cm4gMQogICAgZmkKICAgIGZyb21QYXRoPSIkKHJlYWRsaW5rIC1mICIke2Zyb21QYXRofSIvLi4pIgogIGRvbmUKICByZXR1cm4gMQp9CgoKIyBAZGVzY3JpcHRpb24gY3JlYXRlIGEgdGVtcCBmaWxlIHVzaW5nIGRlZmF1bHQgVE1QRElSIHZhcmlhYmxlCiMgQGVudiBUTVBESVIgU3RyaW5nIChkZWZhdWx0IHZhbHVlIC90bXApCiMgQGFyZyAkMSB0ZW1wbGF0ZU5hbWU6U3RyaW5nIHRlbXBsYXRlIG5hbWUgdG8gdXNlKG9wdGlvbmFsKQpGcmFtZXdvcms6OmNyZWF0ZVRlbXBGaWxlKCkgewogIG1rdGVtcCAtcCAiJHtUTVBESVI6LS90bXB9IiAtdCAiJHsxOi19LlhYWFhYWFhYWFhYWCIKfQoKCiMgQGRlc2NyaXB0aW9uIGVuc3VyZSBjb21tYW5kIHRhciBpcyBhdmFpbGFibGUKIyBAZXhpdGNvZGUgMSBpZiB0YXIgY29tbWFuZCBub3QgYXZhaWxhYmxlCiMgQHN0ZGVyciBkaWFnbm9zdGljcyBpbmZvcm1hdGlvbiBpcyBkaXNwbGF5ZWQKTGludXg6OnJlcXVpcmVUYXJDb21tYW5kKCkgewogIEFzc2VydDo6Y29tbWFuZEV4aXN0cyB0YXIKfQoKCmRlY2xhcmUgLWcgRklSU1RfTE9HX0RBVEUgTE9HX0xBU1RfTE9HX0RBVEUgTE9HX0xBU1RfTE9HX0RBVEVfSU5JVCBMT0dfTEFTVF9EVVJBVElPTl9TVFIKRklSU1RfTE9HX0RBVEU9IiR7RVBPQ0hSRUFMVElNRS9bXjAtOV0vfSIKTE9HX0xBU1RfTE9HX0RBVEU9IiR7RklSU1RfTE9HX0RBVEV9IgpMT0dfTEFTVF9MT0dfREFURV9JTklUPTEKTE9HX0xBU1RfRFVSQVRJT05fU1RSPSIiCgojIEBkZXNjcmlwdGlvbiBjb21wdXRlIGR1cmF0aW9uIHNpbmNlIGxhc3QgY2FsbCB0byB0aGlzIGZ1bmN0aW9uCiMgdGhlIHJlc3VsdCBpcyBzZXQgaW4gZm9sbG93aW5nIGVudiB2YXJpYWJsZXMuCiMgaW4gc3Muc3NzIChzZWNvbmRzIGZvbGxvd2VkIGJ5IG1pbGxpc2Vjb25kcyBwcmVjaXNpb24gMyBkZWNpbWFscykKIyBAbm9hcmdzCiMgQGVudiBESVNQTEFZX0RVUkFUSU9OIGludCAoZGVmYXVsdCAwKSBpZiAxIGRpc3BsYXkgZWxhcHNlZCB0aW1lIGluZm9ybWF0aW9uIGJldHdlZW4gMiBpbmZvIGxvZ3MKIyBAc2V0IExPR19MQVNUX0xPR19EQVRFX0lOSVQgaW50IChkZWZhdWx0IDEpIHNldCB0byAwIGF0IGZpcnN0IGNhbGwsIGFsbG93cyB0byBkZXRlY3QgcmVmZXJlbmNlIGxvZwojIEBzZXQgTE9HX0xBU1RfRFVSQVRJT05fU1RSIFN0cmluZyB0aGUgbGFzdCBkdXJhdGlvbiBkaXNwbGF5ZWQKIyBAc2V0IExPR19MQVNUX0xPR19EQVRFIFN0cmluZyB0aGUgbGFzdCBsb2cgZGF0ZSB0aGF0IHdpbGwgYmUgdXNlZCB0byBjb21wdXRlIG5leHQgZGlmZgpMb2c6OmNvbXB1dGVEdXJhdGlvbigpIHsKICBpZiAoKCR7RElTUExBWV9EVVJBVElPTjotMH0gPT0gMSkpOyB0aGVuCiAgICBsb2NhbCAtaSBkdXJhdGlvbj0wCiAgICBsb2NhbCAtaSBkZWx0YT0wCiAgICBsb2NhbCBkdXJhdGlvblN0ciBkZWx0YVN0cgogICAgbG9jYWwgLWkgY3VycmVudExvZ0RhdGUKICAgIGN1cnJlbnRMb2dEYXRlPSIke0VQT0NIUkVBTFRJTUUvW14wLTldL30iCiAgICBpZiAoKExPR19MQVNUX0xPR19EQVRFX0lOSVQgPT0gMSkpOyB0aGVuCiAgICAgIExPR19MQVNUX0xPR19EQVRFX0lOSVQ9MAogICAgICBMT0dfTEFTVF9EVVJBVElPTl9TVFI9IlJlZiIKICAgIGVsc2UKICAgICAgZHVyYXRpb249JCgoKGN1cnJlbnRMb2dEYXRlIC0gRklSU1RfTE9HX0RBVEUpIC8gMTAwMDAwMCkpCiAgICAgIGRlbHRhPSQoKChjdXJyZW50TG9nRGF0ZSAtIExPR19MQVNUX0xPR19EQVRFKSAvIDEwMDAwMDApKQogICAgICBpZiAoKGR1cmF0aW9uID4gNTkpKTsgdGhlbgogICAgICAgIGR1cmF0aW9uU3RyPSQoZGF0ZSAtdWQgIkAke2R1cmF0aW9ufSIgKyclSDolTTolUycpCiAgICAgIGVsc2UKICAgICAgICBkdXJhdGlvblN0cj0iJHtkdXJhdGlvbn1zIgogICAgICBmaQogICAgICBpZiAoKGRlbHRhID4gNTkpKTsgdGhlbgogICAgICAgIGRlbHRhU3RyPSQoZGF0ZSAtdWQgIkAke2RlbHRhfSIgKyclSDolTTolUycpCiAgICAgIGVsc2UKICAgICAgICBkZWx0YVN0cj0iJHtkZWx0YX1zIgogICAgICBmaQogICAgICBMT0dfTEFTVF9EVVJBVElPTl9TVFI9IiR7ZHVyYXRpb25TdHJ9Lyske2RlbHRhU3RyfSIKICAgIGZpCiAgICBMT0dfTEFTVF9MT0dfREFURT0iJHtjdXJyZW50TG9nRGF0ZX0iCiAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKICAgIGxvY2FsIG1pY3JvU2Vjb25kcz0iJHtFUE9DSFJFQUxUSU1FIyoufSIKICAgIExPR19MQVNUX0RVUkFUSU9OX1NUUj0iJChwcmludGYgJyUoJVQpVC4lMDMuMGZcbicgIiR7RVBPQ0hTRUNPTkRTfSIgIiR7bWljcm9TZWNvbmRzOjA6M30iKSgke0xPR19MQVNUX0RVUkFUSU9OX1NUUn0pIC0gIgogIGVsc2UKICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjAzNAogICAgTE9HX0xBU1RfRFVSQVRJT05fU1RSPSIiCiAgZmkKfQoKCiMgQGRlc2NyaXB0aW9uIERpc3BsYXkgbWVzc2FnZSB1c2luZyBkZWJ1ZyBjb2xvciAoZ3JheSkKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKIyBAZW52IERJU1BMQVlfRFVSQVRJT04gaW50IChkZWZhdWx0IDApIGlmIDEgZGlzcGxheSBlbGFwc2VkIHRpbWUgaW5mb3JtYXRpb24gYmV0d2VlbiAyIGluZm8gbG9ncwojIEBlbnYgTE9HX0NPTlRFWFQgU3RyaW5nIGFsbG93cyB0byBjb250ZXh0dWFsaXplIHRoZSBsb2cKTG9nOjpkaXNwbGF5RGVidWcoKSB7CiAgaWYgKChCQVNIX0ZSQU1FV09SS19ESVNQTEFZX0xFVkVMID49IF9fTEVWRUxfREVCVUcpKTsgdGhlbgogICAgTG9nOjpjb21wdXRlRHVyYXRpb24KICAgIGVjaG8gLWUgIiR7X19ERUJVR19DT0xPUn1ERUJVRyAgIC0gJHtMT0dfQ09OVEVYVDotfSR7TE9HX0xBU1RfRFVSQVRJT05fU1RSOi19JHsxfSR7X19SRVNFVF9DT0xPUn0iID4mMgogIGZpCiAgTG9nOjpsb2dEZWJ1ZyAiJDEiCn0KCgojIEBkZXNjcmlwdGlvbiBEaXNwbGF5IG1lc3NhZ2UgdXNpbmcgZXJyb3IgY29sb3IgKHJlZCkKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKIyBAZW52IERJU1BMQVlfRFVSQVRJT04gaW50IChkZWZhdWx0IDApIGlmIDEgZGlzcGxheSBlbGFwc2VkIHRpbWUgaW5mb3JtYXRpb24gYmV0d2VlbiAyIGluZm8gbG9ncwojIEBlbnYgTE9HX0NPTlRFWFQgU3RyaW5nIGFsbG93cyB0byBjb250ZXh0dWFsaXplIHRoZSBsb2cKTG9nOjpkaXNwbGF5RXJyb3IoKSB7CiAgaWYgKChCQVNIX0ZSQU1FV09SS19ESVNQTEFZX0xFVkVMID49IF9fTEVWRUxfRVJST1IpKTsgdGhlbgogICAgTG9nOjpjb21wdXRlRHVyYXRpb24KICAgIGVjaG8gLWUgIiR7X19FUlJPUl9DT0xPUn1FUlJPUiAgIC0gJHtMT0dfQ09OVEVYVDotfSR7TE9HX0xBU1RfRFVSQVRJT05fU1RSOi19JHsxfSR7X19SRVNFVF9DT0xPUn0iID4mMgogIGZpCiAgTG9nOjpsb2dFcnJvciAiJDEiCn0KCgojIEBkZXNjcmlwdGlvbiBEaXNwbGF5IG1lc3NhZ2UgdXNpbmcgaW5mbyBjb2xvciAoYmcgbGlnaHQgYmx1ZS9mZyB3aGl0ZSkKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKIyBAZW52IERJU1BMQVlfRFVSQVRJT04gaW50IChkZWZhdWx0IDApIGlmIDEgZGlzcGxheSBlbGFwc2VkIHRpbWUgaW5mb3JtYXRpb24gYmV0d2VlbiAyIGluZm8gbG9ncwojIEBlbnYgTE9HX0NPTlRFWFQgU3RyaW5nIGFsbG93cyB0byBjb250ZXh0dWFsaXplIHRoZSBsb2cKTG9nOjpkaXNwbGF5SW5mbygpIHsKICBsb2NhbCB0eXBlPSIkezI6LUlORk99IgogIGlmICgoQkFTSF9GUkFNRVdPUktfRElTUExBWV9MRVZFTCA+PSBfX0xFVkVMX0lORk8pKTsgdGhlbgogICAgTG9nOjpjb21wdXRlRHVyYXRpb24KICAgIGVjaG8gLWUgIiR7X19JTkZPX0NPTE9SfSR7dHlwZX0gICAgLSAke0xPR19DT05URVhUOi19JHtMT0dfTEFTVF9EVVJBVElPTl9TVFI6LX0kezF9JHtfX1JFU0VUX0NPTE9SfSIgPiYyCiAgZmkKICBMb2c6OmxvZ0luZm8gIiQxIiAiJHt0eXBlfSIKfQoKCiMgQGRlc2NyaXB0aW9uIERpc3BsYXkgbWVzc2FnZSB1c2luZyBlcnJvciBjb2xvciAocmVkKSBhbmQgZXhpdCBpbW1lZGlhdGVseSB3aXRoIGVycm9yIHN0YXR1cyAxCiMgQGFyZyAkMSBtZXNzYWdlOlN0cmluZyB0aGUgbWVzc2FnZSB0byBkaXNwbGF5CiMgQGVudiBESVNQTEFZX0RVUkFUSU9OIGludCAoZGVmYXVsdCAwKSBpZiAxIGRpc3BsYXkgZWxhcHNlZCB0aW1lIGluZm9ybWF0aW9uIGJldHdlZW4gMiBpbmZvIGxvZ3MKIyBAZW52IExPR19DT05URVhUIFN0cmluZyBhbGxvd3MgdG8gY29udGV4dHVhbGl6ZSB0aGUgbG9nCkxvZzo6ZmF0YWwoKSB7CiAgTG9nOjpjb21wdXRlRHVyYXRpb24KICBlY2hvIC1lICIke19fRVJST1JfQ09MT1J9RkFUQUwgICAtICR7TE9HX0NPTlRFWFQ6LX0ke0xPR19MQVNUX0RVUkFUSU9OX1NUUjotfSR7MX0ke19fUkVTRVRfQ09MT1J9IiA+JjIKICBMb2c6OmxvZ0ZhdGFsICIkMSIKICBleGl0IDEKfQoKCiMgQGRlc2NyaXB0aW9uIGxvZyBtZXNzYWdlIHRvIGZpbGUKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpsb2dEZWJ1ZygpIHsKICBpZiAoKEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCA+PSBfX0xFVkVMX0RFQlVHKSk7IHRoZW4KICAgIExvZzo6bG9nTWVzc2FnZSAiJHsyOi1ERUJVR30iICIkMSIKICBmaQp9CgoKIyBAZGVzY3JpcHRpb24gbG9nIG1lc3NhZ2UgdG8gZmlsZQojIEBhcmcgJDEgbWVzc2FnZTpTdHJpbmcgdGhlIG1lc3NhZ2UgdG8gZGlzcGxheQpMb2c6OmxvZ0Vycm9yKCkgewogIGlmICgoQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMID49IF9fTEVWRUxfRVJST1IpKTsgdGhlbgogICAgTG9nOjpsb2dNZXNzYWdlICIkezI6LUVSUk9SfSIgIiQxIgogIGZpCn0KCgojIEBkZXNjcmlwdGlvbiBsb2cgbWVzc2FnZSB0byBmaWxlCiMgQGFyZyAkMSBtZXNzYWdlOlN0cmluZyB0aGUgbWVzc2FnZSB0byBkaXNwbGF5CkxvZzo6bG9nRmF0YWwoKSB7CiAgTG9nOjpsb2dNZXNzYWdlICIkezI6LUZBVEFMfSIgIiQxIgp9CgoKIyBAZGVzY3JpcHRpb24gbG9nIG1lc3NhZ2UgdG8gZmlsZQojIEBhcmcgJDEgbWVzc2FnZTpTdHJpbmcgdGhlIG1lc3NhZ2UgdG8gZGlzcGxheQpMb2c6OmxvZ0luZm8oKSB7CiAgaWYgKChCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwgPj0gX19MRVZFTF9JTkZPKSk7IHRoZW4KICAgIExvZzo6bG9nTWVzc2FnZSAiJHsyOi1JTkZPfSIgIiQxIgogIGZpCn0KCgojIEBkZXNjcmlwdGlvbiBJbnRlcm5hbDogY29tbW9uIGxvZyBtZXNzYWdlCiMgQGV4YW1wbGUgdGV4dAojICAgW2RhdGVdfFtsZXZlbE1zZ118bWVzc2FnZQojCiMgQGV4YW1wbGUgdGV4dAojICAgMjAyMC0wMS0xOSAxOToyMDoyMXxFUlJPUiAgfGxvZyBlcnJvcgojICAgMjAyMC0wMS0xOSAxOToyMDoyMXxTS0lQUEVEfGxvZyBza2lwcGVkCiMKIyBAYXJnICQxIGxldmVsTXNnOlN0cmluZyBtZXNzYWdlJ3MgbGV2ZWwgZGVzY3JpcHRpb24gKGVnOiBTVEFUVVMsIEVSUk9SLCAuLi4pCiMgQGFyZyAkMiBtc2c6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKIyBAZW52IEJBU0hfRlJBTUVXT1JLX0xPR19GSUxFIFN0cmluZyBsb2cgZmlsZSB0byB1c2UsIGRvIG5vdGhpbmcgaWYgZW1wdHkKIyBAZW52IEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCBpbnQgbG9nIGxldmVsIGxvZyBvbmx5IGlmID4gT0ZGIG9yIGZhdGFsIG1lc3NhZ2VzCiMgQHN0ZGVyciBkaWFnbm9zdGljcyBpbmZvcm1hdGlvbiBpcyBkaXNwbGF5ZWQKTG9nOjpsb2dNZXNzYWdlKCkgewoKICBpZiBbWyAiJHtSRVFVSVJFX0ZVTkNUSU9OX0VOVl9SRVFVSVJFX0xPQURfTE9BREVEOi0wfSIgIT0gMSBdXTsgdGhlbgogICAgZWNobyA+JjIgIlJlcXVpcmVtZW50IEVudjo6cmVxdWlyZUxvYWQgaGFzIG5vdCBiZWVuIGxvYWRlZCIKICAgIGV4aXQgMQogIGZpCgogIGlmIFtbICIke1JFUVVJUkVfRlVOQ1RJT05fTE9HX1JFUVVJUkVfTE9BRF9MT0FERUQ6LTB9IiAhPSAxIF1dOyB0aGVuCiAgICBlY2hvID4mMiAiUmVxdWlyZW1lbnQgTG9nOjpyZXF1aXJlTG9hZCBoYXMgbm90IGJlZW4gbG9hZGVkIgogICAgZXhpdCAxCiAgZmkKCiAgbG9jYWwgbGV2ZWxNc2c9IiQxIgogIGxvY2FsIG1zZz0iJDIiCiAgbG9jYWwgZGF0ZQoKICBpZiBbWyAtbiAiJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRX0iIF1dICYmICgoQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMID4gX19MRVZFTF9PRkYpKTsgdGhlbgogICAgZGF0ZT0iJChkYXRlICcrJVktJW0tJWQgJUg6JU06JVMnKSIKICAgIHRvdWNoICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFfSIKICAgIHByaW50ZiAiJXN8JTdzfCVzXG4iICIke2RhdGV9IiAiJHtsZXZlbE1zZ30iICIke21zZ30iID4+IiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IgogIGZpCn0KCgojIEBkZXNjcmlwdGlvbiBhY3RpdmF0ZSBvciBub3QgTG9nOjpkaXNwbGF5KiBhbmQgTG9nOjpsb2cqIGZ1bmN0aW9ucwojIGJhc2VkIG9uIEJBU0hfRlJBTUVXT1JLX0RJU1BMQVlfTEVWRUwgYW5kIEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTAojIGVudmlyb25tZW50IHZhcmlhYmxlcyBsb2FkZWQgYnkgRW52OjpyZXF1aXJlTG9hZAojIHRyeSB0byBjcmVhdGUgbG9nIGZpbGUgYW5kIHJvdGF0ZSBpdCBpZiBuZWNlc3NhcnkKIyBAbm9hcmdzCiMgQHNldCBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwgaW50IHRvIE9GRiBsZXZlbCBpZiBCQVNIX0ZSQU1FV09SS19MT0dfRklMRSBpcyBlbXB0eSBvciBub3Qgd3JpdGFibGUKIyBAZW52IEJBU0hfRlJBTUVXT1JLX0RJU1BMQVlfTEVWRUwgaW50CiMgQGVudiBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwgaW50CiMgQGVudiBCQVNIX0ZSQU1FV09SS19MT0dfRklMRSBTdHJpbmcKIyBAZW52IEJBU0hfRlJBTUVXT1JLX0xPR19GSUxFX01BWF9ST1RBVElPTiBpbnQgZG8gbG9nIHJvdGF0aW9uIGlmID4gMAojIEBleGl0Y29kZSAwIGFsd2F5cyBzdWNjZXNzZnVsCiMgQHN0ZGVyciBkaWFnbm9zdGljcyBpbmZvcm1hdGlvbiBhYm91dCBsb2cgZmlsZSBpcyBkaXNwbGF5ZWQKTG9nOjpyZXF1aXJlTG9hZCgpIHsKICBleHBvcnQgUkVRVUlSRV9GVU5DVElPTl9MT0dfUkVRVUlSRV9MT0FEX0xPQURFRD0xCgoKICBpZiBbWyAiJHtSRVFVSVJFX0ZVTkNUSU9OX0VOVl9SRVFVSVJFX0xPQURfTE9BREVEOi0wfSIgIT0gMSBdXTsgdGhlbgogICAgZWNobyA+JjIgIlJlcXVpcmVtZW50IEVudjo6cmVxdWlyZUxvYWQgaGFzIG5vdCBiZWVuIGxvYWRlZCIKICAgIGV4aXQgMQogIGZpCgogIGlmIFtbICIke1JFUVVJUkVfRlVOQ1RJT05fVUlfUkVRVUlSRV9USEVNRV9MT0FERUQ6LTB9IiAhPSAxIF1dOyB0aGVuCiAgICBlY2hvID4mMiAiUmVxdWlyZW1lbnQgVUk6OnJlcXVpcmVUaGVtZSBoYXMgbm90IGJlZW4gbG9hZGVkIgogICAgZXhpdCAxCiAgZmkKCiAgaWYgW1sgLXogIiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEU6LX0iIF1dOyB0aGVuCiAgICBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUw9JHtfX0xFVkVMX09GRn0KICAgIGV4cG9ydCBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwKICBmaQoKICBpZiAoKEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCA+IF9fTEVWRUxfT0ZGKSk7IHRoZW4KICAgIGlmIFtbICEgLWYgIiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IiBdXTsgdGhlbgogICAgICBpZiBbWyAhIC1kICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFJS8qfSIgXV07IHRoZW4KICAgICAgICBpZiAhIG1rZGlyIC1wICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFJS8qfSIgMj4vZGV2L251bGw7IHRoZW4KICAgICAgICAgIEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTD0ke19fTEVWRUxfT0ZGfQogICAgICAgICAgZWNobyAtZSAiJHtfX0VSUk9SX0NPTE9SfUVSUk9SICAgLSBkaXJlY3RvcnkgJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRSUvKn0gaXMgbm90IHdyaXRhYmxlJHtfX1JFU0VUX0NPTE9SfSIgPiYyCiAgICAgICAgZmkKICAgICAgZWxpZiAhIHRvdWNoIC0tbm8tY3JlYXRlICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFfSIgMj4vZGV2L251bGw7IHRoZW4KICAgICAgICBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUw9JHtfX0xFVkVMX09GRn0KICAgICAgICBlY2hvIC1lICIke19fRVJST1JfQ09MT1J9RVJST1IgICAtIEZpbGUgJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRX0gaXMgbm90IHdyaXRhYmxlJHtfX1JFU0VUX0NPTE9SfSIgPiYyCiAgICAgIGZpCiAgICBlbGlmIFtbICEgLXcgIiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IiBdXTsgdGhlbgogICAgICBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUw9JHtfX0xFVkVMX09GRn0KICAgICAgZWNobyAtZSAiJHtfX0VSUk9SX0NPTE9SfUVSUk9SICAgLSBGaWxlICR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IGlzIG5vdCB3cml0YWJsZSR7X19SRVNFVF9DT0xPUn0iID4mMgogICAgZmkKICBmaQoKICBpZiAoKEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCA+IF9fTEVWRUxfT0ZGKSk7IHRoZW4KICAgICMgd2lsbCBhbHdheXMgYmUgY3JlYXRlZCBldmVuIGlmIG5vdCBpbiBpbmZvIGxldmVsCiAgICBMb2c6OmxvZ01lc3NhZ2UgIklORk8iICJMb2dnaW5nIHRvIGZpbGUgJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRX0gLSBMb2cgbGV2ZWwgJHtCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUx9IgogICAgaWYgKChCQVNIX0ZSQU1FV09SS19MT0dfRklMRV9NQVhfUk9UQVRJT04gPiAwKSk7IHRoZW4KICAgICAgTG9nOjpyb3RhdGUgIiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IiAiJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRV9NQVhfUk9UQVRJT059IgogICAgZmkKICBmaQp9CgoKIyBAZGVzY3JpcHRpb24gVG8gYmUgY2FsbGVkIGJlZm9yZSBsb2dnaW5nIGluIHRoZSBsb2cgZmlsZQojIEBhcmcgJDEgZmlsZTpzdHJpbmcgbG9nIGZpbGUgbmFtZQojIEBhcmcgJDIgbWF4TG9nRmlsZXNDb3VudDppbnQgbWF4aW11bSBudW1iZXIgb2YgbG9nIGZpbGVzCkxvZzo6cm90YXRlKCkgewogIGxvY2FsIGZpbGU9IiQxIgogIGxvY2FsIG1heExvZ0ZpbGVzQ291bnQ9IiR7MjotNX0iCgogIGlmIFtbICEgLWYgIiR7ZmlsZX0iIF1dOyB0aGVuCiAgICBMb2c6OmRpc3BsYXlEZWJ1ZyAiTG9nIGZpbGUgJHtmaWxlfSBkb2Vzbid0IGV4aXN0IHlldCIKICAgIHJldHVybiAwCiAgZmkKICBsb2NhbCBpCiAgZm9yICgoaSA9IG1heExvZ0ZpbGVzQ291bnQgLSAxOyBpID4gMDsgaS0tKSk7IGRvCiAgICBMb2c6OmRpc3BsYXlJbmZvICJMb2cgcm90YXRpb24gJHtmaWxlfS4ke2l9IHRvICR7ZmlsZX0uJCgoaSArIDEpKSIKICAgIG12ICIke2ZpbGV9LiJ7IiR7aX0iLCIkKChpICsgMSkpIn0gJj4vZGV2L251bGwgfHwgdHJ1ZQogIGRvbmUKICBpZiBjcCAiJHtmaWxlfSIgIiR7ZmlsZX0uMSIgJj4vZGV2L251bGw7IHRoZW4KICAgIGVjaG8gPiIke2ZpbGV9IiAjIHJlc2V0IGxvZyBmaWxlCiAgICBMb2c6OmRpc3BsYXlJbmZvICJMb2cgcm90YXRpb24gJHtmaWxlfSB0byAke2ZpbGV9LjEiCiAgZmkKfQoKCiMgQGRlc2NyaXB0aW9uIGxvYWQgY29sb3IgdGhlbWUKIyBAbm9hcmdzCiMgQGVudiBCQVNIX0ZSQU1FV09SS19USEVNRSBTdHJpbmcgdGhlbWUgdG8gdXNlCiMgQGVudiBMT0FEX1RIRU1FIGludCAwIHRvIGF2b2lkIGxvYWRpbmcgdGhlbWUKIyBAZXhpdGNvZGUgMCBhbHdheXMgc3VjY2Vzc2Z1bApVSTo6cmVxdWlyZVRoZW1lKCkgewogIGV4cG9ydCBSRVFVSVJFX0ZVTkNUSU9OX1VJX1JFUVVJUkVfVEhFTUVfTE9BREVEPTEKCiAgaWYgW1sgIiR7TE9BRF9USEVNRTotMX0iID0gIjEiIF1dOyB0aGVuCiAgICBVSTo6dGhlbWUgIiR7QkFTSF9GUkFNRVdPUktfVEhFTUUtZGVmYXVsdH0iCiAgZmkKfQoKCiMgQGRlc2NyaXB0aW9uIGxvYWQgY29sb3JzIHRoZW1lIGNvbnN0YW50cwojIEB3YXJuaW5nIGlmIHR0eSBub3Qgb3BlbmVkLCBub0NvbG9yIHRoZW1lIHdpbGwgYmUgY2hvc2VuCiMgQGFyZyAkMSB0aGVtZTpTdHJpbmcgdGhlIHRoZW1lIHRvIHVzZSAoZGVmYXVsdCwgbm9Db2xvcikKIyBAYXJnICRAIGFyZ3M6U3RyaW5nW10KIyBAc2V0IF9fRVJST1JfQ09MT1IgU3RyaW5nIGluZGljYXRlIGVycm9yIHN0YXR1cwojIEBzZXQgX19JTkZPX0NPTE9SIFN0cmluZyBpbmRpY2F0ZSBpbmZvIHN0YXR1cwojIEBzZXQgX19TVUNDRVNTX0NPTE9SIFN0cmluZyBpbmRpY2F0ZSBzdWNjZXNzIHN0YXR1cwojIEBzZXQgX19XQVJOSU5HX0NPTE9SIFN0cmluZyBpbmRpY2F0ZSB3YXJuaW5nIHN0YXR1cwojIEBzZXQgX19TS0lQUEVEX0NPTE9SIFN0cmluZyBpbmRpY2F0ZSBza2lwcGVkIHN0YXR1cwojIEBzZXQgX19ERUJVR19DT0xPUiBTdHJpbmcgaW5kaWNhdGUgZGVidWcgc3RhdHVzCiMgQHNldCBfX0hFTFBfQ09MT1IgU3RyaW5nIGluZGljYXRlIGhlbHAgc3RhdHVzCiMgQHNldCBfX1RFU1RfQ09MT1IgU3RyaW5nIG5vdCB1c2VkCiMgQHNldCBfX1RFU1RfRVJST1JfQ09MT1IgU3RyaW5nIG5vdCB1c2VkCiMgQHNldCBfX0hFTFBfVElUTEVfQ09MT1IgU3RyaW5nIHVzZWQgdG8gZGlzcGxheSBoZWxwIHRpdGxlIGluIGhlbHAgc3RyaW5ncwojIEBzZXQgX19IRUxQX09QVElPTl9DT0xPUiBTdHJpbmcgdXNlZCB0byBkaXNwbGF5IGhpZ2hsaWdodCBvcHRpb25zIGluIGhlbHAgc3RyaW5ncwojCiMgQHNldCBfX1JFU0VUX0NPTE9SIFN0cmluZyByZXNldCBkZWZhdWx0IGNvbG9yCiMKIyBAc2V0IF9fSEVMUF9FWEFNUExFIFN0cmluZyB0byByZW1vdmUKIyBAc2V0IF9fSEVMUF9USVRMRSBTdHJpbmcgdG8gcmVtb3ZlCiMgQHNldCBfX0hFTFBfTk9STUFMIFN0cmluZyB0byByZW1vdmUKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0ClVJOjp0aGVtZSgpIHsKICBsb2NhbCB0aGVtZT0iJHsxLWRlZmF1bHR9IgogIGlmIFtbICEgIiR7dGhlbWV9IiA9fiAtZm9yY2UkIF1dICYmICEgQXNzZXJ0Ojp0dHk7IHRoZW4KICAgIHRoZW1lPSJub0NvbG9yIgogIGZpCiAgY2FzZSAiJHt0aGVtZX0iIGluCiAgICBkZWZhdWx0IHwgZGVmYXVsdC1mb3JjZSkKICAgICAgdGhlbWU9ImRlZmF1bHQiCiAgICAgIDs7CiAgICBub0NvbG9yKSA7OwogICAgKikKICAgICAgTG9nOjpmYXRhbCAiaW52YWxpZCB0aGVtZSBwcm92aWRlZCIKICAgICAgOzsKICBlc2FjCiAgaWYgW1sgIiR7dGhlbWV9IiA9ICJkZWZhdWx0IiBdXTsgdGhlbgogICAgQkFTSF9GUkFNRVdPUktfVEhFTUU9ImRlZmF1bHQiCiAgICAjIGNoZWNrIGNvbG9ycyBhcHBsaWNhYmxlIGh0dHBzOi8vbWlzYy5mbG9naXNvZnQuY29tL2Jhc2gvdGlwX2NvbG9yc19hbmRfZm9ybWF0dGluZwogICAgX19FUlJPUl9DT0xPUj0nXGVbMzFtJyAgICAgICAgICMgUmVkCiAgICBfX0lORk9fQ09MT1I9J1xlWzQ0bScgICAgICAgICAgIyB3aGl0ZSBvbiBsaWdodEJsdWUKICAgIF9fU1VDQ0VTU19DT0xPUj0nXGVbMzJtJyAgICAgICAjIEdyZWVuCiAgICBfX1dBUk5JTkdfQ09MT1I9J1xlWzMzbScgICAgICAgIyBZZWxsb3cKICAgIF9fU0tJUFBFRF9DT0xPUj0nXGVbMzNtJyAgICAgICAjIFllbGxvdwogICAgX19ERUJVR19DT0xPUj0nXGVbMzdtJyAgICAgICAgICMgR3JheQogICAgX19IRUxQX0NPTE9SPSdcZVs3OzQ5OzMzbScgICAgICMgQmxhY2sgb24gR29sZAogICAgX19URVNUX0NPTE9SPSdcZVsxMDBtJyAgICAgICAgICMgTGlnaHQgbWFnZW50YQogICAgX19URVNUX0VSUk9SX0NPTE9SPSdcZVs0MW0nICAgICMgd2hpdGUgb24gcmVkCiAgICBfX0hFTFBfVElUTEVfQ09MT1I9IlxlWzE7MzdtIiAgIyBCb2xkCiAgICBfX0hFTFBfT1BUSU9OX0NPTE9SPSJcZVsxOzM0bSIgIyBCbHVlCiAgICAjIEludGVybmFsOiByZXNldCBjb2xvcgogICAgX19SRVNFVF9DT0xPUj0nXGVbMG0nICMgUmVzZXQgQ29sb3IKICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjE1NSxTQzIwMzQKICAgIF9fSEVMUF9FWEFNUExFPSIkKGVjaG8gLWUgIlxlWzI7OTdtIikiCiAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIxNTUsU0MyMDM0CiAgICBfX0hFTFBfVElUTEU9IiQoZWNobyAtZSAiXGVbMTszN20iKSIKICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjE1NSxTQzIwMzQKICAgIF9fSEVMUF9OT1JNQUw9IiQoZWNobyAtZSAiXDAzM1swbSIpIgogIGVsc2UKICAgIEJBU0hfRlJBTUVXT1JLX1RIRU1FPSJub0NvbG9yIgogICAgIyBjaGVjayBjb2xvcnMgYXBwbGljYWJsZSBodHRwczovL21pc2MuZmxvZ2lzb2Z0LmNvbS9iYXNoL3RpcF9jb2xvcnNfYW5kX2Zvcm1hdHRpbmcKICAgIF9fRVJST1JfQ09MT1I9JycKICAgIF9fSU5GT19DT0xPUj0nJwogICAgX19TVUNDRVNTX0NPTE9SPScnCiAgICBfX1dBUk5JTkdfQ09MT1I9JycKICAgIF9fU0tJUFBFRF9DT0xPUj0nJwogICAgX19ERUJVR19DT0xPUj0nJwogICAgX19IRUxQX0NPTE9SPScnCiAgICBfX1RFU1RfQ09MT1I9JycKICAgIF9fVEVTVF9FUlJPUl9DT0xPUj0nJwogICAgX19IRUxQX1RJVExFX0NPTE9SPScnCiAgICBfX0hFTFBfT1BUSU9OX0NPTE9SPScnCiAgICAjIEludGVybmFsOiByZXNldCBjb2xvcgogICAgX19SRVNFVF9DT0xPUj0nJwogICAgX19IRUxQX0VYQU1QTEU9JycKICAgIF9fSEVMUF9USVRMRT0nJwogICAgX19IRUxQX05PUk1BTD0nJwogIGZpCn0KIyBGVU5DVElPTlMKCm9wdGlvbkhlbHBDYWxsYmFjaygpIHsKICAic2ltcGxlQ29tbWFuZEhlbHAiCiAgZXhpdCAwCn0KCmNvcHlyaWdodENhbGxiYWNrKCkgewogICMKICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIxNTUsU0MyMTU0LFNDMjI1MAogIGVjaG8gIkNvcHlyaWdodCAoYykgMjAyNC1ub3cgRnJhbmNvaXMgQ2hhc3RhbmV0Igp9CgpFbnY6OnJlcXVpcmVMb2FkKCkgewogIGV4cG9ydCBSRVFVSVJFX0ZVTkNUSU9OX0VOVl9SRVFVSVJFX0xPQURfTE9BREVEPTEKfQoKVUk6OnJlcXVpcmVUaGVtZSgpIHsKICBleHBvcnQgUkVRVUlSRV9GVU5DVElPTl9VSV9SRVFVSVJFX1RIRU1FX0xPQURFRD0xCn0KCkxvZzo6cmVxdWlyZUxvYWQoKSB7CiAgZXhwb3J0IFJFUVVJUkVfRlVOQ1RJT05fTE9HX1JFUVVJUkVfTE9BRF9MT0FERUQ9MQp9CgpkZWZhdWx0QmVmb3JlUGFyc2VDYWxsYmFjaygpIHsKICBFbnY6OnJlcXVpcmVMb2FkCiAgVUk6OnJlcXVpcmVUaGVtZQogIExvZzo6cmVxdWlyZUxvYWQKfQoKYmVmb3JlUGFyc2VDYWxsYmFjaygpIHsKICBkZWZhdWx0QmVmb3JlUGFyc2VDYWxsYmFjawp9CgpkZWZhdWx0QWZ0ZXJQYXJzZUNhbGxiYWNrKCkgewogIDoKfQoKYWZ0ZXJQYXJzZUNhbGxiYWNrKCkgewogIGRlZmF1bHRBZnRlclBhcnNlQ2FsbGJhY2sKfQoKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMzE3ICMgaWYgZnVuY3Rpb24gaXMgb3ZlcnJpZGRlbgpvcHRpb25WZXJzaW9uQ2FsbGJhY2soKSB7CiAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMTU0CiAgZWNobyAiJHtTQ1JJUFRfTkFNRX0gdmVyc2lvbiAzLjAiCiAgZXhpdCAwCn0KCgojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQojIENvbW1hbmQgc2ltcGxlQ29tbWFuZAojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyBvcHRpb25zIHZhcmlhYmxlcyBpbml0aWFsaXphdGlvbgpkZWNsYXJlIG9wdGlvbkhlbHA9IjAiCmRlY2xhcmUgb3B0aW9uVmVyc2lvbj0iMCIKIyBhcmd1bWVudHMgdmFyaWFibGVzIGluaXRpYWxpemF0aW9uCmRlY2xhcmUgZGlyZWN0b3J5PSIiCmRlY2xhcmUgLWEgZXh0ZW5zaW9ucz0oKQojIEBkZXNjcmlwdGlvbiBwYXJzZSBjb21tYW5kIG9wdGlvbnMgYW5kIGFyZ3VtZW50cyBmb3Igc2ltcGxlQ29tbWFuZApzaW1wbGVDb21tYW5kUGFyc2UoKSB7CiAgTG9nOjpkaXNwbGF5RGVidWcgIkNvbW1hbmQgJHtTQ1JJUFRfTkFNRX0gLSBwYXJzZSBhcmd1bWVudHM6ICR7QkFTSF9GUkFNRVdPUktfQVJHVlsqXX0iCiAgTG9nOjpkaXNwbGF5RGVidWcgIkNvbW1hbmQgJHtTQ1JJUFRfTkFNRX0gLSBwYXJzZSBmaWx0ZXJlZCBhcmd1bWVudHM6ICR7QkFTSF9GUkFNRVdPUktfQVJHVl9GSUxURVJFRFsqXX0iCiAgb3B0aW9uSGVscD0iMCIKICBsb2NhbCAtaSBvcHRpb25zX3BhcnNlX29wdGlvblBhcnNlZENvdW50T3B0aW9uSGVscAogICgob3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvbkhlbHAgPSAwKSkgfHwgdHJ1ZQogIG9wdGlvblZlcnNpb249IjAiCiAgbG9jYWwgLWkgb3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvblZlcnNpb24KICAoKG9wdGlvbnNfcGFyc2Vfb3B0aW9uUGFyc2VkQ291bnRPcHRpb25WZXJzaW9uID0gMCkpIHx8IHRydWUKCiAgZGlyZWN0b3J5PSIiCgogIGxvY2FsIC1pIG9wdGlvbnNfcGFyc2VfYXJnUGFyc2VkQ291bnREaXJlY3RvcnkKICAoKG9wdGlvbnNfcGFyc2VfYXJnUGFyc2VkQ291bnREaXJlY3RvcnkgPSAwKSkgfHwgdHJ1ZQoKICBleHRlbnNpb25zPSgpCiAgbG9jYWwgLWkgb3B0aW9uc19wYXJzZV9hcmdQYXJzZWRDb3VudEV4dGVuc2lvbnMKICAoKG9wdGlvbnNfcGFyc2VfYXJnUGFyc2VkQ291bnRFeHRlbnNpb25zID0gMCkpIHx8IHRydWUKCgogICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjAzNAogIGxvY2FsIC1pIG9wdGlvbnNfcGFyc2VfcGFyc2VkQXJnSW5kZXg9MAogIHdoaWxlICgoJCMgPiAwKSk7IGRvCiAgICBsb2NhbCBvcHRpb25zX3BhcnNlX2FyZz0iJDEiCiAgICBsb2NhbCBhcmdPcHREZWZhdWx0QmVoYXZpb3I9MAogICAgY2FzZSAiJHtvcHRpb25zX3BhcnNlX2FyZ30iIGluCiAgICAgICMgT3B0aW9uIDEvMgogICAgICAjIG9wdGlvbkhlbHAgYWx0cyAtLWhlbHB8LWgKICAgICAgIyB0eXBlOiBCb29sZWFuIG1pbiAwIG1heCAxCiAgICAgIC0taGVscCB8IC1oKQogICAgICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjAzNAogICAgICAgIG9wdGlvbkhlbHA9IjEiCgogICAgICAgIGlmICgob3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvbkhlbHAgPj0gMSApKTsgdGhlbgogICAgICAgICAgTG9nOjpkaXNwbGF5RXJyb3IgIkNvbW1hbmQgJHtTQ1JJUFRfTkFNRX0gLSBPcHRpb24gJHtvcHRpb25zX3BhcnNlX2FyZ30gLSBNYXhpbXVtIG51bWJlciBvZiBvcHRpb24gb2NjdXJyZW5jZXMgcmVhY2hlZCgxKSIKICAgICAgICAgIHJldHVybiAxCiAgICAgICAgZmkKICAgICAgICAoKCsrb3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvbkhlbHApKQogICAgICAgIG9wdGlvbkhlbHBDYWxsYmFjayAiJHtvcHRpb25zX3BhcnNlX2FyZ30iICIke29wdGlvbkhlbHB9IgoKICAgICAgICA7OwoKICAgICAgIyBPcHRpb24gMi8yCiAgICAgICMgb3B0aW9uVmVyc2lvbiBhbHRzIC0tdmVyc2lvbgogICAgICAjIHR5cGU6IEJvb2xlYW4gbWluIDAgbWF4IDEKICAgICAgLS12ZXJzaW9uKQogICAgICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjAzNAogICAgICAgIG9wdGlvblZlcnNpb249IjEiCgogICAgICAgIGlmICgob3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvblZlcnNpb24gPj0gMSApKTsgdGhlbgogICAgICAgICAgTG9nOjpkaXNwbGF5RXJyb3IgIkNvbW1hbmQgJHtTQ1JJUFRfTkFNRX0gLSBPcHRpb24gJHtvcHRpb25zX3BhcnNlX2FyZ30gLSBNYXhpbXVtIG51bWJlciBvZiBvcHRpb24gb2NjdXJyZW5jZXMgcmVhY2hlZCgxKSIKICAgICAgICAgIHJldHVybiAxCiAgICAgICAgZmkKICAgICAgICAoKCsrb3B0aW9uc19wYXJzZV9vcHRpb25QYXJzZWRDb3VudE9wdGlvblZlcnNpb24pKQogICAgICAgIG9wdGlvblZlcnNpb25DYWxsYmFjayAiJHtvcHRpb25zX3BhcnNlX2FyZ30iICIke29wdGlvblZlcnNpb259IgoKICAgICAgICA7OwoKICAgICAgLSopCiAgICAgICAgaWYgW1sgIiR7YXJnT3B0RGVmYXVsdEJlaGF2aW9yfSIgPSAiMCIgXV07IHRoZW4KICAgICAgICAgIExvZzo6ZGlzcGxheUVycm9yICJDb21tYW5kICR7U0NSSVBUX05BTUV9IC0gSW52YWxpZCBvcHRpb24gJHtvcHRpb25zX3BhcnNlX2FyZ30iCiAgICAgICAgICByZXR1cm4gMQogICAgICAgIGZpCiAgICAgICAgOzsKICAgICAgKikKICAgICAgICAoKG1pblBhcnNlZEFyZ0luZGV4MCA9IDApKSB8fCB0cnVlCiAgICAgICAgKChtYXhQYXJzZWRBcmdJbmRleDAgPSAwKSkgfHwgdHJ1ZQogICAgICAgICgobWluUGFyc2VkQXJnSW5kZXgxID0gbWluUGFyc2VkQXJnSW5kZXgwICsgMSkpIHx8IHRydWUKICAgICAgICAoKG1heFBhcnNlZEFyZ0luZGV4MSA9IG1heFBhcnNlZEFyZ0luZGV4MCArIDEpKSB8fCB0cnVlCiAgICAgICAgKChtaW5QYXJzZWRBcmdJbmRleDIgPSBtaW5QYXJzZWRBcmdJbmRleDEgKyAxKSkgfHwgdHJ1ZQogICAgICAgICgobWF4UGFyc2VkQXJnSW5kZXgyID0gbWF4UGFyc2VkQXJnSW5kZXgxKSkgfHwgdHJ1ZQogICAgICAgICgoaW5jcmVtZW50QXJnID0gMSApKQogICAgICAgIGlmICgoMCkpOyB0aGVuCiAgICAgICAgICAjIFRlY2huaWNhbCBpZiAtIG5ldmVyIHJlYWNoZWQKICAgICAgICAgIDoKCiAgICAgICAgIyBBcmd1bWVudCAxLzIgLSBkaXJlY3RvcnkKICAgICAgICAjIEFyZ3VtZW50IGRpcmVjdG9yeSBtaW4gMSBtYXggMQogICAgICAgIGVsaWYgKCggb3B0aW9uc19wYXJzZV9wYXJzZWRBcmdJbmRleCA+PSBtaW5QYXJzZWRBcmdJbmRleDAgJiYKICAgICAgICAgIG9wdGlvbnNfcGFyc2VfcGFyc2VkQXJnSW5kZXggPCBtYXhQYXJzZWRBcmdJbmRleDEgKSk7IHRoZW4KICAgICAgICAgIGlmICgob3B0aW9uc19wYXJzZV9hcmdQYXJzZWRDb3VudERpcmVjdG9yeSA+PSAxICkpOyB0aGVuCiAgICAgICAgICAgIExvZzo6ZGlzcGxheUVycm9yICJDb21tYW5kICR7U0NSSVBUX05BTUV9IC0gQXJndW1lbnQgZGlyZWN0b3J5IC0gTWF4aW11bSBudW1iZXIgb2YgYXJndW1lbnQgb2NjdXJyZW5jZXMgcmVhY2hlZCgxKSIKICAgICAgICAgICAgcmV0dXJuIDEKICAgICAgICAgIGZpCiAgICAgICAgICAoKCsrb3B0aW9uc19wYXJzZV9hcmdQYXJzZWRDb3VudERpcmVjdG9yeSkpCiAgICAgICAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKICAgICAgICAgIGRpcmVjdG9yeT0iJHtvcHRpb25zX3BhcnNlX2FyZ30iCgoKICAgICAgICAjIEFyZ3VtZW50IDIvMiAtIGV4dGVuc2lvbnMKICAgICAgICAjIEFyZ3VtZW50IGV4dGVuc2lvbnMgbWluIDEgbWF4IC0xCiAgICAgICAgZWxpZiAoKCBvcHRpb25zX3BhcnNlX3BhcnNlZEFyZ0luZGV4ID49IG1pblBhcnNlZEFyZ0luZGV4MSApKTsgdGhlbgogICAgICAgICAgKCgrK29wdGlvbnNfcGFyc2VfYXJnUGFyc2VkQ291bnRFeHRlbnNpb25zKSkKICAgICAgICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjAzNAogICAgICAgICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0CiAgICAgICAgICBleHRlbnNpb25zKz0oIiR7b3B0aW9uc19wYXJzZV9hcmd9IikKCgogICAgICAgICMgZWxzZSB0b28gbXVjaCBhcmdzCiAgICAgICAgZWxzZQoKCiAgICAgICAgICBpZiBbWyAiJHthcmdPcHREZWZhdWx0QmVoYXZpb3J9IiA9ICIwIiBdXTsgdGhlbgogICAgICAgICAgICAjIHRvbyBtdWNoIGFyZ3MgYW5kIG5vIHVua25vd25Bcmd1bWVudENhbGxiYWNrcyBjb25maWd1cmVkCiAgICAgICAgICAgIExvZzo6ZGlzcGxheUVycm9yICJDb21tYW5kICR7U0NSSVBUX05BTUV9IC0gQXJndW1lbnQgLSB0b28gbXVjaCBhcmd1bWVudHMgcHJvdmlkZWQ6ICQqIgogICAgICAgICAgICByZXR1cm4gMQogICAgICAgICAgZmkKCiAgICAgICAgZmkKICAgICAgICBpZiAoKGluY3JlbWVudEFyZyA9PSAxKSk7IHRoZW4KICAgICAgICAgICgoKytvcHRpb25zX3BhcnNlX3BhcnNlZEFyZ0luZGV4KSkKICAgICAgICBmaQogICAgICAgIDs7CiAgICBlc2FjCiAgICBzaGlmdCB8fCB0cnVlCiAgZG9uZQoKCiAgaWYgKChvcHRpb25zX3BhcnNlX2FyZ1BhcnNlZENvdW50RGlyZWN0b3J5IDwgMSApKTsgdGhlbgogICAgTG9nOjpkaXNwbGF5RXJyb3IgIkNvbW1hbmQgJHtTQ1JJUFRfTkFNRX0gLSBBcmd1bWVudCAnZGlyZWN0b3J5JyBzaG91bGQgYmUgcHJvdmlkZWQgYXQgbGVhc3QgMSB0aW1lKHMpIgogICAgcmV0dXJuIDEKICBmaQoKICBpZiAoKG9wdGlvbnNfcGFyc2VfYXJnUGFyc2VkQ291bnRFeHRlbnNpb25zIDwgMSApKTsgdGhlbgogICAgTG9nOjpkaXNwbGF5RXJyb3IgIkNvbW1hbmQgJHtTQ1JJUFRfTkFNRX0gLSBBcmd1bWVudCAnZXh0ZW5zaW9ucycgc2hvdWxkIGJlIHByb3ZpZGVkIGF0IGxlYXN0IDEgdGltZShzKSIKICAgIHJldHVybiAxCiAgZmkgfHwgcmV0dXJuICQ/Cgp9CgojIEBkZXNjcmlwdGlvbiBkaXNwbGF5IGNvbW1hbmQgb3B0aW9ucyBhbmQgYXJndW1lbnRzIGhlbHAgZm9yIHNpbXBsZUNvbW1hbmQKc2ltcGxlQ29tbWFuZEhlbHAoKSB7CiAgZWNobyAtZSAiJHtfX0hFTFBfVElUTEVfQ09MT1J9U1lOT1BTSVM6JHtfX1JFU0VUX0NPTE9SfSIKICBBcnJheTo6d3JhcDIgJyAnIDc2IDQgIiAgICAiICJhbGxvd3MgdG8gbG9hZCBzZXZlcmFsIGNvbmZpZyBmaWxlcyBhdCBvbmNlIgogIGVjaG8KICBlY2hvCgogICMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgIyB1c2FnZSBzZWN0aW9uCiAgIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICBBcnJheTo6d3JhcDIgIiAiIDgwIDIgIiR7X19IRUxQX1RJVExFX0NPTE9SfVVTQUdFOiR7X19SRVNFVF9DT0xPUn0iICJzaW1wbGVDb21tYW5kIFtPUFRJT05TXSBbQVJHVU1FTlRTXSIKICBlY2hvCiAgIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAjIHVzYWdlL29wdGlvbnMgc2VjdGlvbgogICMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgb3B0aW9uc0FsdExpc3Q9KCJbLS1oZWxwfC1oXSIgIlstLXZlcnNpb25dIgogICkKICBBcnJheTo6d3JhcDIgIiAiIDgwIDIgIiR7X19IRUxQX1RJVExFX0NPTE9SfVVTQUdFOiR7X19SRVNFVF9DT0xPUn0iIFwKICAgICJzaW1wbGVDb21tYW5kIiAiJHtvcHRpb25zQWx0TGlzdFtAXX0iCiAgZWNobwoKICAjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogICMgdXNhZ2UvYXJndW1lbnRzIHNlY3Rpb24KICAjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogIGVjaG8KICBlY2hvIC1lICIke19fSEVMUF9USVRMRV9DT0xPUn1BUkdVTUVOVFM6JHtfX1JFU0VUX0NPTE9SfSIKCiAgQXJyYXk6OndyYXAyICIgIiA4MCAyICIgICR7X19IRUxQX09QVElPTl9DT0xPUn1kaXJlY3Rvcnkke19fSEVMUF9OT1JNQUx9IHtzaW5nbGV9IChtYW5kYXRvcnkpIgogIEFycmF5Ojp3cmFwMiAnICcgNzYgNCAiICAgICIgImRpcmVjdG9yeSBpbiB3aGljaCBmaWxlcyB0byBsb2FkIHdpbGwgYmUgc2VhcmNoZWQiCiAgZWNobwoKCiAgQXJyYXk6OndyYXAyICIgIiA4MCAyICIgICR7X19IRUxQX09QVElPTl9DT0xPUn1leHRlbnNpb25zJHtfX0hFTFBfTk9STUFMfSB7bGlzdH0gKGF0IGxlYXN0IDEgdGltZXMpIgogIEFycmF5Ojp3cmFwMiAnICcgNzYgNCAiICAgICIgImxpc3Qgb2YgZmlsZSBleHRlbnNpb24gYWxsb3dlZCB0byBiZSBsb2FkZWQiCiAgZWNobwoKCiAgIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAjIG9wdGlvbnMgc2VjdGlvbgogICMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgZWNobwogIGVjaG8gLWUgIiR7X19IRUxQX1RJVExFX0NPTE9SfUdMT0JBTCBPUFRJT05TOiR7X19SRVNFVF9DT0xPUn0iCiAgZWNobyAtZSAiICAke19fSEVMUF9PUFRJT05fQ09MT1J9LS1oZWxwJHtfX0hFTFBfTk9STUFMfSwgJHtfX0hFTFBfT1BUSU9OX0NPTE9SfS1oJHtfX0hFTFBfTk9STUFMfSB7c2luZ2xlfSIKICBBcnJheTo6d3JhcDIgJyAnIDc2IDQgIiAgICAiICJEaXNwbGF5cyB0aGlzIGNvbW1hbmQgaGVscCIKICBlY2hvCgoKICBlY2hvIC1lICIgICR7X19IRUxQX09QVElPTl9DT0xPUn0tLXZlcnNpb24ke19fSEVMUF9OT1JNQUx9IHtzaW5nbGV9IgogIEFycmF5Ojp3cmFwMiAnICcgNzYgNCAiICAgICIgIlByaW50IHZlcnNpb24gaW5mb3JtYXRpb24gYW5kIHF1aXQuIgogIGVjaG8KCiAgIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAjIGxvbmdEZXNjcmlwdGlvbiBzZWN0aW9uCiAgIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICBlY2hvCiAgZWNobwogIGVjaG8gLWUgIiR7X19IRUxQX1RJVExFX0NPTE9SfURFU0NSSVBUSU9OOiR7X19SRVNFVF9DT0xPUn0iCiAgZGVjbGFyZSAtYSBzaW1wbGVDb21tYW5kTG9uZ0Rlc2NyaXB0aW9uPSgKICAidXNlZnVsIGZvciBiYXNoIGFuZCB6c2ggY29uZmlndXJhdGlvbiBsb2FkaW5nIgogICkKICBBcnJheTo6d3JhcDIgJyAnIDc2IDAgIiR7c2ltcGxlQ29tbWFuZExvbmdEZXNjcmlwdGlvbltAXX0iCiAgZWNobwogICMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgIyB2ZXJzaW9uIHNlY3Rpb24KICAjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogIGVjaG8KICBlY2hvIC1uIC1lICIke19fSEVMUF9USVRMRV9DT0xPUn1WRVJTSU9OOiAke19fUkVTRVRfQ09MT1J9IgogIGVjaG8gIjMuMCIKICAjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogICMgYXV0aG9yIHNlY3Rpb24KICAjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogIGVjaG8KICBlY2hvIC1uIC1lICIke19fSEVMUF9USVRMRV9DT0xPUn1BVVRIT1I6ICR7X19SRVNFVF9DT0xPUn0iCiAgZWNobyAiW0ZyYW5jb2lzIENoYXN0YW5ldF0oaHR0cHM6Ly9naXRodWIuY29tL2ZjaGFzdGFuZXQpIgogICMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgIyBzb3VyY2VGaWxlIHNlY3Rpb24KICAjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogIGVjaG8KICBlY2hvIC1uIC1lICIke19fSEVMUF9USVRMRV9DT0xPUn1TT1VSQ0UgRklMRTogJHtfX1JFU0VUX0NPTE9SfSIKICBlY2hvICJodHRwczovL2dpdGh1Yi5jb20vZmNoYXN0YW5ldC9iYXNoLWRldi1lbnYvdHJlZS9tYXN0ZXIvc3JjL190b29scy9maW5kQ29uZmlnRmlsZXMtYmluYXJ5LnlhbWwiCiAgIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAjIGxpY2Vuc2Ugc2VjdGlvbgogICMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgZWNobwogIGVjaG8gLW4gLWUgIiR7X19IRUxQX1RJVExFX0NPTE9SfUxJQ0VOU0U6ICR7X19SRVNFVF9DT0xPUn0iCiAgZWNobyAiTUlUIExpY2Vuc2UiCiAgIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAjIGNvcHlyaWdodCBzZWN0aW9uCiAgIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICBBcnJheTo6d3JhcDIgJyAnIDc2IDAgIiQoY29weXJpZ2h0Q2FsbGJhY2spIgp9CgoKYmVmb3JlUGFyc2VDYWxsYmFjawoKc2ltcGxlQ29tbWFuZFBhcnNlICIkQCIKTUFJTl9GVU5DVElPTl9OQU1FPSJtYWluIgptYWluKCkgewoKTGludXg6OnJlcXVpcmVUYXJDb21tYW5kCkNvbXBpbGVyOjpFbWJlZDo6ZXh0cmFjdEZpbGVGcm9tQmFzZTY0IFwKICAiJHtQRVJTSVNURU5UX1RNUERJUjotL3RtcH0vNGU3ZTg1NTJlZDJhZGQ1Yjk0ODZiNzZlYWMxNTFiNTYyNjJlYjI0MWMzMDI5NTNmYWVjNzIxNmQ3MzMwOTg0Zi9maW5kQ29uZmlnRmlsZXNBd2siIFwKICAiUWtWSFNVNGdld29nSUVaVFBTSXVJanNLSUNCemNHeHBkQ2hsZUhRc0lHVjRkRUZ5Y2l3Z0lud2lLVHNLSUNCbWIzSWdLR2tnYVc0Z1pYaDBRWEp5S1NCN0NpQWdJQ0JsZUhSSmJtUmxlRnRsZUhSQmNuSmJhVjFkSUQwZ2FUc0tJQ0I5Q24wS1puVnVZM1JwYjI0Z1ltRnpaVzVoYldWWGFYUm9iM1YwUlhoMFpXNXphVzl1S0dacGJHVXBJSHNLSUNCemRXSW9JaTRxTHlJc0lDSWlMQ0JtYVd4bEtRb2dJSE4xWWlndlhDNWJYaTVkS3lRdkxDQWlJaXdnWm1sc1pTa0tJQ0J5WlhSMWNtNGdabWxzWlFwOUNuc0tJQ0JwWmlBb0pFNUdJR2x1SUdWNGRFbHVaR1Y0S1NCN0NpQWdJQ0JtYVd4bFFtRnpaVDFpWVhObGJtRnRaVmRwZEdodmRYUkZlSFJsYm5OcGIyNG9KREFwQ2lBZ0lDQndjbWx1ZENCbWFXeGxRbUZ6WlNBaVhIUWlJR1Y0ZEVsdVpHVjRXeVJPUmwwZ0lseDBJaUFrTURzS0lDQjlDbjBLIiBcCiAgIjY0NCIKCmRlY2xhcmUgLWd4IGVtYmVkX2ZpbGVfZmluZENvbmZpZ0ZpbGVzQXdrPSIke1BFUlNJU1RFTlRfVE1QRElSOi0vdG1wfS80ZTdlODU1MmVkMmFkZDViOTQ4NmI3NmVhYzE1MWI1NjI2MmViMjQxYzMwMjk1M2ZhZWM3MjE2ZDczMzA5ODRmL2ZpbmRDb25maWdGaWxlc0F3ayIKCgojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIxNTQKaWYgW1sgISAtZCAiJHtkaXJlY3Rvcnl9IiBdXTsgdGhlbgogIHJldHVybiAxCmZpCmRlY2xhcmUgLWEgZmluZENtZD0oCiAgZmluZCAiJHtkaXJlY3Rvcnl9IiAtZXhlY3V0YWJsZSAtdHlwZSAnZixsJyAnKCcKKQpmb3IgZXh0IGluICIke2V4dGVuc2lvbnNbQF19IjsgZG8KICBmaW5kQ21kKz0oLW5hbWUgXCouIiR7ZXh0fSIgLW8pCmRvbmUKdW5zZXQgJ2ZpbmRDbWRbLTFdJwpmaW5kQ21kKz0oJyknIC1wcmludGYgJyVwXG4nKQoKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMTU0CiIke2ZpbmRDbWRbQF19IiAyPi9kZXYvbnVsbCB8CiAgYXdrIC12IGV4dD0iJChwcmludGYgJyVzfCcgIiR7ZXh0ZW5zaW9uc1tAXX0iKSIgLWYgIiR7ZW1iZWRfZmlsZV9maW5kQ29uZmlnRmlsZXNBd2t9IiB8CiAgc29ydCAtdCQnXHQnIC1rMSwxIC1rMiwyIHwgY3V0IC1mMy0KCn0KCiMgaWYgZmlsZSBpcyBzb3VyY2VkIGF2b2lkIGNhbGxpbmcgbWFpbiBmdW5jdGlvbgojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIxNzgKQkFTSF9TT1VSQ0U9Ii4kMCIgIyBjYW5ub3QgYmUgY2hhbmdlZCBpbiBiYXNoCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjEyOAppZiB0ZXN0ICIuJDAiID09ICIuJHtCQVNIX1NPVVJDRX0iOyB0aGVuCiAgaWYgW1sgIiR7QkFTSF9GUkFNRVdPUktfUVVJRVRfTU9ERTotMH0iID0gIjEiIF1dOyB0aGVuCiAgICBtYWluICIkQCIgJj4vZGV2L251bGwKICBlbHNlCiAgICBtYWluICIkQCIKICBmaQpmaQo=" \
  "755"

declare -gx embed_file_findConfigFiles="${PERSISTENT_TMPDIR:-/tmp}/4499845f13fbf1e1951f61dc971232e41f02dabc81c92d6f64706fb1f9bfc542/findConfigFiles"


helpDescription() {
  echo "Default Zsh configuration"
}

dependencies() {
  echo "installScripts/ShellBashDefaultConfig"
}

listVariables() {
  echo "HOME"
  echo "USERNAME"
  echo "USERGROUP"
}

fortunes() {
  if [[ "${USER_SHELL}" = "/usr/bin/zsh" ]]; then
    echo -e "${__INFO_COLOR}$(scriptName)${__RESET_COLOR} -- Zsh ref card manual ${__HELP_EXAMPLE}<http://www.bash2zsh.com/zsh_refcard/refcard.pdf>${__RESET_COLOR}."
    echo "%"
    if [[ "${ZSH_PREFERRED_THEME:-${ZSH_DEFAULT_THEME}}" != "powerlevel10k/powerlevel10k" ]]; then
      echo -e "${__INFO_COLOR}$(scriptName)${__RESET_COLOR} -- ${__HELP_EXAMPLE}Powerlevel10k${__RESET_COLOR} - use the command ${__HELP_EXAMPLE}p10k configure${__RESET_COLOR} to customize shell prompt."
      echo "%"
    fi
  else
    if command -v zsh &>/dev/null; then
      echo -e "${__INFO_COLOR}$(scriptName)${__RESET_COLOR} -- ${__HELP_EXAMPLE}${USER_SHELL}${__RESET_COLOR} is set as default shell, you can switch to zsh using ${__HELP_EXAMPLE}chsh -s /usr/bin/zsh${__RESET_COLOR}."
      echo "%"
    else
      echo -e "${__INFO_COLOR}$(scriptName)${__RESET_COLOR} -- ${__HELP_EXAMPLE}Zsh${__RESET_COLOR} is not set as your default shell, you can give it a try using ${__HELP_EXAMPLE}installAndConfigure ZshProfile${__RESET_COLOR}."
      echo "%"
    fi
  fi
}

# jscpd:ignore-start
helpVariables() { :; }
defaultVariables() { :; }
checkVariables() { :; }
breakOnConfigFailure() { :; }
breakOnTestFailure() { :; }
# jscpd:ignore-end

cleanBeforeExport() {
  rm -f "${HOME}/.zcompdump" || true
}

testCleanBeforeExport() {
  ((failures = 0)) || true
  Assert::fileNotExists "${HOME}/.zcompdump" || ((++failures))
  return "${failures}"
}

install() {
  local -a packages=(
    zsh
    # needed by some zinit packages
    subversion
  )
  Linux::Apt::installIfNecessary --no-install-recommends "${packages[@]}"

  Log::displayInfo "install oh-my-zsh"
  sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended

  Log::displayInfo "install plugin manager"
  if command -v zinit &>/dev/null; then
    zinit self-update
    zinit update --all --parallel
  else
    NO_INPUT=1 NO_TUTORIAL=1 bash -c "$(
      curl \
        --fail --show-error --silent \
        --location https://raw.githubusercontent.com/zdharma-continuum/zinit/HEAD/scripts/install.sh
    )"
  fi

  Log::displayInfo "install ohmyposh theme"
  if [[ "${ZSH_PREFERRED_THEME:-${ZSH_DEFAULT_THEME}}" = "ohmyposh" ]]; then
    curl -s https://ohmyposh.dev/install.sh | bash -s
  fi
}

assertZshFunctionExists() {
  local functionName="$1"
  zsh -i -c "typeset -f '${functionName}' &>/dev/null" || {
    Log::displayError "Zsh function ${functionName} does not exist"
    return 1
  }
}

testInstall() {
  local -i failures=0
  Assert::commandExists zsh || ((++failures))
  Assert::commandExists "svn" || ((++failures))
  Assert::commandExists "oh-my-posh" || ((++failures))
  assertZshFunctionExists zinit || ((++failures))
  return "${failures}"
}

configure() {
  if [[ "${PREFERRED_SHELL}" = "ShellZsh" ]]; then
    if [[ "${USER_SHELL}" != "/usr/bin/zsh" ]]; then
      sudo usermod --shell /usr/bin/zsh "${USERNAME}"
      USER_SHELL="/usr/bin/zsh"
      Log::displayHelp "You have to log in/log out to make zsh by default"
    fi
    Log::displayHelp "Zsh is set as default shell, you can switch back to bash using 'chsh -s /usr/bin/bash'"
  fi
  # shellcheck disable=SC2154
  Conf::copyStructure \
    "${embed_dir_conf_dir}" \
    "$(fullScriptOverrideDir)" \
    ".bash-dev-env"

  Conf::copyStructure \
    "${embed_dir_conf_dir}" \
    "$(fullScriptOverrideDir)" \
    "home" \
    "${HOME}"

  # shellcheck disable=SC2154
  OVERWRITE_CONFIG_FILES=1 Install::file \
    "${embed_file_findConfigFiles}" \
    "${HOME}/.bash-dev-env/findConfigFiles"
}

declare -a confFiles=(
  "${HOME}/.bash-dev-env/interactive.d/zsh-syntax-complete-suggest.zsh"
  "${HOME}/.bash-dev-env/interactive.d/zsh-beep.zsh"
  "${HOME}/.bash-dev-env/interactive.d/zsh-history.zsh"
  "${HOME}/.bash-dev-env/interactive.d/zsh-ls-colors.zsh"
  "${HOME}/.bash-dev-env/interactive.d/zsh-ssh.zsh"
  "${HOME}/.bash-dev-env/interactive.d/zsh-z.zsh"
  "${HOME}/.bash-dev-env/themes.d/powerlevel10k.zsh"
  "${HOME}/.bash-dev-env/themes.d/ohmyposh.zsh"
  "${HOME}/.bash-dev-env/themes.d/pure.zsh"
  "${HOME}/.bash-dev-env/themes.d/starship.zsh"
  "${HOME}/.bash-dev-env/findConfigFiles"
  "${HOME}/.zshrc"
  "${HOME}/.zprofile"
  "${HOME}/.p10k.zsh"
)

testConfigure() {
  local -i failures=0
  local file
  for file in "${confFiles[@]}"; do
    Assert::fileExists "${file}" || ((++failures))
  done
  Log::displayInfo "Try to load .zshrc"
  (zsh -i -c 'echo "Hello Zsh"' || exit 1) || {
    Log::displayError "something goes bad while loading ~/.zshrc"
    ((++failures))
  }

  return "${failures}"
}



softwareArgHelpFunction() {
  echo "    List of softwares to install (--profile option cannot be used in this case)"
  echo "    See below for complete list of softwares available"
}

profileHelpFunction() {
  echo "    Profile name to use that contains all the softwares to install"
}

profilesHelpList() {
  echo -e "  ${__HELP_TITLE_COLOR}Available profiles:${__RESET_COLOR}"
  (
    Conf::list "${BASH_DEV_ENV_ROOT_DIR}/profiles" "profile." ".sh" "-type f" "    - "
    local dir
    for dir in "${BASH_DEV_ENV_ROOT_DIR}/srcAlt/"*; do
      if [[ -d "${dir}/profiles" ]]; then
        Conf::list "${dir}/profiles" "profile." ".sh" "-type f" "    - "
      fi
    done
  ) | sort | uniq
}

validateProfile() {
  local profileName="$2"
  if ! Profiles::getProfilePath "${profileName}" &>/dev/null; then
    Log::fatal "Profile file profile.${profileName}.sh doesn't exist in any profiles directory"
  fi
}

commandCallback() {
  if ((${#CONFIG_LIST} > 0)); then
    if [[ -n "${PROFILE}" ]]; then
      Log::fatal "You cannot combine profile and softwares"
    fi
    # check if each Softwares exists
    local software
    for software in "${CONFIG_LIST[@]}"; do
      if [[ ! -f "${BASH_DEV_ENV_ROOT_DIR}/${software}" ]]; then
        Log::fatal "Software ${software} configuration does not exists"
      fi
    done
  elif [[ -z "${PROFILE}" ]]; then
    Log::fatal "You must specify either a list of softwares, either a profile name"
  else
    # get profile path
    local profilePath
    profilePath="$(Profiles::getProfilePath "${PROFILE}")" # should succeed as it was tested by option
    # load selected profile
    Profiles::loadProfile "${profilePath}"
  fi
  if [[ "${SKIP_DEPENDENCIES:-0}" = "0" ]]; then
    CONFIG_LIST=("${CONFIG_LIST[@]}")

    declare rootDependency="your software selection"
    if [[ -n "${PROFILE}" ]]; then
      rootDependency="profile ${PROFILE}"
    fi
    # deduce dependencies
    declare -ag allDepsResult=()
    # shellcheck disable=SC2034
    declare -Ag allDepsResultSeen=()
    Profiles::allDepsRecursive \
      "${BASH_DEV_ENV_ROOT_DIR}" "${rootDependency}" "${CONFIG_LIST[@]}"

    CONFIG_LIST=("${allDepsResult[@]}")
  fi
  if ((${#CONFIG_LIST} == 0)); then
    Log::fatal "Softwares list is empty"
  fi
}

export CONFIG_LIST
export PROFILE



generateSoftwaresList() {
  local directory="$1"
  local relativeDir="$2"
  local description list softName

  list="$(
    Conf::list "${directory}" "" "" "-type f" "" |
      grep -v -E '^(_.*|MandatorySoftwares)$' || true
  )"
  local -i maxLineLength
  maxLineLength="$(wc -L <<<"${list}")"
  ((maxLineLength += 1 + ${#relativeDir}))
  while read -r soft; do
    softName="${soft}"
    description="$(SKIP_REQUIRES=1 "${directory}/${soft}" helpDescription 2>/dev/null)"
    if [[ -z "${description}" ]]; then
      description="<No description available>"
    fi
    description="$(printf -- '_%.0s' $(seq "$((maxLineLength - ${#softName} - 1 - ${#relativeDir} + 1))")) ${description}"
    description="  - ${__HELP_TITLE_COLOR}${relativeDir}/${softName} ${__HELP_EXAMPLE}${description}${__RESET_COLOR}"
    echo -e " ${description}" | sed '2,$s/^/      /'
  done <<<"${list}"
}

softwaresListCacheFile() {
  local relativeDir="$1"
  directoryName="$(sed -E 's#/#_#g' <<<"${relativeDir}")"
  echo "${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}/bash_dev_env_${directoryName}_arg_help_cache"
}

generateSoftwaresListCache() {
  local directory="$1"
  local relativeDir="$2"
  local softwaresListHelpTempFile="$3"

  if [[ ! -f "${softwaresListHelpTempFile}" ]] ||
    (($(File::elapsedTimeSinceLastModification "${softwaresListHelpTempFile}") > help_cache_max_duration)); then
    echo >&2 -n "Generating softwares list cache (directory ${relativeDir}) ..."
    generateSoftwaresList "${directory}" "${relativeDir}" >"${softwaresListHelpTempFile}" || rm -f "${softwaresListHelpTempFile}"
    echo >&2 -e "\033[2K" # erase line (Generating softwares list cache ...)
  fi
}

displayAvailableSoftwares() {
  local directory="$1"

  local relativeDir
  relativeDir="$(File::relativeToDir "${directory}" "${BASH_DEV_ENV_ROOT_DIR}")"
  local softwaresListHelpTempFile
  softwaresListHelpTempFile="$(softwaresListCacheFile "${relativeDir}")"
  generateSoftwaresListCache "${directory}" "${relativeDir}" "${softwaresListHelpTempFile}"
  echo -e "  ${__HELP_TITLE_COLOR}Available Softwares (directory ${relativeDir}):${__RESET_COLOR}"
  cat "${softwaresListHelpTempFile}"
}

declare -i help_cache_max_duration=86400



optionHelpCallback() {
  "ShellZshDefaultConfigCommandHelp"
  exit 0
}

defaultBeforeParseCallback() {
  Env::requireLoad
  UI::requireTheme
  Log::requireLoad
  Linux::requireUbuntu
  Linux::Wsl::requireWsl
}

beforeParseCallback() {
  defaultBeforeParseCallback
}

defaultAfterParseCallback() {
  Engine::Config::loadConfig
}

afterParseCallback() {
  defaultAfterParseCallback
}


# ------------------------------------------
# Command ShellZshDefaultConfigCommand
# ------------------------------------------

# options variables initialization
declare SKIP_CONFIGURE="0"
declare SKIP_INSTALL="0"
declare SKIP_TEST="0"
declare SKIP_DEPENDENCIES="0"
declare PREPARE_EXPORT="0"
declare PROFILE=""
declare optionHelp="0"
declare optionConfig="0"
declare optionBashFrameworkConfig=""
declare optionInfoVerbose="0"
declare optionDebugVerbose="0"
declare optionTraceVerbose="0"
declare optionLogLevel="optionLogLevelDefaultValueFunction"
declare optionLogFile="optionLogFileDefaultValueFunction"
declare optionDisplayLevel="optionDisplayLevelDefaultValueFunction"
declare optionNoColor="0"
declare optionTheme="default"
declare optionVersion="0"
declare optionQuiet="0"
# arguments variables initialization
declare command="install"
# @description parse command options and arguments for ShellZshDefaultConfigCommand
ShellZshDefaultConfigCommandParse() {
  Log::displayDebug "Command ${SCRIPT_NAME} - parse arguments: ${BASH_FRAMEWORK_ARGV[*]}"
  Log::displayDebug "Command ${SCRIPT_NAME} - parse filtered arguments: ${BASH_FRAMEWORK_ARGV_FILTERED[*]}"
  SKIP_CONFIGURE="0"
  local -i options_parse_optionParsedCountSKIP_CONFIGURE
  ((options_parse_optionParsedCountSKIP_CONFIGURE = 0)) || true
  SKIP_INSTALL="0"
  local -i options_parse_optionParsedCountSKIP_INSTALL
  ((options_parse_optionParsedCountSKIP_INSTALL = 0)) || true
  SKIP_TEST="0"
  local -i options_parse_optionParsedCountSKIP_TEST
  ((options_parse_optionParsedCountSKIP_TEST = 0)) || true
  SKIP_DEPENDENCIES="0"
  local -i options_parse_optionParsedCountSKIP_DEPENDENCIES
  ((options_parse_optionParsedCountSKIP_DEPENDENCIES = 0)) || true
  PREPARE_EXPORT="0"
  local -i options_parse_optionParsedCountPREPARE_EXPORT
  ((options_parse_optionParsedCountPREPARE_EXPORT = 0)) || true
  PROFILE=""
  local -i options_parse_optionParsedCountPROFILE
  ((options_parse_optionParsedCountPROFILE = 0)) || true
  optionHelp="0"
  local -i options_parse_optionParsedCountOptionHelp
  ((options_parse_optionParsedCountOptionHelp = 0)) || true
  optionConfig="0"
  local -i options_parse_optionParsedCountOptionConfig
  ((options_parse_optionParsedCountOptionConfig = 0)) || true
  optionBashFrameworkConfig=""
  local -i options_parse_optionParsedCountOptionBashFrameworkConfig
  ((options_parse_optionParsedCountOptionBashFrameworkConfig = 0)) || true
  optionInfoVerbose="0"
  local -i options_parse_optionParsedCountOptionInfoVerbose
  ((options_parse_optionParsedCountOptionInfoVerbose = 0)) || true
  optionDebugVerbose="0"
  local -i options_parse_optionParsedCountOptionDebugVerbose
  ((options_parse_optionParsedCountOptionDebugVerbose = 0)) || true
  optionTraceVerbose="0"
  local -i options_parse_optionParsedCountOptionTraceVerbose
  ((options_parse_optionParsedCountOptionTraceVerbose = 0)) || true
  optionLogLevel="optionLogLevelDefaultValueFunction"
  local -i options_parse_optionParsedCountOptionLogLevel
  ((options_parse_optionParsedCountOptionLogLevel = 0)) || true
  optionLogFile="optionLogFileDefaultValueFunction"
  local -i options_parse_optionParsedCountOptionLogFile
  ((options_parse_optionParsedCountOptionLogFile = 0)) || true
  optionDisplayLevel="optionDisplayLevelDefaultValueFunction"
  local -i options_parse_optionParsedCountOptionDisplayLevel
  ((options_parse_optionParsedCountOptionDisplayLevel = 0)) || true
  optionNoColor="0"
  local -i options_parse_optionParsedCountOptionNoColor
  ((options_parse_optionParsedCountOptionNoColor = 0)) || true
  optionTheme="default"
  local -i options_parse_optionParsedCountOptionTheme
  ((options_parse_optionParsedCountOptionTheme = 0)) || true
  optionVersion="0"
  local -i options_parse_optionParsedCountOptionVersion
  ((options_parse_optionParsedCountOptionVersion = 0)) || true
  optionQuiet="0"
  local -i options_parse_optionParsedCountOptionQuiet
  ((options_parse_optionParsedCountOptionQuiet = 0)) || true

  command="install"

  local -i options_parse_argParsedCountCommand
  ((options_parse_argParsedCountCommand = 0)) || true


  # shellcheck disable=SC2034
  local -i options_parse_parsedArgIndex=0
  while (($# > 0)); do
    local options_parse_arg="$1"
    local argOptDefaultBehavior=0
    case "${options_parse_arg}" in
      # Option 1/19
      # SKIP_CONFIGURE alts --skip-config|--skip-configure|--skip-configuration|-sc
      # type: Boolean min 0 max 1
      --skip-config | --skip-configure | --skip-configuration | -sc)
        # shellcheck disable=SC2034
        SKIP_CONFIGURE="1"

        if ((options_parse_optionParsedCountSKIP_CONFIGURE >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountSKIP_CONFIGURE))
        ;;

      # Option 2/19
      # SKIP_INSTALL alts --skip-install|--skip-installation|-si
      # type: Boolean min 0 max 1
      --skip-install | --skip-installation | -si)
        # shellcheck disable=SC2034
        SKIP_INSTALL="1"

        if ((options_parse_optionParsedCountSKIP_INSTALL >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountSKIP_INSTALL))
        ;;

      # Option 3/19
      # SKIP_TEST alts --skip-test|--skip-tests|-st
      # type: Boolean min 0 max 1
      --skip-test | --skip-tests | -st)
        # shellcheck disable=SC2034
        SKIP_TEST="1"

        if ((options_parse_optionParsedCountSKIP_TEST >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountSKIP_TEST))
        ;;

      # Option 4/19
      # SKIP_DEPENDENCIES alts --skip-deps|--skip-dependencies|-sd
      # type: Boolean min 0 max 1
      --skip-deps | --skip-dependencies | -sd)
        # shellcheck disable=SC2034
        SKIP_DEPENDENCIES="1"

        if ((options_parse_optionParsedCountSKIP_DEPENDENCIES >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountSKIP_DEPENDENCIES))
        ;;

      # Option 5/19
      # PREPARE_EXPORT alts --prepare-export|-e
      # type: Boolean min 0 max 1
      --prepare-export | -e)
        # shellcheck disable=SC2034
        PREPARE_EXPORT="1"

        if ((options_parse_optionParsedCountPREPARE_EXPORT >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountPREPARE_EXPORT))
        ;;

      # Option 6/19
      # PROFILE alts --profile|-p
      # type: String min 0 max 1
      --profile | -p)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi

        if ((options_parse_optionParsedCountPROFILE >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountPROFILE))
        # shellcheck disable=SC2034
        PROFILE="$1"
        validateProfile "${options_parse_arg}" "${PROFILE}"

        ;;

      # Option 7/19
      # optionHelp alts --help|-h
      # type: Boolean min 0 max 1
      --help | -h)
        # shellcheck disable=SC2034
        optionHelp="1"

        if ((options_parse_optionParsedCountOptionHelp >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionHelp))
        optionHelpCallback "${options_parse_arg}" "${optionHelp}"

        ;;

      # Option 8/19
      # optionConfig alts --config
      # type: Boolean min 0 max 1
      --config)
        # shellcheck disable=SC2034
        optionConfig="1"

        if ((options_parse_optionParsedCountOptionConfig >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionConfig))
        ;;

      # Option 9/19
      # optionBashFrameworkConfig alts --bash-framework-config
      # type: String min 0 max 1
      --bash-framework-config)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionBashFrameworkConfig >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionBashFrameworkConfig))
        # shellcheck disable=SC2034
        optionBashFrameworkConfig="$1"
        optionBashFrameworkConfigCallback "${options_parse_arg}" "${optionBashFrameworkConfig}"

        ;;

      # Option 10/19
      # optionInfoVerbose alts --verbose|-v
      # type: Boolean min 0 max 1
      --verbose | -v)
        # shellcheck disable=SC2034
        optionInfoVerbose="1"

        if ((options_parse_optionParsedCountOptionInfoVerbose >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionInfoVerbose))
        optionInfoVerboseCallback "${options_parse_arg}" "${optionInfoVerbose}"

        updateArgListInfoVerboseCallback "${options_parse_arg}" "${optionInfoVerbose}"

        ;;

      # Option 11/19
      # optionDebugVerbose alts -vv
      # type: Boolean min 0 max 1
      -vv)
        # shellcheck disable=SC2034
        optionDebugVerbose="1"

        if ((options_parse_optionParsedCountOptionDebugVerbose >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionDebugVerbose))
        optionDebugVerboseCallback "${options_parse_arg}" "${optionDebugVerbose}"

        updateArgListDebugVerboseCallback "${options_parse_arg}" "${optionDebugVerbose}"

        ;;

      # Option 12/19
      # optionTraceVerbose alts -vvv
      # type: Boolean min 0 max 1
      -vvv)
        # shellcheck disable=SC2034
        optionTraceVerbose="1"

        if ((options_parse_optionParsedCountOptionTraceVerbose >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionTraceVerbose))
        optionTraceVerboseCallback "${options_parse_arg}" "${optionTraceVerbose}"

        updateArgListTraceVerboseCallback "${options_parse_arg}" "${optionTraceVerbose}"

        ;;

      # Option 13/19
      # optionLogLevel alts --log-level
      # type: String min 0 max 1
      # authorizedValues: OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE
      --log-level)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi
        if [[ ! "$1" =~ OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE ]]; then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF, ERR, ERROR, WARN, WARNING, INFO, DEBUG, TRACE)"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionLogLevel >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionLogLevel))
        # shellcheck disable=SC2034
        optionLogLevel="$1"
        optionLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"

        updateArgListLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"

        ;;

      # Option 14/19
      # optionLogFile alts --log-file
      # type: String min 0 max 1
      --log-file)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionLogFile >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionLogFile))
        # shellcheck disable=SC2034
        optionLogFile="$1"
        optionLogFileCallback "${options_parse_arg}" "${optionLogFile}"

        updateArgListLogFileCallback "${options_parse_arg}" "${optionLogFile}"

        ;;

      # Option 15/19
      # optionDisplayLevel alts --display-level
      # type: String min 0 max 1
      # authorizedValues: OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE
      --display-level)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi
        if [[ ! "$1" =~ OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE ]]; then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF, ERR, ERROR, WARN, WARNING, INFO, DEBUG, TRACE)"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionDisplayLevel >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionDisplayLevel))
        # shellcheck disable=SC2034
        optionDisplayLevel="$1"
        optionDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"

        updateArgListDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"

        ;;

      # Option 16/19
      # optionNoColor alts --no-color
      # type: Boolean min 0 max 1
      --no-color)
        # shellcheck disable=SC2034
        optionNoColor="1"

        if ((options_parse_optionParsedCountOptionNoColor >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionNoColor))
        optionNoColorCallback "${options_parse_arg}" "${optionNoColor}"

        updateArgListNoColorCallback "${options_parse_arg}" "${optionNoColor}"

        ;;

      # Option 17/19
      # optionTheme alts --theme
      # type: String min 0 max 1
      # authorizedValues: default|default-force|noColor
      --theme)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi
        if [[ ! "$1" =~ default|default-force|noColor ]]; then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(default, default-force, noColor)"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionTheme >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionTheme))
        # shellcheck disable=SC2034
        optionTheme="$1"
        optionThemeCallback "${options_parse_arg}" "${optionTheme}"

        updateArgListThemeCallback "${options_parse_arg}" "${optionTheme}"

        ;;

      # Option 18/19
      # optionVersion alts --version
      # type: Boolean min 0 max 1
      --version)
        # shellcheck disable=SC2034
        optionVersion="1"

        if ((options_parse_optionParsedCountOptionVersion >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionVersion))
        optionVersionCallback "${options_parse_arg}" "${optionVersion}"

        ;;

      # Option 19/19
      # optionQuiet alts --quiet|-q
      # type: Boolean min 0 max 1
      --quiet | -q)
        # shellcheck disable=SC2034
        optionQuiet="1"

        if ((options_parse_optionParsedCountOptionQuiet >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionQuiet))
        optionQuietCallback "${options_parse_arg}" "${optionQuiet}"

        updateArgListQuietCallback "${options_parse_arg}" "${optionQuiet}"

        ;;

      -*)
        if [[ "${argOptDefaultBehavior}" = "0" ]]; then
          Log::displayError "Command ${SCRIPT_NAME} - Invalid option ${options_parse_arg}"
          return 1
        fi
        ;;
      *)
        ((minParsedArgIndex0 = 0)) || true
        ((maxParsedArgIndex0 = 0)) || true
        ((minParsedArgIndex1 = minParsedArgIndex0 + 0)) || true
        ((maxParsedArgIndex1 = maxParsedArgIndex0 + 1)) || true
        ((incrementArg = 1 ))
        if ((0)); then
          # Technical if - never reached
          :

        # Argument 1/1 - command
        # Argument command min 0 max 1
        # Argument command authorizedValues: isInterfaceImplemented|helpDescription|scriptName|dependencies|listVariables|fortunes|helpVariables|defaultVariables|checkVariables|breakOnConfigFailure|breakOnTestFailure|isInstallImplemented|install|isTestInstallImplemented|testInstall|isConfigureImplemented|configure|isTestConfigureImplemented|testConfigure|isCleanBeforeExportImplemented
        elif (( options_parse_parsedArgIndex >= minParsedArgIndex0 &&
          options_parse_parsedArgIndex < maxParsedArgIndex1 )); then
          if [[ ! "${options_parse_arg}" =~ isInterfaceImplemented|helpDescription|scriptName|dependencies|listVariables|fortunes|helpVariables|defaultVariables|checkVariables|breakOnConfigFailure|breakOnTestFailure|isInstallImplemented|install|isTestInstallImplemented|testInstall|isConfigureImplemented|configure|isTestConfigureImplemented|testConfigure|isCleanBeforeExportImplemented ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Argument command - value '${options_parse_arg}' is not part of authorized values(isInterfaceImplemented, helpDescription, scriptName, dependencies, listVariables, fortunes, helpVariables, defaultVariables, checkVariables, breakOnConfigFailure, breakOnTestFailure, isInstallImplemented, install, isTestInstallImplemented, testInstall, isConfigureImplemented, configure, isTestConfigureImplemented, testConfigure, isCleanBeforeExportImplemented)"
            return 1
          fi
          if ((options_parse_argParsedCountCommand >= 1 )); then
            Log::displayError "Command ${SCRIPT_NAME} - Argument command - Maximum number of argument occurrences reached(1)"
            return 1
          fi
          ((++options_parse_argParsedCountCommand))
          # shellcheck disable=SC2034
          command="${options_parse_arg}"
          argsInstallScriptCommandCallback "${command}" -- "${@:2}"


        # else too much args
        else


          if [[ "${argOptDefaultBehavior}" = "0" ]]; then
            # too much args and no unknownArgumentCallbacks configured
            Log::displayError "Command ${SCRIPT_NAME} - Argument - too much arguments provided: $*"
            return 1
          fi

        fi
        if ((incrementArg == 1)); then
          ((++options_parse_parsedArgIndex))
        fi
        ;;
    esac
    shift || true
  done || return $?

  commandOptionParseFinished

}

# @description display command options and arguments help for ShellZshDefaultConfigCommand
ShellZshDefaultConfigCommandHelp() {
  echo -e "${__HELP_TITLE_COLOR}SYNOPSIS:${__RESET_COLOR}"
  helpDescriptionFunction


  # ------------------------------------------
  # usage section
  # ------------------------------------------
  Array::wrap2 " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" "ShellZshDefaultConfig [OPTIONS] [ARGUMENTS]"
  echo
  # ------------------------------------------
  # usage/options section
  # ------------------------------------------
  optionsAltList=("[--skip-config|--skip-configure|--skip-configuration|-sc]" "[--skip-install|--skip-installation|-si]" "[--skip-test|--skip-tests|-st]" "[--skip-deps|--skip-dependencies|-sd]" "[--prepare-export|-e]" "[--profile|-p <profile>]" "[--help|-h]" "[--config]" "[--bash-framework-config <bash-framework-config>]" "[--verbose|-v]" "[-vv]" "[-vvv]" "[--log-level <log-level>]" "[--log-file <log-file>]" "[--display-level <display-level>]" "[--no-color]" "[--theme <theme>]" "[--version]" "[--quiet|-q]"
  )
  Array::wrap2 " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" \
    "ShellZshDefaultConfig" "${optionsAltList[@]}"
  echo

  # ------------------------------------------
  # usage/arguments section
  # ------------------------------------------
  echo
  echo -e "${__HELP_TITLE_COLOR}ARGUMENTS:${__RESET_COLOR}"

  Array::wrap2 " " 80 2 "  [${__HELP_OPTION_COLOR}command${__HELP_NORMAL} {single}]"
  Array::wrap2 ' ' 76 4 "    " "The command to run on this install script."
  echo

  echo "    Possible values:"
  Array::wrap2 ' ' 76 8 "      - ${__OPTION_COLOR}isInterfaceImplemented:${__RESET_COLOR} Check if all commands below are available"
  echo
  Array::wrap2 ' ' 76 8 "      - ${__OPTION_COLOR}helpDescription:${__RESET_COLOR} Show help description of this install script."
  echo
  Array::wrap2 ' ' 76 8 "      - ${__OPTION_COLOR}scriptName:${__RESET_COLOR} Show the internal name of this install script."
  echo
  Array::wrap2 ' ' 76 8 "      - ${__OPTION_COLOR}dependencies:${__RESET_COLOR} Show this install scripts's dependencies."
  echo
  Array::wrap2 ' ' 76 8 "      - ${__OPTION_COLOR}listVariables:${__RESET_COLOR} Show the variables needed to execute this
  install script."
  echo
  Array::wrap2 ' ' 76 8 "      - ${__OPTION_COLOR}fortunes:${__RESET_COLOR} Show the fortunes sentences that this
  install script can generate."
  echo
  echo -e "      - ${__OPTION_COLOR}helpVariables${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}defaultVariables${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}checkVariables${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}breakOnConfigFailure${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}breakOnTestFailure${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}isInstallImplemented${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}install${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}isTestInstallImplemented${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}testInstall${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}isConfigureImplemented${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}configure${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}isTestConfigureImplemented${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}testConfigure${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}isCleanBeforeExportImplemented${__RESET_COLOR}"


  Array::wrap2 ' ' 76 6 "    Default value: " "install"
  echo

  # ------------------------------------------
  # options section
  # ------------------------------------------
  echo
  echo -e "${__HELP_TITLE_COLOR}SKIP OPTIONS:${__RESET_COLOR}"
  echo -e "  ${__HELP_OPTION_COLOR}--skip-config${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-configure${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-configuration${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-sc${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Skip software configuration."
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--skip-install${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-installation${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-si${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Skip software installation."
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--skip-test${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-tests${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-st${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Skip software installation test."
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--skip-deps${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-dependencies${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-sd${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Install the software requested without resolving dependencies."
  echo

  echo
  echo -e "${__HELP_TITLE_COLOR}EXPORT OPTIONS:${__RESET_COLOR}"
  echo -e "  ${__HELP_OPTION_COLOR}--prepare-export${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-e${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "prepare the wsl installation for export (remove all sensitive files)"
  echo

  echo
  echo -e "${__HELP_TITLE_COLOR}INSTALL OPTIONS:${__RESET_COLOR}"
  echo -e "  ${__HELP_OPTION_COLOR}--profile${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-p <profile>${__HELP_NORMAL} {single}"
  profileHelpFunction


  echo
  echo -e "${__HELP_TITLE_COLOR}GLOBAL OPTIONS:${__RESET_COLOR}"
  echo -e "  ${__HELP_OPTION_COLOR}--help${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-h${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Displays this command help"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--config${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Displays configuration"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--bash-framework-config <bash-framework-config>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Use alternate bash framework configuration."
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--verbose${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-v${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Info level verbose mode (alias of --display-level INFO)"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}-vv${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Debug level verbose mode (alias of --display-level DEBUG)"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}-vvv${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Trace level verbose mode (alias of --display-level TRACE)"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--log-level <log-level>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Set log level"
  echo

  echo "    Possible values: "
  echo -e "      - ${__OPTION_COLOR}OFF${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}ERR${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}ERROR${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}WARN${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}WARNING${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}INFO${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}DEBUG${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}TRACE${__RESET_COLOR}"

  Array::wrap2 ' ' 76 6 "    Default value: " "$(optionLogLevelDefaultValueFunction)"
  echo

  echo -e "  ${__HELP_OPTION_COLOR}--log-file <log-file>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Set log file"
  echo


  Array::wrap2 ' ' 76 6 "    Default value: " "$(optionLogFileDefaultValueFunction)"
  echo

  echo -e "  ${__HELP_OPTION_COLOR}--display-level <display-level>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Set display level"
  echo

  echo "    Possible values: "
  echo -e "      - ${__OPTION_COLOR}OFF${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}ERR${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}ERROR${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}WARN${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}WARNING${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}INFO${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}DEBUG${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}TRACE${__RESET_COLOR}"

  Array::wrap2 ' ' 76 6 "    Default value: " "$(optionDisplayLevelDefaultValueFunction)"
  echo

  echo -e "  ${__HELP_OPTION_COLOR}--no-color${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Produce monochrome output. alias of --theme noColor."
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--theme <theme>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Choose color theme - default-force means colors will be produced even if command is piped."
  echo

  echo "    Possible values: "
  echo -e "      - ${__OPTION_COLOR}default${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}default-force${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}noColor${__RESET_COLOR}"

  Array::wrap2 ' ' 76 6 "    Default value: " "default"
  echo

  echo -e "  ${__HELP_OPTION_COLOR}--version${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Print version information and quit."
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--quiet${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-q${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Quiet mode, doesn't display any output."
  echo

  # ------------------------------------------
  # longDescription section
  # ------------------------------------------
  echo
  echo
  echo -e "${__HELP_TITLE_COLOR}DESCRIPTION:${__RESET_COLOR}"
  helpLongDescriptionFunction
  # ------------------------------------------
  # version section
  # ------------------------------------------
  echo
  echo -n -e "${__HELP_TITLE_COLOR}VERSION: ${__RESET_COLOR}"
  echo "3.0"
  # ------------------------------------------
  # author section
  # ------------------------------------------
  echo
  echo -n -e "${__HELP_TITLE_COLOR}AUTHOR: ${__RESET_COLOR}"
  echo "[Franois Chastanet](https://github.com/fchastanet)"
  # ------------------------------------------
  # sourceFile section
  # ------------------------------------------
  echo
  echo -n -e "${__HELP_TITLE_COLOR}SOURCE FILE: ${__RESET_COLOR}"
  echo "https://github.com/fchastanet/bash-dev-env/tree/master/src/_installScripts/_Configs/ShellZshDefaultConfig-binary.yaml"
  # ------------------------------------------
  # license section
  # ------------------------------------------
  echo
  echo -n -e "${__HELP_TITLE_COLOR}LICENSE: ${__RESET_COLOR}"
  echo "MIT License"
  # ------------------------------------------
  # copyright section
  # ------------------------------------------
  Array::wrap2 ' ' 76 0 "$(copyrightCallback)"
}


beforeParseCallback

ShellZshDefaultConfigCommandParse "$@"
MAIN_FUNCTION_NAME="main"
main() {

afterParseCallback
InstallScripts::command

}

# if file is sourced avoid calling main function
# shellcheck disable=SC2178
BASH_SOURCE=".$0" # cannot be changed in bash
# shellcheck disable=SC2128
if test ".$0" == ".${BASH_SOURCE}"; then
  if [[ "${BASH_FRAMEWORK_QUIET_MODE:-0}" = "1" ]]; then
    main "$@" &>/dev/null
  else
    main "$@"
  fi
fi
