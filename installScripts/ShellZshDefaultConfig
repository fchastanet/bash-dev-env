#!/usr/bin/env bash
###############################################################################
# GENERATED FROM https://github.com/fchastanet/bash-dev-env/tree/master/src/_installScripts/_Configs/ShellZshDefaultConfig-binary.yaml
# DO NOT EDIT IT
# @generated
###############################################################################
# shellcheck disable=SC2288,SC2034



# ensure that no user aliases could interfere with
# commands used in this script
unalias -a || true
shopt -u expand_aliases

# shellcheck disable=SC2034
((failures = 0)) || true

# Bash will remember & return the highest exit code in a chain of pipes.
# This way you can catch the error inside pipes, e.g. mysqldump | gzip
set -o pipefail
set -o errexit

# Command Substitution can inherit errexit option since bash v4.4
shopt -s inherit_errexit || true

# if set, and job control is not active, the shell runs the last command
# of a pipeline not executed in the background in the current shell
# environment.
shopt -s lastpipe

# a log is generated when a command fails
set -o errtrace

# use nullglob so that (file*.php) will return an empty array if no file
# matches the wildcard
shopt -s nullglob

# ensure regexp are interpreted without accentuated characters
export LC_ALL=POSIX

export TERM=xterm-256color

# avoid interactive install
export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true

# store command arguments for later usage
# shellcheck disable=SC2034
declare -a BASH_FRAMEWORK_ARGV=("$@")
# shellcheck disable=SC2034
declare -a ORIGINAL_BASH_FRAMEWORK_ARGV=("$@")

# @see https://unix.stackexchange.com/a/386856
# shellcheck disable=SC2317
interruptManagement() {
  # restore SIGINT handler
  trap - INT
  # ensure that Ctrl-C is trapped by this script and not by sub process
  # report to the parent that we have indeed been interrupted
  kill -s INT "$$"
}
trap interruptManagement INT

################################################
# Temp dir management
################################################

KEEP_TEMP_FILES="${KEEP_TEMP_FILES:-0}"
export KEEP_TEMP_FILES

# PERSISTENT_TMPDIR is not deleted by traps
PERSISTENT_TMPDIR="${TMPDIR:-/tmp}/bash-framework"
export PERSISTENT_TMPDIR
if [[ ! -d "${PERSISTENT_TMPDIR}" ]]; then
  mkdir -p "${PERSISTENT_TMPDIR}"
fi

# shellcheck disable=SC2034
TMPDIR="$(mktemp -d -p "${PERSISTENT_TMPDIR:-/tmp}" -t bash-framework-$$-XXXXXX)"
export TMPDIR

# temp dir cleaning
# shellcheck disable=SC2317
cleanOnExit() {
  local rc=$?
  if [[ "${KEEP_TEMP_FILES:-0}" = "1" ]]; then
    Log::displayInfo "KEEP_TEMP_FILES=1 temp files kept here '${TMPDIR}'"
  elif [[ -n "${TMPDIR+xxx}" ]]; then
    Log::displayDebug "KEEP_TEMP_FILES=0 removing temp files '${TMPDIR}'"
    rm -Rf "${TMPDIR:-/tmp/fake}" >/dev/null 2>&1
  fi
  exit "${rc}"
}
trap cleanOnExit EXIT HUP QUIT ABRT TERM


SCRIPT_NAME=${0##*/}
REAL_SCRIPT_FILE="$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")"
if [[ -n "${EMBED_CURRENT_DIR}" ]]; then
  CURRENT_DIR="${EMBED_CURRENT_DIR}"
else
  CURRENT_DIR="${REAL_SCRIPT_FILE%/*}"
fi
FRAMEWORK_ROOT_DIR="$(cd "${CURRENT_DIR}/.." && pwd -P)"
FRAMEWORK_SRC_DIR="${FRAMEWORK_ROOT_DIR}/src"
FRAMEWORK_BIN_DIR="${FRAMEWORK_ROOT_DIR}/bin"
FRAMEWORK_VENDOR_DIR="${FRAMEWORK_ROOT_DIR}/vendor"
FRAMEWORK_VENDOR_BIN_DIR="${FRAMEWORK_ROOT_DIR}/vendor/bin"

# @description Log namespace provides 2 kind of functions
# - Log::display* allows to display given message with
#   given display level
# - Log::log* allows to log given message with
#   given log level
# Log::display* functions automatically log the message too
# @see Env::requireLoad to load the display and log level from .env file

# @description log level off
export __LEVEL_OFF=0
# @description log level error
export __LEVEL_ERROR=1
# @description log level warning
export __LEVEL_WARNING=2
# @description log level info
export __LEVEL_INFO=3
# @description log level success
export __LEVEL_SUCCESS=3
# @description log level debug
export __LEVEL_DEBUG=4

# @description verbose level off
export __VERBOSE_LEVEL_OFF=0
# @description verbose level info
export __VERBOSE_LEVEL_INFO=1
# @description verbose level info
export __VERBOSE_LEVEL_DEBUG=2
# @description verbose level info
export __VERBOSE_LEVEL_TRACE=3


# @description check if an element is contained in an array
#
# @arg $1 needle:String
# @arg $@ array:String[]
# @exitcode 0 if found
# @exitcode 1 otherwise
# @example
#   Array::contains "${libPath}" "${__BASH_FRAMEWORK_IMPORTED_FILES[@]}"
Array::contains() {
  local element
  for element in "${@:2}"; do
    [[ "${element}" = "$1" ]] && return 0
  done
  return 1
}


# @description concatenate each element of an array with a separator
# but wrapping text when line length is more than provided argument
# The algorithm will try not to cut the array element if it can.
# - if an arg can be placed on current line it will be,
#   otherwise current line is printed and arg is added to the new
#   current line
# - Empty arg is interpreted as a new line.
# - Add \r to arg in order to force break line and avoid following
#   arg to be concatenated with current arg.
#
# @arg $1 glue:String
# @arg $2 maxLineLength:int
# @arg $3 indentNextLine:int
# @arg $@ array:String[]
Array::wrap2() {
  local glue="${1-}"
  local -i glueLength="${#glue}"
  shift || true
  local -i maxLineLength=$1
  shift || true
  local -i indentNextLine=$1
  shift || true
  local indentStr=""
  if ((indentNextLine > 0)); then
    indentStr="$(head -c "${indentNextLine}" </dev/zero | tr '\0' " ")"
  fi
  if (($# == 0)); then
    return 0
  fi

  printCurrentLine() {
    if ((isNewline == 0)) || ((previousLineEmpty == 1)); then
      echo
    fi
    ((isNewline = 1))
    echo -en "${indentStr}"
    ((currentLineLength = indentNextLine)) || true
  }
  appendToCurrentLine() {
    local text="$1"
    local -i length=$2
    ((currentLineLength += length)) || true
    ((isNewline = 0)) || true
    if [[ "${text: -1}" = $'\r' ]]; then
      text="${text:0:-1}"
      echo -en "${text%%+([[:blank:]])}"
      printCurrentLine
    else
      echo -en "${text%%+([[:blank:]])}"
    fi
  }

  (
    local currentLine
    local -i currentLineLength=0 isNewline=1 argLength=0
    local -a additionalLines
    local -i previousLineEmpty=0
    local arg=""

    while (($# > 0)); do
      arg="$1"
      shift || true

      # replace tab by 2 spaces
      arg="${arg//$'\t'/  }"
      # remove trailing spaces
      arg="${arg%[[:blank:]]}"
      if [[ "${arg}" = $'\n' || -z "${arg}" ]]; then
        printCurrentLine
        ((previousLineEmpty = 1))
        continue
      else
        if ((previousLineEmpty == 1)); then
          printCurrentLine
        fi
        ((previousLineEmpty = 0)) || true
      fi
      # convert eol to args
      mapfile -t additionalLines <<<"${arg}"
      if ((${#additionalLines[@]} > 1)); then
        set -- "${additionalLines[@]}" "$@"
        continue
      fi

      ((argLength = ${#arg})) || true

      # empty arg
      if ((argLength == 0)); then
        if ((isNewline == 0)); then
          # isNewline = 0 means currentLine is not empty
          printCurrentLine
        fi
        continue
      fi

      if ((isNewline == 0)); then
        glueLength="${#glue}"
      else
        glueLength="0"
      fi
      if ((currentLineLength + argLength + glueLength > maxLineLength)); then
        if ((argLength + glueLength > maxLineLength)); then
          # arg is too long to even fit on one line
          # we have to split the arg on current and next line
          local -i remainingLineLength
          ((remainingLineLength = maxLineLength - currentLineLength - glueLength))
          appendToCurrentLine "${glue:0:${glueLength}}${arg:0:${remainingLineLength}}" "$((glueLength + remainingLineLength))"
          printCurrentLine
          arg="${arg:${remainingLineLength}}"
          # remove leading spaces
          arg="${arg##[[:blank:]]}"

          set -- "${arg}" "$@"
        else
          # the arg can fit on next line
          printCurrentLine
          appendToCurrentLine "${arg}" "${argLength}"
        fi
      else
        appendToCurrentLine "${glue:0:${glueLength}}${arg}" "$((glueLength + argLength))"
      fi
    done
    if [[ "${currentLine}" != "" ]] && [[ ! "${currentLine}" =~ ^[\ \t]+$ ]]; then
      printCurrentLine
    fi
  ) | sed -E -e 's/[[:blank:]]+$//'
}


# @description check if command specified exists or return 1
# with error and message if not
#
# @arg $1 commandName:String on which existence must be checked
# @arg $2 helpIfNotExists:String a help command to display if the command does not exist
#
# @exitcode 1 if the command specified does not exist
# @stderr diagnostic information + help if second argument is provided
Assert::commandExists() {
  local commandName="$1"
  local helpIfNotExists="$2"

  "${BASH_FRAMEWORK_COMMAND:-command}" -v "${commandName}" >/dev/null 2>/dev/null || {
    Log::displayError "${commandName} is not installed, please install it"
    if [[ -n "${helpIfNotExists}" ]]; then
      Log::displayInfo "${helpIfNotExists}"
    fi
    return 1
  }
  return 0
}


# @description check if param is valid email address
# @warning it is a very simple check, no RFC validation
# @arg $1 emailAddress:String the full email address
# @exitcode 1 if invalid email address
Assert::emailAddress() {
  local expectedRegexp="^\S+@\S+$"

  [[ "$1" =~ ${expectedRegexp} ]]
}


# @description asserts that first argument is file that exists with specified ownership
# @arg $1 file:String
# @arg $2 user:String expected owner user name of the file (default: USERNAME or id -un command)
# @arg $3 group:String expected owner group name of the file (default: USERGROUP or id -gn command)
# @env USERNAME String if arg $2 is not provided
# @env USERGROUP String if arg $3 is not provided
# @env SUDO String allows to use custom sudo prefix command
# @exitcode 1 if missing file
# @exitcode 2 if incorrect user ownership
# @exitcode 3 if incorrect group ownership
# @stderr diagnostics information is displayed
Assert::fileExists() {
  local file="$1"
  local user="${2:-${USERNAME}}"
  local group="${3:-${USERGROUP}}"
  if [[ -n "${user}" ]]; then
    Log::displayInfo "Check ${file} exists with user ${user}:${group}"
  else
    Log::displayInfo "Check ${file} exists"
  fi
  if ! ${SUDO:-} test -f "${file}" &>/dev/null; then
    Log::displayError "missing file ${file}"
    return 1
  fi
  if [[ -n "${user}" && "${user}" != "$(${SUDO:-} stat -c '%U' "${file}")" ]]; then
    Log::displayError "incorrect user ownership on file ${file}"
    return 2
  fi
  if [[ -n "${group}" && "${group}" != "$(${SUDO:-} stat -c '%G' "${file}")" ]]; then
    Log::displayError "incorrect group ownership on file ${file}"
    return 3
  fi
}


# @description check if argument respects 2 or more words separated by a space
# it supports accentuated characters and names with hyphen(-)
# @arg $1 firstNameLastName:String
# @exitcode 1 if regexp not matches
# @see https://regex101.com/r/JyyfOM/1
Assert::firstNameLastName() {
  local regexp="^[^ ]+([ ][^ ]+)+$"
  [[ $1 =~ ${regexp} ]]
}


# @description checks if function name provided exists
# @arg $1 functionName:String
# @exitcode 1 if function name doesn't exist
Assert::functionExists() {
  declare -F "$1" >/dev/null
}


# @description check if argument respects ldap login naming convention
# only using lowercase characters a-z
# @arg $1 ldapLogin:String
# @exitcode 1 if regexp not matches
Assert::ldapLogin() {
  [[ $1 =~ ^[a-z]+$ ]]
}


# @description check if tty (interactive mode) is active
# @noargs
# @exitcode 1 if tty not active
# @env NON_INTERACTIVE if 1 consider as not interactive even if environment is interactive
# @env INTERACTIVE if 1 consider as interactive even if environment is not interactive
Assert::tty() {
  if [[ "${NON_INTERACTIVE:-0}" = "1" ]]; then
    return 1
  fi
  if [[ "${INTERACTIVE:-0}" = "1" ]]; then
    return 0
  fi
  tty -s
}


# @description check if argument respects this framework variable naming convention
# - if variable begins with an uppercase or underscore, following letters have to be uppercase or underscore
# - variable name can includes ':' or '_' or digits but not as first letter
# here valid variable name examples
#
# @arg $1 variableName:String
# @exitcode 1 if regexp not matches
# @see https://regex101.com/r/BUlPXS/1
Assert::validVariableName() {
  [[ "$1" =~ (^[a-z][A-Za-z_0-9:]+$)|(^[A-Z_][A-Z_0-9:]+$) ]]
}


# @description checks if variable name provided exists
# @arg $1 varName:String
# @exitcode 1 if variable doesn't exist
# @exitcode 2 if variable value empty
# @exitcode 3 if variable name invalid
# @see Assert::validVariableName
# @stderr diagnostics information is displayed
Assert::varExistsAndNotEmpty() {
  local varName="$1"
  if ! Assert::validVariableName "${varName}"; then
    Log::displayError "${varName} - invalid variable name"
    return 3
  fi
  if [[ -z "${!varName+unset}" ]]; then
    Log::displayError "${varName} - not defined"
    return 1
  elif [[ -z "${!varName}" ]]; then
    Log::displayError "${varName} - please provide a value"
    return 2
  fi
}


# @description determine if the script is executed under WSL
# cspell:disable
# @example text
#   uname GitBash windows (with wsl) => MINGW64_NT-10.0 ZOXFL-6619QN2 2.10.0(0.325/5/3) 2018-06-13 23:34 x86_64 Msys
#   uname GitBash windows (wo wsl)   => MINGW64_NT-10.0 frsa02-j5cbkc2 2.9.0(0.318/5/3) 2018-01-12 23:37 x86_64 Msys
#   uname wsl => Linux ZOXFL-6619QN2 4.4.0-17134-Microsoft #112-Microsoft Thu Jun 07 22:57:00 PST 2018 x86_64 x86_64 x86_64 GNU/Linux
# cspell:enable
#
# @exitcode 1 on error
Assert::wsl() {
  [[ "$(uname -o)" = "GNU/Linux" ]]
}


# @description Backup given file in the same directory or in BACKUP_DIR directory
# backup file name is composed by following fields separated by -:
#   - if BACKUP_DIR is not empty then escaped dir name separated by @
#   - filename(without path)
#   - date with format %Y%m%d_%H:%M:%S (Eg: 20240326_14:45:08)
# @arg $1 file:String the file to backup
# @stderr messages about backup file location
# @env SUDO String allows to use custom sudo prefix command
# @env BACKUP_DIR if not set backup the file in the same directory as original file
# @exitcode 1 on copy failure
Backup::file() {
  local file="$1"
  if [[ -f "${file}" ]]; then
    local backupFile fileDirname escapedDirname
    fileDirname="${file%/*}"
    escapedDirname=${fileDirname/\//}      # remove first slash
    escapedDirname=${escapedDirname//\//@} # replace all slashes by @
    if [[ -z "${BACKUP_DIR:-}" ]]; then
      backupFile="${fileDirname}/${file##*/}-$(date +"%Y%m%d_%H:%M:%S")"
    else
      backupFile="${BACKUP_DIR}/${escapedDirname}@${file##*/}-$(date +"%Y%m%d_%H:%M:%S")"
    fi
    Log::displayInfo "Backup file '${file}' to ${backupFile}"
    ${SUDO:-} cp "${file}" "${backupFile}"
  fi
}


# @description get property value from file
# if not present compute it using propertyNotFoundCallback (if provided) and store it in property file
# @arg $1 propertyFile:String the file in which the property will be searched
# @arg $2 key:String the property key to search in property file
# @arg $3 propertyNotFoundCallback:Function (optional) a callback to call if property key is not found in property file
# @arg $@ args:String[] (optional) the arguments to pass to the propertyNotFoundCallback
# @exitcode 1 if value is not found
# @exitcode * if propertyNotFoundCallback fails
# @stdout the property value given by property file or by the propertyNotFoundCallback
Cache::getPropertyValue2() {
  local propertyFile="$1"
  local -n propertiesMap=$2
  local -n getPropertyValue2_val=$3
  local key="$4"
  local propertyNotFoundCallback=$5
  shift 5 || true
  local -a args=("$@")

  if [[ "${#propertiesMap[@]}" = "0" && -s "${propertyFile}" ]]; then
    local line
    while IFS="" read -r line; do
      if [[ "${line}" =~ ^([^=]+)=(.+)$ ]]; then
        propertiesMap["${BASH_REMATCH[1]}"]="${BASH_REMATCH[2]}"
      fi
    done <"${propertyFile}"
  fi

  if [[ -n "${propertiesMap[${key}]+abc}" ]]; then
    getPropertyValue2_val="${propertiesMap[${key}]}"
    return 0
  elif [[ "$(type -t "${propertyNotFoundCallback}")" = "function" ]]; then
    getPropertyValue2_val="$("${propertyNotFoundCallback}" "${args[@]}")" || return $?
    propertiesMap["${key}"]="${getPropertyValue2_val}"
    echo "${key}=${getPropertyValue2_val}" >>"${propertyFile}"
    return 0
  fi
  return 1
}


# @description convert base64 encoded back to target dir
# it is advised to include the md5sum of the binFile in the path of the target dir
#
# @arg $1 targetDir:string the directory in which tar archive will be untarred
# @arg $2 base64:string the base64 encoded tar czf archive
# @stderr diagnostics information is displayed
Compiler::Embed::extractDirFromBase64() {

  if [[ "${REQUIRE_FUNCTION_LINUX_REQUIRE_TAR_COMMAND_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::requireTarCommand has not been loaded"
    exit 1
  fi

  local targetDir="$1"
  local base64="$2"

  if [[ ! -d "${targetDir}" ]]; then
    mkdir -p "${targetDir}"
    (
      cd "${targetDir}" || exit 1
      base64 -d <<<"${base64}" | tar -xzf - 2>/dev/null || {
        Log::displayError "untar failure, invalid base64 string"
        exit 1
      }
    ) || return 1
  fi
}


# @description convert base64 encoded back to target file
# if target file is executable prepend dir of target
# file to PATH to make binary available everywhere
# it is advised to include in the path of the target file
# the md5sum of the binFile
#
# @arg $1 targetFile:String the file to write
# @arg $2 binFileBase64:String the base64 encoded file
# @arg $3 fileMode:String the chmod to set on the file
# @set PATH String prepend target embedded file binary directory to PATH variable if binary executable
Compiler::Embed::extractFileFromBase64() {
  local targetFile="$1"
  local binFileBase64="$2"
  local fileMode="${3:-+x}"
  local targetDir="${targetFile%/*}"

  if [[ ! -f "${targetFile}" ]]; then
    if [[ ! -d "${targetDir}" ]]; then
      mkdir -p "${targetDir}"
    fi
    base64 -d >"${targetFile}" <<<"${binFileBase64}"
    chmod "${fileMode}" "${targetFile}"
  fi

  if [[ -x "${targetFile}" ]]; then
    Env::pathPrepend "${targetDir}"
  fi
}


# @description copy folder structure to target directory
# merge embedDir with overridden directory if provided and available
# @arg $1 embedDir:String the path embedded
# @arg $2 overrideDir:String the path overridden
# @arg $3 subDir:String the sub-directory to copy from embedDir and/or overrideDir
# @arg $4 targetDir:String the target directory (default: ${HOME}/${subDir})
# @env SUDO String allows to use custom sudo prefix command
# @env HOME used for default value of targetDir arg
# @env OVERWRITE_CONFIG_FILES indicates if target directory should be overwritten if it exists
# @env PRETTY_ROOT_DIR used to make paths relative to this directory to reduce length of messages
# @env IGNORE_MISSING_SOURCE_DIR
Conf::copyStructure() {
  local embedDir="$1"
  local overrideDir="$2"
  local subDir="$3"
  local targetDir="${4:-${HOME}/${subDir}}"

  local configDir
  # shellcheck disable=SC2154
  configDir="$(Conf::getOverriddenDir "${embedDir}" "${overrideDir}")"
  if [[ -d "${configDir}/${subDir}" ]]; then
    # shellcheck disable=SC2154
    OVERWRITE_CONFIG_FILES=${OVERWRITE_CONFIG_FILES:-1} \
      PRETTY_ROOT_DIR="${embedDir%/*}" \
      Install::structure "${configDir}/${subDir}" "${targetDir}"
  elif [[ "${IGNORE_MISSING_SOURCE_DIR:-0}" = "1" ]]; then
    return 0
  else
    Log::displayError "Directory ${subDir} does not exists in '${embedDir}' or '${overrideDir}'"
    return 1
  fi
}


# @description select right file to load depending if file exists in this order:
# - from conf.override
# - from embedded file if provided
# - from conf dir
# @arg $1 file:String
# @arg $2 embedFile:String eventual embedded file
# @exitcode 1 if file does not exist at all
Conf::dynamicConfFile() {
  local file="${1/#\//}" # remove first slash if any
  local embedFile="${2:-}"
  if [[ -f "${CONF_OVERRIDE_DIR}/${file}" ]]; then
    echo "${CONF_OVERRIDE_DIR}/${file}"
    return 0
  elif [[ -f "${embedFile}" ]]; then
    echo "${embedFile}"
    return 0
  fi
  if [[ "${IGNORE_ERROR:-0}" = "0" ]]; then
    Log::displayWarning "Conf::dynamicConfFile - ${file} does not exist in any config dirs declared"
    return 1
  fi
}


# @description generate temp directory where default
# and overridden directories have been merged
#   - if overridden dir exists, create a new temp folder
#     - copy all files from default folder
#     - overwrite with files from overridden folder
#     - (Later) delete files listed in .remove$$ file
#     - return the path of this temp folder
#   - else just return the default folder path
# Then it is easier to pick overridden or default files/folders
#
# @arg $1 defaultDir:String usually the embed directory
# @arg $2 overriddenDirPath:String the path to the directory
#   that could be overridden
# @exitcode 1 if default dir does not exist
# @exitcode 2 if error during copy
Conf::getOverriddenDir() {
  local defaultDir="$1"
  local overriddenDirPath="$2"

  if [[ ! -d "${defaultDir}" ]]; then
    Log::displayError "Directory ${defaultDir} does not exists"
    return 1
  fi
  if [[ ! -d "${overriddenDirPath}" || -z "$(ls -A "${overriddenDirPath}")" ]]; then
    Log::displayInfo "Conf::getOverriddenDir - directory ${overriddenDirPath} does not exist, keep default one ${defaultDir}"
    echo "${defaultDir}"
    return 0
  fi
  local tempDir
  tempDir="$(mktemp -d)"
  (
    shopt -s dotglob
    cp -R "${defaultDir}/." "${tempDir}"
    cp -R "${overriddenDirPath}/." "${tempDir}"
  ) || return 2
  echo "${tempDir}"
}


# @description check validity of .env variables
# @env CHECK_ENV int 0 to avoid checking environment
# @noargs
Engine::Config::checkEnv() {
  local envFile="$1"
  if [[ "${CHECK_ENV:-1}" = "0" ]]; then
    return 0
  fi
  # avoid checks if .env file didn't changed
  local envFileMd5Cache="${PERSISTENT_TMPDIR:-/tmp}/bash-dev-env-enf-file-checksum"
  if md5sum -c "${envFileMd5Cache}" &>/dev/null; then
    return 0
  else
    md5sum "${envFile}" >"${envFileMd5Cache}"
  fi
  local errorCount=0 || true
  checkNotEmpty() {
    local var="$1"
    if ! Assert::varExistsAndNotEmpty "${var}"; then
      ((++errorCount))
      return 1
    fi
  }
  checkVarAndDir() {
    local var="$1"
    local mode="${2:-}"
    local status=0
    if checkNotEmpty "${var}"; then
      if [[ ! -d "${!var}" ]] && ! mkdir -p "${!var}"; then
        Log::displayError "variable ${var} - impossible to create the directory '${!var}'"
        ((errorCount++))
        return 1
      fi
      if [[ "${mode}" =~ w && ! -w "${!var}" ]]; then
        Log::displayError "variable ${var} - directory '${!var}' is not writable"
        ((status++))
        ((errorCount++))
      fi
      if [[ "${mode}" =~ r && ! -r "${!var}" ]]; then
        Log::displayError "variable ${var} - directory '${!var}' is not accessible"
        ((status++))
        ((errorCount++))
      fi
    fi

    return "${status}"
  }
  checkValidValues() {
    local var="$1"
    shift || true
    local -a validValues=("$@")
    if ! Array::contains "${!var}" "${validValues[@]}"; then
      Log::displayError "variable ${var} - value ${!var} is not part of the following values ${validValues[*]}"
      ((++errorCount))
    fi
  }

  if ! echo "${ID}" | grep -qEw 'debian|ubuntu'; then
    Log::fatal "This script is built to support only Debian or Ubuntu distributions. You are using ${ID}."
  fi

  if checkNotEmpty USERNAME && ! getent passwd "${USERNAME}" 2>/dev/null >/dev/null; then
    Log::displayError "USERNAME - user '${USERNAME}' does not exist"
    ((errorCount++))
  fi

  if [[ -n "${SSH_LOGIN:-}" ]] && ! Assert::ldapLogin "${SSH_LOGIN}"; then
    Log::displayError "SSH_LOGIN - invalid ldap login (format expected firstNameLastName) in ${BASH_DEV_ENV_ROOT_DIR}/.env file"
    ((errorCount++))
  fi

  if checkNotEmpty "GIT_USERNAME" && ! Assert::firstNameLastName "${GIT_USERNAME}"; then
    Log::displayError "GIT_USERNAME - invalid format, expected : firstName lastName"
    ((errorCount++))
  fi

  if checkNotEmpty "GIT_USER_MAIL" && ! Assert::emailAddress "${GIT_USER_MAIL}"; then
    Log::displayError "GIT_USER_MAIL - invalid email address"
    ((errorCount++))
  fi

  if checkNotEmpty "AWS_USER_MAIL" && ! Assert::emailAddress "${AWS_USER_MAIL}"; then
    Log::displayError "AWS_USER_MAIL - invalid email address"
    ((errorCount++))
  fi

  checkVarAndDir CONF_OVERRIDE_DIR r || true
  checkVarAndDir PROJECTS_DIR r || true
  checkVarAndDir BACKUP_DIR rw || true
  checkVarAndDir LOGS_DIR rw || true
  checkVarAndDir INSTALL_SCRIPTS_ROOT_DIR r || true
  checkVarAndDir HOME rw || true

  checkValidValues UPGRADE_UBUNTU_VERSION 0 lts dev
  checkValidValues PREFERRED_SHELL ShellBash ShellZsh
  checkValidValues ZSH_PREFERRED_THEME powerlevel10k/powerlevel10k sindresorhus/pure starship/starship

  checkValidValues SHOW_FORTUNES 0 1
  checkValidValues SHOW_MOTD 0 1
  checkValidValues OVERWRITE_CONFIG_FILES 0 1
  checkValidValues CHANGE_WINDOWS_FILES 0 1
  checkValidValues CAN_TALK_DURING_INSTALLATION 0 1
  checkValidValues INSTALL_INTERACTIVE 0 1

  checkNotEmpty WSLCONFIG_MAX_MEMORY
  checkValidValues WSLCONFIG_SWAP 0 1
  export CHECK_ENV=0
  return "${errorCount}"
}


# @description if .env does not exist, initialize it with .env.template
Engine::Config::createEnvFileFromTemplate() {
  local envFile="$1"
  local envFileTemplate="$2"

  if [[ ! -f "${envFile}" ]]; then
    echo "${envFileTemplate}" >"${envFile}"
    Log::displayError "a default env file has been created, please edit ${envFile}"
    return 1
  fi
}


# @description load .env file
# @arg $1 envFile:String the file to load
Engine::Config::loadConfig() {
  if [[ "${BASH_DEV_ENV_CONFIG_LOADED:-0}" = "1" ]]; then
    return 0
  fi
Linux::requireTarCommand
Compiler::Embed::extractFileFromBase64 \
  "${PERSISTENT_TMPDIR:-/tmp}/2d460e9c1bb95b79effe0eff168b6276ae2f425de780f9369eda1a14e888ed7c/envFileTemplate" \
  "IyEvYmluL2Jhc2gKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0CgojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiMgR2VuZXJhbCBpbmZvcm1hdGlvbgojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgojIHdzbCB1c2VybmFtZSB3aXRoIGRlZmF1bHQgcGFzc3dvcmQgd3NsClVTRVJOQU1FPSJ3c2wiCgpIT01FPSIvaG9tZS93c2wiCgpXSU5ET1dTX1VTRVJOQU1FPSJmY2hhc3RhbmV0IgoKIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQojIEdpdCAmIFNTSCBpbmZvcm1hdGlvbgojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgojIGlmIDEsIGl0IGluZGljYXRlcyB5b3UgYWNjZXB0IHRoYXQgeW91ciBnaXQga2V5IHdpbGwgYmUgbG9hZGVkLgojIGlmIDAsIGNvbmZpZ3VyYXRpb25zIHRoYXQgbmVlZCB0byBiZSBhdXRoZW50aWNhdGVkIHdpbGwgYmUgc2tpcHBlZC4KIyBEaXN0cm8gbW9kZTogaW4gYW55IGNhc2UsIHlvdXIga2V5IGlzIG5vdCBjb3BpZWQuCkFVVEhPUklaRV9TU0hfS0VZX1VTQUdFPTEKCiMgeW91ciBsb2dpbiB0byBjb25uZWN0IHRvIHNzaCBzZXJ2ZXJzIGlmIGFueQpTU0hfTE9HSU49IiIKCiMgeW91ciBnaXQgZnVsbCBuYW1lICdGaXJzdE5hbWUgTGFzdE5hbWUnCkdJVF9VU0VSTkFNRT0iIgoKIyBlbWFpbCB1c2VkIGZvciBnaXQgJ2xkYXBAZG9tYWluLmNvbScKR0lUX1VTRVJfTUFJTD0iIgoKIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQojIEFXUyBpbmZvcm1hdGlvbgojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgojIGVtYWlsIHVzZWQgdG8gY29ubmVjdCB0byBhd3MKQVdTX1VTRVJfTUFJTD0iZmNoYXN0YW5ldEBnbWFpbC5jb20iCgojIGFwcCBpZCB0byBjb25uZWN0IHRvIGF3cyBhY2NvdW50CkFXU19BUFBfSUQ9IiIKCkFXU19QUk9GSUxFPSIiCkFXU19ERUZBVUxUX1JFR0lPTj0iIgpBV1NfVEVTVF9TRUNSRVRfSUQ9IiIKQVdTX0RFRkFVTFRfRE9DS0VSX1JFR0lTVFJZX0lEPSIiCgojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiMgSzhTIGluZm9ybWF0aW9uCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiMgS3ViZURlZmF1bHRDb25maWcgfi8ua3ViZS9jb25maWcgZ2VuZXJhdGlvbgojIGF3cyByZWdpb24gb2YgdGhlIGNsdXN0ZXIgKEVnOiB1cy1lYXN0LTEpCktVQkVfQ09ORklHX1JFR0lPTl9DT0RFPQoKIyBhd3MgYXJuIG9mIHRoZSBjbHVzdGVyLgojIEVnOiBhcm46YXdzOmVjczpyZWdpb246YXdzX2FjY291bnRfaWQ6Y2x1c3Rlci9NeUNsdXN0ZXIKS1VCRV9DT05GSUdfQ0xVU1RFUl9BUk49CgojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiMgRGlyZWN0b3JpZXMKIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyBvdmVycmlkZGVuIGNvbmYgZGlyZWN0b3J5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIG92ZXJyaWRlCiMgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiB0aGF0IGFyZSBlbWJlZGRlZCBpbiBiaW5hcmllcwpDT05GX09WRVJSSURFX0RJUj0iJHtCQVNIX0RFVl9FTlZfUk9PVF9ESVJ9L2NvbmYub3ZlcnJpZGUiCgojIHdoZXJlIHRvIGluc3RhbGwgYmFzaC10b29scywgLi4uCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjE1MwpQUk9KRUNUU19ESVI9IiR7SE9NRX0vcHJvamVjdHMiCgojIHdoZXJlIG92ZXJyaWRkZW4gY29uZmlnIGZpbGVzIHdpbGwgYmUgYmFja2VkIHVwCkJBQ0tVUF9ESVI9IiR7QkFTSF9ERVZfRU5WX1JPT1RfRElSfS9iYWNrdXAiCiMgYmFja3VwIGZpbGVzL2RpcnMgYmVmb3JlIGluc3RhbGxpbmcgbmV3IGZpbGUgKHVzdWFsbHkgMSwgYnV0IDAgaWYgdXNpbmcgZGlzdHJvKQpCQUNLVVBfQkVGT1JFX0lOU1RBTEw9MQoKIyBsb2dzIGRpcmVjdG9yeQpMT0dTX0RJUj0iJHtCQVNIX0RFVl9FTlZfUk9PVF9ESVJ9L2xvZ3MiCgojIGluc3RhbGxTY3JpcHRzIHJvb3QgZGlyCklOU1RBTExfU0NSSVBUU19ST09UX0RJUj0iJHtCQVNIX0RFVl9FTlZfUk9PVF9ESVJ9L2luc3RhbGxTY3JpcHRzIgoKIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQojIEluc3RhbGxhdGlvbiBjb25maWd1cmF0aW9uCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiMgQ29uZmlndXJhdGlvbiBmaWxlcyBhcmUgb3ZlcndyaXR0ZW4gZXZlbiBpZiBleGlzdHMKIyAhISEhIEZpcnN0IHRpbWUgaW5pdGlhbGl6YXRpb246IGxldCB0aGlzIHZhbHVlIHRvIDEgISEhIQojIFZhbHVlIDA6CiMgLSBJZiB0YXJnZXQgY29uZmlndXJhdGlvbiBmaWxlIGV4aXN0cywgZGlzcGxheXMgYSBtZXNzYWdlIGFuZCBkbyBub3Qgb3ZlcndyaXRlIHRoZSBmaWxlCiMgLSBJZiB0YXJnZXQgY29uZmlndXJhdGlvbiBmaWxlIGRvZXNuJ3QgZXhpc3QsIGluc3RhbGxzIHRoZSBmaWxlCiMgVmFsdWUgMQojIC0gaW5zdGFsbCBvciBvdmVyd3JpdGUgdGhlIGZpbGUgd2l0aG91dCBjaGVja2luZyBleGlzdGVuY2UKT1ZFUldSSVRFX0NPTkZJR19GSUxFUz0xCgojIFdpbmRvd3MgZmlsZXMgY2FuIGJlIG92ZXJyaWRkZW4gaWYgMQojIGlmIDAKIyAtIHNraXAgY2hhbmdlcyB0byAlVVNFUlBST0ZJTEUlLy53c2xjb25maWcKIyAtIHNraXAgY29weWluZyBmb250cwpDSEFOR0VfV0lORE9XU19GSUxFUz0xCgojIEluZGljYXRlIHRoYXQgaW5zdGFsbCBzY3JpcHQgY2FuIHdhcm4geW91IHVzaW5nIHNwZWFrZXIgd2hlbiB5b3VyIGlucHV0IGlzIG5lZWRlZApDQU5fVEFMS19EVVJJTkdfSU5TVEFMTEFUSU9OPTEKCiMgaWYgMCBpbnN0YWxsIHNjcmlwdCB3aWxsIHNraXAgYWxsIGludGVyYWN0aXZlIGFjdGl2aXR5IChzYW1sMmF3cywgLi4uKSwKIyBzbyBkZXBlbmRlbnQgaW5zdGFsbGF0aW9uIHdpbGwgYmUgc2tpcHBlZCBhcyB3ZWxsCklOU1RBTExfSU5URVJBQ1RJVkU9MQoKIyBkaXNwbGF5IGVsYXBzZWQgdGltZSBzaW5jZSBsYXN0IGxvZwpESVNQTEFZX0RVUkFUSU9OPTEKCiMgMCAgID0+IG5vIHVwZ3JhZGUgYXQgYWxsCiMgbHRzID0+IFVQR1JBREUgdG8gbGF0ZXN0IHVidW50dSBsdHMgdmVyc2lvbgojIGRldiA9PiBVUEdSQURFIHRvIGxhdGVzdCB1YnVudHUgZGV2IHZlcnNpb24KIyBVc2UgaWYgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLAojIGNvdWxkIGNhdXNlIHNvbWUgcGFja2FnZXMgdG8gbm90IGJlaW5nIGF2YWlsYWJsZSB5ZXQKVVBHUkFERV9VQlVOVFVfVkVSU0lPTj0wCgojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiMgUHJvZmlsZSBjb25maWd1cmF0aW9uCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiMgQ2hvb3NlIHlvdXIgcHJlZmVycmVkIHNoZWxsCiMgcG9zc2libGUgY2hvaWNlczogU2hlbGxCYXNoIChMZWdhY3kgZXhwZXJpZW5jZSksIFNoZWxsWnNoIChSZWNvbW1lbmRlZCBleHBlcmllbmNlKQpQUkVGRVJSRURfU0hFTEw9IlNoZWxsWnNoIgoKIyBac2ggdGhlbWUgdG8gdXNlCiMgcG9zc2libGUgY2hvaWNlczogcG93ZXJsZXZlbDEway9wb3dlcmxldmVsMTBrLCBzaW5kcmVzb3JodXMvcHVyZSwgc3RhcnNoaXAvc3RhcnNoaXAKWlNIX1BSRUZFUlJFRF9USEVNRT0icG93ZXJsZXZlbDEway9wb3dlcmxldmVsMTBrIgoKIyBEaXNwbGF5IEZvcnR1bmUgdG9vbHRpcCBhdCBiYXNoL3pzaCBzZXNzaW9uIG9wZW4KU0hPV19GT1JUVU5FUz0xCgojIERpc3BsYXkgTU9URCBhdCBiYXNoL3pzaCBzZXNzaW9uIG9wZW4KU0hPV19NT1REPTEKCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KIyBXU0xDT05GSUcKIyBUaGVzZSBwYXJhbWV0ZXJzIGF1dG9tYXRpY2FsbHkgY29uZmlndXJlICVVU0VSUFJPRklMRSUvLndzbGNvbmZpZyBmaWxlLgojIEBzZWUgaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvd2luZG93cy93c2wvd3NsLWNvbmZpZwojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgojIFJlY29tbWVuZGVkIDUwJSBvZiB0b3RhbCBtZW1vcnkKV1NMQ09ORklHX01BWF9NRU1PUlk9OEdCCgojIHBlcnNvbmFsbHkgSSBwcmVmZXIgcnVuIG91dCBvZiBtZW1vcnkgaW5zdGVhZCBvZiBiZWdpbm5pbmcgc3dhcHBpbmcKIyBTbyBJIGtub3cgaW1tZWRpYXRlbHkgaWYgc29tZSBwcm9jZXNzZXMgaGF2ZSB0byBiZSBzdG9wcGVkCldTTENPTkZJR19TV0FQPTAKCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KIyBIYWNrcwojIG9uIHNvbWUgY29uZmlndXJhdGlvbnMgd2UgaGF2ZSB0byBmb3JjZSBwYXRoIG9mIHNvbWUgd2luZG93cyBjb21tYW5kcwojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgojUE9XRVJTSEVMTF9CSU49L21udC9jL1dpbmRvd3MvU3lzdGVtMzIvV2luZG93c1Bvd2VyU2hlbGwvdjEuMC9wb3dlcnNoZWxsLmV4ZQojSVBDT05GSUdfQklOPS9tbnQvYy9XaW5kb3dzL3N5c3RlbTMyL2lwY29uZmlnLmV4ZQojV1NMX0VYRV9CSU49L21udC9jL1dpbmRvd3Mvc3lzdGVtMzIvd3NsLmV4ZQoKIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQojIEdlbmVyYWwgZGlzdHJpYnV0aW9uIGluZm9ybWF0aW9uCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiMgaG9zdG5hbWUgb2YgdGhlIGRpc3RybwpESVNUUk9fSE9TVE5BTUU9IndzbEhvc3QiCg==" \
  "755"

declare -gx embed_file_envFileTemplate="${PERSISTENT_TMPDIR:-/tmp}/2d460e9c1bb95b79effe0eff168b6276ae2f425de780f9369eda1a14e888ed7c/envFileTemplate"

  local envFile="${BASH_DEV_ENV_ROOT_DIR}/.env"
  # shellcheck disable=SC2154
  Engine::Config::createEnvFileFromTemplate \
    "${envFile}" "${embed_file_envFileTemplate}" || exit 1
  set -o allexport
  # shellcheck source=/.env.template
  source <(echo "${embed_file_envFileTemplate}")
  # shellcheck source=/.env
  source "${BASH_DEV_ENV_ROOT_DIR}/.env"
  set +o allexport
  export STATS_DIR="${LOGS_DIR}/stats"
  if [[ ! -d "${STATS_DIR}" ]]; then
    mkdir -p "${STATS_DIR}" || true
  fi
  export LOGS_INSTALL_SCRIPTS_DIR="${LOGS_DIR}/installScripts"
  if [[ ! -d "${LOGS_INSTALL_SCRIPTS_DIR}" ]]; then
    mkdir -p "${LOGS_INSTALL_SCRIPTS_DIR}" || true
  fi

  # load environment variables ID, VERSION_CODENAME
  Engine::Config::loadOsRelease
  Engine::Config::loadUserVariables

  if ! Engine::Config::checkEnv "${BASH_DEV_ENV_ROOT_DIR}/.env"; then
    Log::displayError "one or more variables are invalid, check above logs and fix '${envFile}' file accordingly"
    return 1
  fi

  Engine::Config::loadHostIp

  Engine::Config::requireWslu

  #Linux::Wsl::initEnv
  Engine::Config::loadWslVariables

  Log::requireLoad

  Engine::Config::loadSshKey

  Engine::Config::loadLocaleConfig

  export BASH_DEV_ENV_CONFIG_LOADED=1
}


# @description deduce wsl host ip
# @set HOST_IP exported env containing the IP
Engine::Config::loadHostIp() {
  HOST_IP="$(/sbin/ip route | awk '/default/ { print $3 }')"

  export HOST_IP
}


# @description load locale configuration
Engine::Config::loadLocaleConfig() {
  if [[ "${BASH_DEV_ENV_CONFIG_LOADED:-0}" = "1" ]]; then
    return 0
  fi
  if [[ "${LOAD_LOCALE_CONFIG:-1}" = "1" && ! -f "${PERSISTENT_TMPDIR}/localeConfig.initialized" ]]; then
    Log::displayInfo "Initializing locale en_US.UTF-8"
    export PATH="${PATH}:${HOME}/.local/bin"
    sudo sed -E -i -e 's/# en_US.UTF-8 UTF-8/en_US.UTF-8 UTF-8/' /etc/locale.gen
    echo 'LANG="en_US.UTF-8"' | sudo tee /etc/default/locale >/dev/null
    echo "LANG=en_US.UTF-8" | sudo tee /etc/locale.conf >/dev/null
    sudo locale-gen en_US.UTF-8
    sudo dpkg-reconfigure --frontend=noninteractive locales
    export LC_ALL=C
    export LANG=en_US.UTF-8
    export LC_MESSAGES=en_US.UTF-8
    touch "${PERSISTENT_TMPDIR}/localeConfig.initialized"
  fi
}


# @description load /etc/os-release file
# @set NAME
# @set VERSION
# @set ID
# @set ID_LIKE
# @set PRETTY_NAME
# @set VERSION_ID
# @set HOME_URL
# @set SUPPORT_URL
# @set BUG_REPORT_URL
# @set PRIVACY_POLICY_URL
# @set VERSION_CODENAME
# @set UBUNTU_CODENAME
Engine::Config::loadOsRelease() {
  if [[ ! -f /etc/os-release ]]; then
    Log::displayError "file /etc/os-release does not exists"
    return 1
  fi
  # This will load environment variables ID, VERSION_CODENAME, ...
  set -o allexport
  source /etc/os-release
  set +o allexport
}


# @description load pageant and ssh key
# you can provide ssh key by env variable SSH_PRIVATE_KEY
# or if empty, file ~/.ssh/id_rsa will be used if present
# @env SSH_PRIVATE_KEY ssh key provided by env variable
# @env AUTHORIZE_SSH_KEY_USAGE if 0, no ssh key is loaded
# @env LOAD_SSH_KEY feature flag used in distro mode
Engine::Config::loadSshKey() {
  if [[ "${LOAD_SSH_KEY:-1}" = "0" ]]; then
    # ignore in distro mode
    return 0
  fi
  if [[ "${AUTHORIZE_SSH_KEY_USAGE:-0}" = "0" ]]; then
    Log::displaySkipped "Ssh key will not be loaded as you set AUTHORIZE_SSH_KEY_USAGE to 0"
    return 0
  fi
  if [[ -n "${SSH_AUTH_SOCK}" && -n "${SSH_AGENT_PID}" ]]; then
    Log::displaySkipped "Ssh agent skipped as variables SSH_AUTH_SOCK and SSH_AGENT_PID are set"
    return 0
  fi

  if [[ -z "${SSH_PRIVATE_KEY}" && ! -f "${HOME}/.ssh/id_rsa" ]]; then
    Log::displayError "File '${HOME}/.ssh/id_rsa' is missing and env variable SSH_PRIVATE_KEY is empty"
    return 1
  fi
  local errorCode=0
  ssh-add -l &>/dev/null || errorCode=$?
  if [[ "${errorCode}" = "2" ]]; then
    # ssh agent is not started
    Log::displayInfo "Starting ssh agent"
    eval "$(ssh-agent)" || return 2
    export SSH_AUTH_SOCK
    export SSH_AGENT_PID
  fi

  if [[ -z "${SSH_PRIVATE_KEY}" ]]; then
    ssh-add "${HOME}/.ssh/id_rsa" || return 3
  else
    ssh-add <(base64 -d <<<"${SSH_PRIVATE_KEY}") || return 3
  fi

  # Check key has been added to ssh agent
  ssh-add -l &>/dev/null || {
    Log::displayError "Your ssh key has not been loaded"
    return 4
  }
}


# @description deduce HOME, USER_ID, USERGROUP_ID and USERGROUP from USERNAME
# @env USERNAME String the name of the user
# @set USER_ID String
# @set USERGROUP String
# @set USERGROUP_ID String
# @set USER_SHELL String current user shell
# @set HOME String
# @env REMOTE String prefix command to run commands remotely
Engine::Config::loadUserVariables() {
  # deduce user home and group
  local -a split
  local IFS=':'
  # shellcheck disable=SC2207
  split=($(${REMOTE:-} getent passwd "${USERNAME}"))
  USER_ID="${split[2]}"
  USERGROUP_ID="${split[3]}"
  HOME="${split[5]}"
  USER_SHELL="${split[6]}"
  USERGROUP="$(${REMOTE:-} id -gn "${USERNAME}")"

  if [[ -z "${USERGROUP}" || -z "${HOME}" ]]; then
    Log::displayError "USERNAME - unable to deduce USERGROUP, HOME from USERNAME"
    return 1
  fi

  export HOME
  export USER_ID
  export USERGROUP_ID
  export USERGROUP
  export USER_SHELL
}


# @description load wsl env variables
# @set BASE_MNT_C
# @set WINDOWS_DIR
# @set WINDOWS_PROFILE_DIR
# @set LOCAL_APP_DATA
# @set WINDOW_PATH
# @set WSL_EXE_BIN
# @set IPCONFIG_BIN
# @set POWERSHELL_BIN
# @env WSL_EXE_BIN
# @env IPCONFIG_BIN
# @env POWERSHELL_BIN
Engine::Config::loadWslVariables() {
  if ! Assert::wsl; then
    # skip
    return 0
  fi

  local IFS=' '
  local -a split=()
  # shellcheck disable=SC2207
  split=($(grep -m 1 -E 'C:\\[^ ]+ ([^ ]+) ' /proc/mounts 2>/dev/null)) || {
    # probably not wsl after all
    return 0
  }
  # shellcheck disable=SC1003
  BASE_MNT_C="${split[1]}"
  export BASE_MNT_C

  Linux::Wsl::cachedWslpathFromWslVar2 WINDOWS_DIR SystemRoot
  WINDOWS_DIR="${WINDOWS_DIR:-${BASE_MNT_C:-/mnt/c}/Windows}"
  export WINDOWS_DIR

  Linux::Wsl::cachedWslpathFromWslVar2 WINDOWS_PROFILE_DIR USERPROFILE
  WINDOWS_PROFILE_DIR="${WINDOWS_PROFILE_DIR:-${BASE_MNT_C:-/mnt/c}/Users/${WINDOWS_USERNAME}}"
  export WINDOWS_PROFILE_DIR

  Linux::Wsl::cachedWslpathFromWslVar2 LOCAL_APP_DATA LOCALAPPDATA
  export LOCAL_APP_DATA

  # WINDOW_PATH
  Linux::Wsl::cachedWslvar2 WINDOW_PATH PATH
  WINDOW_PATH="${WINDOW_PATH//;/:}"
  WINDOW_PATH="${WINDOW_PATH//\\//}"
  WINDOW_PATH="${WINDOW_PATH//C:/${BASE_MNT_C:-/mnt/c}}"

  deduceBin() {
    local var="$1"
    local expectedFullPath="$2"
    local expectedBin="$3"
    if [[ -z "${!var+xxx}" ]]; then
      eval "${var}=${expectedFullPath}"
      if ! command -v "${!var}" >/dev/null 2>&1; then
        eval "${var}=$(command -v "${expectedBin}" 2>/dev/null)"
      fi
    fi
    if [[ -z "${!var:-}" ]] || ! command -v "${!var}" >/dev/null 2>&1; then
      Log::fatal "variable ${var} - command ${expectedBin} not found"
    fi
    # shellcheck disable=SC2163
    export "${var}"
  }

  checkBinary() {
    local var="$1"
    if [[ -z "${var}" || ! -x "${!var}" ]]; then
      Log::displayError "variable ${var} - binary '${!var}' does not exist or not executable"
      ((errorCount++))
    fi
  }

  local errorCount=0
  # IPCONFIG_BIN - which ipconfig.exe does not work when executed as root
  deduceBin IPCONFIG_BIN "${WINDOWS_DIR}/System32/ipconfig.exe" "ipconfig.exe"
  checkBinary IPCONFIG_BIN

  deduceBin WSL_EXE_BIN "${WINDOWS_DIR}/System32/wsl.exe" "wsl.exe"
  checkBinary WSL_EXE_BIN

  deduceBin POWERSHELL_BIN "${WINDOWS_DIR}/System32/WindowsPowerShell/v1.0/powershell.exe" "powershell.exe"
  checkBinary POWERSHELL_BIN

  return "${errorCount}"
}


# @description install apt wslu if necessary providing wslvar, wslpath
Engine::Config::requireWslu() {
  if [[ "${LOAD_WSLU:-1}" = "0" ]]; then
    return 0
  fi
  if ! command -v wslvar &>/dev/null; then
    Log::displayInfo "Installing pre-requisite Wslu : wslvar, wslpath, ... commands"
    Linux::Apt::installIfNecessary --no-install-recommends wslu

    # @see https://github.com/microsoft/WSL/issues/8843#issuecomment-1792256894
    Log::displayInfo "Fix wsl interoperability due to wsl bug"
    if [[ ! -f /usr/lib/binfmt.d/WSLInterop.conf &&
      ! -f /etc/systemd/system/wsl-binfmt.service &&
      -f /run/systemd/generator.early/wsl-binfmt.service ]]; then
      sudo sh -c 'echo :WSLInterop:M::MZ::/init:PF > /usr/lib/binfmt.d/WSLInterop.conf'
      sudo ln -s /run/systemd/generator.early/wsl-binfmt.service /etc/systemd/system/wsl-binfmt.service
    fi
  fi
}


# @description prepend directories to the PATH environment variable
# @arg $@ args:String[] list of directories to prepend
# @set PATH update PATH with the directories prepended
Env::pathPrepend() {
  local arg
  for arg in "$@"; do
    if [[ -d "${arg}" && ":${PATH}:" != *":${arg}:"* ]]; then
      PATH="$(realpath "${arg}"):${PATH}"
    fi
  done
}


# @description ensure env files are loaded
# @arg $@ list of default files to load at the end
# @exitcode 1 if one of env files fails to load
# @stderr diagnostics information is displayed
# shellcheck disable=SC2120
Env::requireLoad() {
  export REQUIRE_FUNCTION_ENV_REQUIRE_LOAD_LOADED=1

  local -a defaultFiles=("$@")
  # get list of possible config files
  local -a configFiles=()
  if [[ -n "${BASH_FRAMEWORK_ENV_FILES[0]+1}" ]]; then
    # BASH_FRAMEWORK_ENV_FILES is an array
    configFiles+=("${BASH_FRAMEWORK_ENV_FILES[@]}")
  fi
  local localFrameworkConfigFile
  localFrameworkConfigFile="$(pwd)/.framework-config"
  if [[ -f "${localFrameworkConfigFile}" ]]; then
    configFiles+=("${localFrameworkConfigFile}")
  fi
  if [[ -f "${FRAMEWORK_ROOT_DIR}/.framework-config" ]]; then
    configFiles+=("${FRAMEWORK_ROOT_DIR}/.framework-config")
  fi
  configFiles+=("${optionEnvFiles[@]}")
  configFiles+=("${defaultFiles[@]}")

  for file in "${configFiles[@]}"; do
    # shellcheck source=/.framework-config
    CURRENT_LOADED_ENV_FILE="${file}" source "${file}" || {
      Log::displayError "while loading config file: ${file}"
      return 1
    }
  done
}


# @description delete files older than n days in given path
# @warning use this function with caution as it will delete all files in given path without any prompt
# @arg $1 path:String the directory in which files will be deleted or the file to delete
# @arg $2 mtime:String expiration time in days (eg: 1 means 1 day) (default value: 1). Eg: +1 match files that have been accessed at least two days ago (rounding effect)
# @arg $3 maxdepth:int Descend at most levels (a non-negative integer) levels of directories below the starting-points. (default value: 1)
# @exitcode 1 if path not provided or empty
# @exitcode * find command failure code
# @stderr find output on error or diagnostics logs
# @see man find atime
File::garbageCollect() {
  local path="$1"
  local mtime="$2"
  local maxdepth="${3:-1}"

  if [[ -z "${path}" ]]; then
    return 1
  fi

  if [[ ! -e "${path}" ]]; then
    # path already removed
    return 0
  fi

  Log::displayInfo "Garbage collect files older than ${mtime} days in path ${path} with max depth ${maxdepth}"
  find "${path}" -depth -maxdepth "${maxdepth}" -type f -mtime "${mtime}" -print -delete
}


# @description print the resolved path relative to DIR
# do not check for path existence
# @arg $1 srcFile:String the file to resolve
# @arg $2 relativeTo:String the directory
# @stdout the resolved path relative to DIR
File::relativeToDir() {
  local srcFile="$1"
  local relativeTo="$2"

  realpath -m --relative-to="${relativeTo}" "${srcFile}"
}


# @description create a temp file using default TMPDIR variable
# @env TMPDIR String (default value /tmp)
# @arg $1 templateName:String template name to use(optional)
Framework::createTempFile() {
  mktemp -p "${TMPDIR:-/tmp}" -t "${1:-}.XXXXXXXXXXXX"
}


# @description installs file to given directory
#
# callbacks parameters `${fromFile} ${targetFile} $@`
# @arg $1 fromFile - original file to copy
# @arg $2 targetFile - target file
# @arg $3 userName:String (optional) (default: ${USERNAME}) the user name that will be used to set target files ownership
# @arg $4 userGroup:String (optional) (default: ${USERNAME}) the group name that will be used to set target files ownership
# @arg $5 successCallback:Function the callback to call when file is installed successfully, by default setUserRights callback is called
# @arg $6 failureCallback:Function the callback to call when file installation has failed, by default unableToCopyCallback callback is called
# @arg $@ callbacksParams:String[] additional parameters passed to callbacks
# @exitcode 1 if fromFile is not readable
# @exitcode 2 if backup file failure
# @exitcode 3 if copy failure
# @exitcode 0 on success or if OVERWRITE_CONFIG_FILES=0
# @exitcode 0 on success or if CHANGE_WINDOWS_FILES=0 and target file is a windows file
# @env OVERWRITE_CONFIG_FILES Boolean (default:0) if 1 will overwrite existing directory
# @env CHANGE_WINDOWS_FILES Boolean (default:0) if 1 and target file is in windows file system, overwrite it
# @env USERNAME (default: root) the user name that will be used to set target files ownership
# @env USERGROUP (default: root) the group name that will be used to set target files ownership
# @env BASE_MNT_C String windows C drive base PATH
# @env FRAMEWORK_ROOT_DIR used to make paths relative to this directory to reduce length of messages
# @env SUDO String allows to use custom sudo prefix command
# @env BACKUP_BEFORE_INSTALL Boolean (default: 1) backup file before installing the file
Install::file() {
  local fromFile="$1"
  local targetFile="$2"
  local userName="${3:-${USERNAME:-root}}"
  local userGroup="${4:-${USERGROUP:-root}}"
  local successCallback=${5:-Install::setUserRightsCallback}
  local failureCallback=${6:-Install::unableToCopyCallback}
  shift 6 || true

  if [[ ! -f "${fromFile}" || ! -r "${fromFile}" ]]; then
    Log::displayError "cannot read source file '${fromFile}'"
    return 1
  fi

  # skip if OVERWRITE_CONFIG_FILES is 0 and target file exists
  if [[ "${OVERWRITE_CONFIG_FILES}" = "0" && -f "${targetFile}" ]]; then
    Log::displayWarning "File '${targetFile}' exists - Skip install (because OVERWRITE_CONFIG_FILES=0 in .env file)"
    return 0
  fi

  # skip if CHANGE_WINDOWS_FILES is 0 and target dir is c drive
  if [[ "${CHANGE_WINDOWS_FILES}" = "0" && "${targetFile}" =~ ^${BASE_MNT_C} ]]; then
    Log::displayWarning "File '${targetFile}' - Skip install (because CHANGE_WINDOWS_FILES=0 in .env file)"
    return 0
  fi

  local targetDir="${targetFile%/*}"
  if ! ${SUDO} test -d "${targetDir}"; then
    ${SUDO:-} mkdir -p "${targetDir}"
    ${SUDO:-} chown "${userName}":"${userGroup}" "${targetDir}"
  fi
  local fromDir="${fromFile%/*}"
  local fromFilename="${fromFile##*/}"

  local prettyFromDir
  # shellcheck disable=SC2295
  prettyFromDir="${fromDir#${PRETTY_ROOT_DIR:-${FRAMEWORK_ROOT_DIR}}/}"
  if diff -q "${fromFile}" "${targetFile}" &>/dev/null; then
    Log::displayStatus "No changes detected. No need to update '${targetFile}' from '${prettyFromDir}/${fromFilename}'"
    return 0
  fi

  if [[ "${BACKUP_BEFORE_INSTALL:-1}" = "1" ]]; then
    Backup::file "${targetFile}" || return 2
  fi

  if ${SUDO:-} cp "${fromFile}" "${targetFile}"; then
    # shellcheck disable=SC2295
    Log::displaySuccess "Installed file '${targetFile}' from '${prettyFromDir}/${fromFilename}'"
    ${successCallback} "${fromFile}" "${targetFile}" "${userName}" "${userGroup}" "${prettyFromDir}" "${fromFilename}"
  else
    # shellcheck disable=SC2295
    Log::displayError "unable to copy file '${targetFile}' from '${fromDir#${FRAMEWORK_ROOT_DIR}/}/${fromFilename}'"
    ${failureCallback} "${fromFile}" "${targetFile}" "${userName}" "${userGroup}" "${prettyFromDir}" "${fromFilename}"
    return 3
  fi
}


# @description install callback
#   set file with root ownership and execution bit
# @arg $1 fromFile:String
# @arg $2 targetFile:String
# @arg $3 userName:String (optional) (default: ${USERNAME}) the user name that will be used to set target files ownership
# @arg $4 userGroup:String (optional) (default: ${USERNAME}) the group name that will be used to set target files ownership
# @env USERNAME (default: root) the user name that will be used to set target files ownership
# @env USERGROUP (default: root) the group name that will be used to set target files ownership
# @env SUDO String allows to use custom sudo prefix command
# @exitcode 1 on any failure
# @see Install::file
Install::setUserRightsCallback() {
  # shellcheck disable=SC2034 # $1 not used
  local fromFile="$1"
  local targetFile="$2"
  local userName="${3:-${USERNAME:-root}}"
  local userGroup="${4:-${USERGROUP:-root}}"

  ${SUDO:-} chown "${userName}":"${userGroup}" "${targetFile}"
}


# @description install dir to given directory but backup it before
# @arg $1 fromDir:String the source base directory
# @arg $2 toDir:String the target base directory
# @env OVERWRITE_CONFIG_FILES Boolean (default:0) if 1 will overwrite existing files
# @env CHANGE_WINDOWS_FILES Boolean (default:0) if 1 and target directory is in windows file system, overwrite it
# @env USERNAME (default: ${USERNAME} if SUDO empty else root) the user name that will be used to set target files ownership
# @env USERGROUP (default: ${USERGROUP} if SUDO empty else root) the group name that will be used to set target files ownership
# @env BASE_MNT_C String windows C drive base PATH
# @env PRETTY_ROOT_DIR used to make paths relative to this directory to reduce length of messages
# @env SUDO String allows to use custom sudo prefix command
# @env BACKUP_BEFORE_INSTALL Boolean (default:1) backup directory before installing the dir
# @exitcode 1 if source directory is not readable
# @exitcode 2 if error during structure replication
# @exitcode 2 if error during file copy
# @exitcode 0 if copy successful
# @exitcode 0 with warning message if CHANGE_WINDOWS_FILES=0 and target directory in C drive
# @stderr diagnostics information is displayed, skipped information if OVERWRITE_CONFIG_FILES or CHANGE_WINDOWS_FILES are set to 1
Install::structure() {
  local fromDir="$1"
  local toDir="$2"
  local userName="root"
  local userGroup="root"
  if [[ -z "${SUDO:-}" ]]; then
    userName="${USERNAME:-root}"
    userGroup="${USERGROUP:-root}"
  fi

  if [[ ! -d "${fromDir}" || ! -r "${fromDir}" ]]; then
    Log::displayError "Install::structure - cannot read source directory '${fromDir}'"
    return 1
  fi

  # skip if CHANGE_WINDOWS_FILES is 0 and target dir is c drive
  if [[ "${CHANGE_WINDOWS_FILES:-0}" = "0" && "${toDir}" =~ ^${BASE_MNT_C:-/mnt/c} ]]; then
    Log::displayWarning "Install::structure - Directory '${fromDir}' - Skip install (because CHANGE_WINDOWS_FILES=0 in .env file)"
    return 0
  fi

  # first replicate directory structure
  # shellcheck disable=SC2317
  createStructure() {
    local dir="$1"
    if ! ${SUDO} test -d "${dir}"; then
      if ! ${SUDO:-} mkdir -p "${dir}"; then
        Log::displayError "Install::structure - impossible to create directory '${dir}'"
        exit 1
      fi
    fi

    if ! ${SUDO:-} chown "${userName}":"${userGroup}" "${dir}"; then
      Log::displayError "Install::structure - impossible to update directory owner '${dir}' with ${userName}:${userGroup}"
      exit 1
    fi
  }
  local dir

  (
    local dir
    shopt -s lastpipe
    # -links 2 allows to exclude empty directories
    ${SUDO:-} find "${fromDir}" -depth -type d -links 2 -print0 |
      while read -rd '' dir; do
        if ! createStructure "${toDir}/${dir#"${fromDir}"}"; then
          # error already reported by createStructure
          exit 1
        fi
      done || {
      if [[ "${PIPESTATUS[0]}" != "0" ]]; then
        Log::displayError "Install::structure - replicated directory structure - find directories on '${fromDir}' resulted in an error"
        exit 2
      fi
    }
  ) || return 2

  # for each file, copy it
  (
    local file
    shopt -s lastpipe
    ${SUDO:-} find "${fromDir}" -depth -type f -print0 |
      while read -rd '' file; do
        local localFile="${file#"${fromDir}/"}"
        if ! Install::file "${fromDir}/${localFile}" "${toDir}/${localFile}"; then
          # error already reported by Install::file
          exit 1
        fi
      done || {
      if [[ "${PIPESTATUS[0]}" != "0" ]]; then
        Log::displayError "Install::structure - replicated file structure - find files on '${fromDir}' resulted in an error"
        exit 2
      fi
    }
  ) || return 3

  # shellcheck disable=SC2295
  Log::displaySuccess "Installed directory '${toDir#${PRETTY_ROOT_DIR}/}' from '${fromDir#${PRETTY_ROOT_DIR}/}'"
}


# @description install callback
#   default callback used called when file copy has failed
# @arg $1 fromFile:String
# @arg $2 targetFile:String
# @env FRAMEWORK_ROOT_DIR used to make paths relative to this directory to reduce length of messages
# @exitcode 1 always fail
# @stderr diagnostics information is displayed
# @see Install::file
Install::unableToCopyCallback() {
  local fromDir="$1"
  local fileName="$2"
  local targetFile="$3"
  Log::fatal "unable to copy file '${fromDir#"${FRAMEWORK_ROOT_DIR}/"}/${fileName}' to '${targetFile}'"
}


# @description the command launch different actions(install, configure, test)
# depending on the options selected
# @see src/_includes/install.skip.options.tpl
# @env SKIP_INSTALL
# @env SKIP_CONFIGURE
# @env SKIP_TEST
# @env STATS_DIR
# @env LOGS_INSTALL_SCRIPTS_DIR
InstallScripts::command() {
  local logsDir="${LOGS_INSTALL_SCRIPTS_DIR:-#}"
  local statsDir="${STATS_DIR:-#}"
  local fullScriptName
  fullScriptName="$(fullScriptName)"
  local scriptName="${fullScriptName//\//@}"
  rm -f "${statsDir}/${scriptName}-"* || true

  # shellcheck disable=SC2317
  onInterrupt() {
    Log::displayError "${scriptName} aborted"
    exit 1
  }
  trap onInterrupt INT TERM ABRT

  local startDate logFile statsFile
  local installStatus="0"
  sourceHook() {
    local hookName="$1"
    # shellcheck disable=SC2154
    hook="$(IGNORE_ERROR=1 Conf::dynamicConfFile "${scriptName}/${hookName}.sh" "${embed_dir_hooks_dir}/${hookName}.sh")"
    if [[ -n "${hook}" && -f "${hook}" && -x "${hook}" ]]; then
      # shellcheck source=src/_installScripts/_Defaults/SimpleTest-hooks/preInstall.sh
      source "${hook}" || {
        Log::displayError "${scriptName} - unable to load hook '${hook}'"
        exit 1
      }
    fi
  }
  local globalStatsFile="${statsDir}/${scriptName}-global.stat"
  local hook
  if [[ "${SKIP_INSTALL}" = "0" ]] && ! InstallScripts::scriptFunctionEmpty install; then
    LOG_CONTEXT="${scriptName} - " Log::headLine "INSTALL" "Installing ${scriptName}"
    logFile="${logsDir}/${scriptName}-install.log"
    statsFile="${statsDir}/${scriptName}-install.stat"

    # break at first install error
    (
      startDate="$(date +%s)"
      # shellcheck disable=SC2317
      computeStats() {
        local rc=$1
        LOG_CONTEXT="${scriptName} - " Stats::statusLine "${statsFile}" "Installation"
        Stats::computeFromLog \
          "${logFile}" "${rc}" "${statsFile}" "${startDate}"
        Stats::aggregateGlobalStats \
          "${globalStatsFile}" "1" "${statsFile}"
        exit "${rc}"
      }
      trap 'computeStats "$?"' EXIT INT TERM ABRT

      local -i failures=0
      sourceHook preInstall || ((++failures))
      install || ((++failures))
      sourceHook postInstall || ((++failures))
      exit "${failures}"
    ) 2>&1 | tee "${logFile}"
  fi

  local testInstallStatus="0"
  if [[ "${SKIP_TEST}" = "0" && "${installStatus}" = "0" ]] &&
    ! InstallScripts::scriptFunctionEmpty testInstall; then
    Log::headLine "TEST" "Testing ${scriptName} installation"
    logFile="${logsDir}/${scriptName}-test-install.log"
    statsFile="${statsDir}/${scriptName}-test-install.stat"
    (
      startDate="$(date +%s)"
      # shellcheck disable=SC2317
      computeStats() {
        local rc=$1
        Stats::statusLine "${statsFile}" "Test Install ${scriptName}"
        Stats::computeFromLog \
          "${logFile}" "${rc}" "${statsFile}" "${startDate}"
        Stats::aggregateGlobalStats \
          "${globalStatsFile}" "1" "${statsFile}"
        exit "${rc}"
      }
      trap 'computeStats "$?"' EXIT INT TERM ABRT

      local -i failures=0
      sourceHook preTestInstall || ((++failures))
      testInstall || ((++failures))
      sourceHook postTestInstall || ((++failures))
      exit "${failures}"
    ) 2>&1 | tee "${logFile}" || testInstallStatus="$?" || true
    if [[ "${testInstallStatus}" != "0" ]] && breakOnTestFailure; then
      # break if test script error
      exit "${testInstallStatus}"
    fi
  fi

  local configStatus="0"
  if [[ "${SKIP_CONFIGURE}" = "0" && "${installStatus}" = "0" ]] &&
    ! InstallScripts::scriptFunctionEmpty configure; then
    Log::headLine "CONFIG" "Configuring ${scriptName}"
    logFile="${logsDir}/${scriptName}-config.log"
    statsFile="${statsDir}/${scriptName}-config.stat"
    (
      startDate="$(date +%s)"
      # shellcheck disable=SC2317
      computeStats() {
        local rc=$1
        Stats::statusLine "${statsFile}" "Configuration ${scriptName}"
        Stats::computeFromLog \
          "${logFile}" "${rc}" "${statsFile}" "${startDate}"
        Stats::aggregateGlobalStats \
          "${globalStatsFile}" "1" "${statsFile}"
        exit "${rc}"
      }
      trap 'computeStats "$?"' EXIT INT TERM ABRT

      local -i failures=0
      sourceHook preConfigure || ((++failures))
      configure || ((++failures))
      sourceHook postConfigure || ((++failures))
      exit "${failures}"
    ) 2>&1 | tee "${logFile}" || configStatus="$?" || true

    if [[ "${configStatus}" != "0" ]] && breakOnConfigFailure; then
      # break if config script error
      exit "${configStatus}"
    fi
  fi

  local testConfigStatus="0"
  if [[ "${SKIP_TEST}" = "0" && "${installStatus}" = "0" && "${configStatus}" = "0" ]] &&
    ! InstallScripts::scriptFunctionEmpty configure; then
    Log::headLine "TEST" "Testing ${scriptName} configuration"
    logFile="${logsDir}/${scriptName}-test-configuration.log"
    statsFile="${statsDir}/${scriptName}-test-configuration.stat"
    (
      startDate="$(date +%s)"
      # shellcheck disable=SC2317
      computeStats() {
        local rc=$1
        Stats::statusLine "${statsFile}" "Test Configuration ${scriptName}"
        Stats::computeFromLog \
          "${logFile}" "${rc}" "${statsFile}" "${startDate}"
        Stats::aggregateGlobalStats \
          "${globalStatsFile}" "1" "${statsFile}"
        exit "${rc}"
      }
      trap 'computeStats "$?"' EXIT INT TERM ABRT

      local -i failures=0
      sourceHook preTestConfigure || ((++failures))
      testConfigure || ((++failures))
      sourceHook postTestConfigure || ((++failures))
      exit "${failures}"
    ) 2>&1 | tee "${logFile}" || testConfigStatus="$?" || true
    if [[ "${testConfigStatus}" != "0" ]] && breakOnTestFailure; then
      # break if test script error
      exit "${testConfigStatus}"
    fi
  fi
}


# @description check if function is empty
# @arg $1 function:Function
# @exitcode 0 if function is considered empty (body with : or true)
InstallScripts::scriptFunctionEmpty() {
  local pattern="^[ \t]+(:|true)"
  [[ "$(declare -f "$1" | sed '3q;d')" =~ ${pattern} && "$(declare -f "$1" | sed '4q;d')" = "}" ]]
}


# @description apt-get install
# @arg $@ softwares:String[] list of softwares to install
# @feature Retry::default
# Linux::requireSudoCommand
# @stdout diagnostics logs
Linux::Apt::install() {

  if [[ "${REQUIRE_FUNCTION_LINUX_REQUIRE_UBUNTU_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::requireUbuntu has not been loaded"
    exit 1
  fi

  Log::displayInfo "Apt install $*"
  Retry::default sudo apt-get install -y -q "$@"
}


# @description apt-get install if package is not installed yet
# @arg $@ packages:String[] list of packages to install
# @feature Retry::default
# Linux::requireSudoCommand
# @env SKIP_APT_GET_UPDATE
# @stdout diagnostics logs
Linux::Apt::installIfNecessary() {

  if [[ "${REQUIRE_FUNCTION_LINUX_REQUIRE_UBUNTU_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::requireUbuntu has not been loaded"
    exit 1
  fi

  local -a packages=("$@")
  local package
  local -i installNeeded=0
  for package in "${packages[@]}"; do
    if [[ "${package}" =~ ^-- ]]; then
      continue
    fi
    if ! Linux::Apt::isPackageInstalled "${package}"; then
      Log::displayInfo "Package ${package} is not installed"
      installNeeded=1
    fi
  done
  if ((installNeeded == 1)); then
    if [[ "${SKIP_APT_GET_UPDATE:-0}" = "0" ]]; then
      Linux::Apt::update
    fi
    Linux::Apt::install "${packages[@]}"
    for package in "${packages[@]}"; do
      if [[ "${package}" =~ ^-- ]]; then
        continue
      fi
      if ! Linux::Apt::isPackageInstalled "${package}"; then
        Log::displayWarning "Package ${package} does not appear to have been installed, check if you could have chosen the wrong package name (Eg: python3.9-distutils instead of python3-distutils)"
      fi
    done
  else
    Log::displayInfo "Apt install avoided as packages are already installed : ${packages[*]}"
  fi
}


# @description check if apt package is installed
# @arg $1 package:String the package name to check
# @stdout diagnostics logs
Linux::Apt::isPackageInstalled() {

  if [[ "${REQUIRE_FUNCTION_LINUX_REQUIRE_UBUNTU_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::requireUbuntu has not been loaded"
    exit 1
  fi

  local package="$1"
  dpkg -l "${package}" | grep -Eq "^ii  ${package}"
}


# @description update apt packages list
# @feature Retry::default
# Linux::requireSudoCommand
# @stdout diagnostics logs
Linux::Apt::update() {

  if [[ "${REQUIRE_FUNCTION_LINUX_REQUIRE_UBUNTU_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::requireUbuntu has not been loaded"
    exit 1
  fi

  Log::displayInfo "Apt update ..."
  Retry::default sudo apt-get update -y --fix-missing -o Acquire::ForceIPv4=true
}


declare -Agx bash_tools_wslpath=()
# @description retrieve wslpath using cache (cache is refreshed every day)
# @arg $@ args:String[] arguments to pass to wslpath
# @env WSL_TMPDIR String temp directory to store the wslpath cache (default value: PERSISTENT_TMPDIR), you can use TMPDIR instead
# @exitcode * if Linux::Wsl::originalWslpath cannot find the path
# @stderr diagnostics information is displayed
# @feature cache
Linux::Wsl::cachedWslpath2() {

  if [[ "${REQUIRE_FUNCTION_LINUX__WSL_REQUIRE_WSL_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::Wsl::requireWsl has not been loaded"
    exit 1
  fi

  # shellcheck disable=SC2034
  local -n cachedWslpath2_value=$1
  shift || true
  local tempEnvFile key
  tempEnvFile="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}/bash_tools_wslpath"

  key="$(Linux::Wsl::getKeyFromWslpathOptions "$@")"
  Cache::getPropertyValue2 \
    "${tempEnvFile}" \
    bash_tools_wslpath \
    cachedWslpath2_value \
    "${key}" \
    Linux::Wsl::originalWslpath "$@"
}


# @description retrieve path from wslvar and then use wslpath to resolve it
# using cache (cache is refreshed every day)
# @arg $1 var:String the var to retrieve using wslvar
# @arg $@ args:String[] (optional) additional arguments to pass to wslvar
# @env WSL_TMPDIR String temp directory to store the wslpath cache (default value: PERSISTENT_TMPDIR), you can use TMPDIR instead
# @exitcode 1 if var cannot be found in cache nor using Linux::Wsl::originalWslvar
# @exitcode 2 if path cannot be found in cache nor using Linux::Wsl::originalWslpath
# @stderr diagnostics information is displayed
# @feature cache
Linux::Wsl::cachedWslpathFromWslVar2() {

  if [[ "${REQUIRE_FUNCTION_LINUX__WSL_REQUIRE_WSL_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::Wsl::requireWsl has not been loaded"
    exit 1
  fi

  # shellcheck disable=SC2034
  local -n cachedWslpathFromWslVar2_value=$1
  shift || true
  local value
  Linux::Wsl::cachedWslvar2 value "$@" || return 1
  Linux::Wsl::cachedWslpath2 cachedWslpathFromWslVar2_value "${value}" || return 2
}


declare -Agx bash_tools_wslvar=()
# @description retrieve wslvar using cache (cache is refreshed every day)
# @arg $1 cachedWslvar2_var:&String the variable to set by reference if the value is found
# @arg $@ args:String[] arguments to pass to wslvar
# @env WSL_TMPDIR String temp directory to store the wslvar cache (default value: PERSISTENT_TMPDIR), you can use TMPDIR instead
# @exitcode * if Linux::Wsl::originalWslvar cannot find the variable
# @stderr diagnostics information is displayed
# @feature cache
Linux::Wsl::cachedWslvar2() {

  if [[ "${REQUIRE_FUNCTION_LINUX__WSL_REQUIRE_WSL_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::Wsl::requireWsl has not been loaded"
    exit 1
  fi

  # shellcheck disable=SC2034
  local -n cachedWslvar2_var="$1"
  shift || true
  local -a args=("$@")
  local tempWslvarFile="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}/bash_tools_wslvar"
  local key
  key="$(Linux::Wsl::getKeyFromWslpathOptions "${args[@]}")"
  Cache::getPropertyValue2 \
    "${tempWslvarFile}" \
    bash_tools_wslvar \
    cachedWslvar2_var \
    "${key}" \
    Linux::Wsl::originalWslvar "${args[@]}"
}


# @description Compute a cache from wslpath options
# @arg $@ args:String[] arguments passed to wslpath
# @stderr diagnostics information is displayed
# @stdout the cache key deduced from the options
# @feature cache
# @internal
Linux::Wsl::getKeyFromWslpathOptions() {

  if [[ "${REQUIRE_FUNCTION_LINUX__WSL_REQUIRE_WSL_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::Wsl::requireWsl has not been loaded"
    exit 1
  fi

  local options
  options=$(getopt -o "auwm" -- "$@" 2>/dev/null) || {
    Log::displayError "invalid options specified"
    return 1
  }
  local key="wslpath"
  eval set -- "${options}"
  while true; do
    case "$1" in
      -a | -u | -w | -m)
        key="${key}$1"
        ;;
      --)
        shift || true
        break
        ;;
      *)
        shift || true
        Log::displayWarning "Unknown key $1"
        ;;
    esac
    shift || true
  done
  key="${key}_$1"
  # replace some characters \:/
  key="${key//\\//}"
  key="${key//:/_}"
  key="${key////_}"
  echo "${key}"
}


# @description call simply original wslpath command
# @arg $@ args:String[] args to pass to wslpath
# @exitcode * wslpath exit code
# @stdout wslpath stdout
Linux::Wsl::originalWslpath() {

  if [[ "${REQUIRE_FUNCTION_LINUX__WSL_REQUIRE_WSL_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::Wsl::requireWsl has not been loaded"
    exit 1
  fi

  wslpath "$@" | sed -z '$ s/[\r\n]$//'
}


# @description call simply original wslvar command
# @arg $@ args:String[] args to pass to wslvar
# @exitcode * wslvar exit code
# @stdout wslvar stdout
Linux::Wsl::originalWslvar() {

  if [[ "${REQUIRE_FUNCTION_LINUX__WSL_REQUIRE_WSL_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::Wsl::requireWsl has not been loaded"
    exit 1
  fi

  wslvar "$@" | sed -z '$ s/[\r\n]$//'
}


# @description ensure linux runs under wsl
# @env WSL_GARBAGE_COLLECT int 0 to disable garbage collect of cache files
# @exitcode 1 if linux does not run under wsl
Linux::Wsl::requireWsl() {
  export REQUIRE_FUNCTION_LINUX__WSL_REQUIRE_WSL_LOADED=1

  Assert::wsl || return 1
  if [[ "${WSL_GARBAGE_COLLECT:-1}" = "1" ]]; then
    local tempEnvDir
    tempEnvDir="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}"
    File::garbageCollect "${tempEnvDir}/bash_tools_wslpath_${USER_ID:-$(id -un)}" "1"
    tempEnvDir="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}"
    File::garbageCollect "${tempEnvDir}/bash_tools_wslvar_${USER_ID:-$(id -un)}" "1"
  fi
}


# @description retrieve linux distributor id
# @noargs
# @exitcode 1 if lsb_release fails or not found
# @stdout the linux distributor id
Linux::getDistributorId() {
  (
    source /etc/os-release
    echo "${ID}"
  )
}


# @description ensure command tar is available
# @exitcode 1 if tar command not available
# @stderr diagnostics information is displayed
Linux::requireTarCommand() {
  export REQUIRE_FUNCTION_LINUX_REQUIRE_TAR_COMMAND_LOADED=1

  Assert::commandExists tar
}


# @description ensure linux distribution is ubuntu
# @exitcode 1 if linux distribution is not ubuntu
Linux::requireUbuntu() {
  export REQUIRE_FUNCTION_LINUX_REQUIRE_UBUNTU_LOADED=1

  if ! Array::contains "$(Linux::getDistributorId)" "ubuntu" "debian"; then
    Log::fatal "this script should be executed under Ubuntu or Debian OS"
  fi
}


declare -g FIRST_LOG_DATE LOG_LAST_LOG_DATE LOG_LAST_LOG_DATE_INIT LOG_LAST_DURATION_STR
FIRST_LOG_DATE="${EPOCHREALTIME/[^0-9]/}"
LOG_LAST_LOG_DATE="${FIRST_LOG_DATE}"
LOG_LAST_LOG_DATE_INIT=1
LOG_LAST_DURATION_STR=""

# @description compute duration since last call to this function
# the result is set in following env variables.
# in ss.sss (seconds followed by milliseconds precision 3 decimals)
# @noargs
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @set LOG_LAST_LOG_DATE_INIT int (default 1) set to 0 at first call, allows to detect reference log
# @set LOG_LAST_DURATION_STR String the last duration displayed
# @set LOG_LAST_LOG_DATE String the last log date that will be used to compute next diff
Log::computeDuration() {
  if ((${DISPLAY_DURATION:-0} == 1)); then
    local -i duration=0
    local -i delta=0
    local -i currentLogDate
    currentLogDate="${EPOCHREALTIME/[^0-9]/}"
    if ((LOG_LAST_LOG_DATE_INIT == 1)); then
      LOG_LAST_LOG_DATE_INIT=0
      LOG_LAST_DURATION_STR="Ref"
    else
      duration=$(((currentLogDate - FIRST_LOG_DATE) / 1000000))
      delta=$(((currentLogDate - LOG_LAST_LOG_DATE) / 1000000))
      LOG_LAST_DURATION_STR="${duration}s/+${delta}s"
    fi
    LOG_LAST_LOG_DATE="${currentLogDate}"
    # shellcheck disable=SC2034
    local microSeconds="${EPOCHREALTIME#*.}"
    LOG_LAST_DURATION_STR="$(printf '%(%T)T.%03.0f\n' "${EPOCHSECONDS}" "${microSeconds:0:3}")(${LOG_LAST_DURATION_STR}) - "
  else
    # shellcheck disable=SC2034
    LOG_LAST_DURATION_STR=""
  fi
}


# @description Display message using debug color (gray)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayDebug() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_DEBUG)); then
    Log::computeDuration
    echo -e "${__DEBUG_COLOR}DEBUG   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logDebug "$1"
}


# @description Display message using error color (red)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayError() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_ERROR)); then
    Log::computeDuration
    echo -e "${__ERROR_COLOR}ERROR   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logError "$1"
}


# @description Display message using info color (bg light blue/fg white)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayHelp() {
  local type="${2:-HELP}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__HELP_COLOR}${type}    - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logHelp "$1" "${type}"
}


# @description Display message using info color (bg light blue/fg white)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayInfo() {
  local type="${2:-INFO}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__INFO_COLOR}${type}    - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logInfo "$1" "${type}"
}


# @description Display message using skip color (yellow)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displaySkipped() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__SKIPPED_COLOR}SKIPPED - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logSkipped "$1"
}


# @description Display message using info color (blue) but warning level
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayStatus() {
  local type="${2:-STATUS}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_WARNING)); then
    Log::computeDuration
    echo -e "${__INFO_COLOR}${type}  - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logStatus "$1" "${type}"
}


# @description Display message using success color (bg green/fg white)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displaySuccess() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__SUCCESS_COLOR}SUCCESS - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logSuccess "$1"
}


# @description Display message using warning color (yellow)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayWarning() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_WARNING)); then
    Log::computeDuration
    echo -e "${__WARNING_COLOR}WARN    - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logWarning "$1"
}


# @description Display message using error color (red) and exit immediately with error status 1
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::fatal() {
  Log::computeDuration
  echo -e "${__ERROR_COLOR}FATAL   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  Log::logFatal "$1"
  exit 1
}


# @description Display given text on full line with TEST_COLOR style
# @arg $1 text:String text to display
Log::headLine() {
  local type="$1"
  local text="$2"
  local message="${type}   - ${text}"
  if [[ -z "${type}" ]]; then
    message="${text}"
  else
    Log::computeDuration
    message="$(printf '%-7s - %s%s' "${type}" "${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}" "${text}")"
  fi
  echo -e "${__TEST_COLOR}$(UI::textLine "${message}" " ")${__RESET_COLOR}" >&2
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logDebug() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_DEBUG)); then
    Log::logMessage "${2:-DEBUG}" "$1"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logError() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_ERROR)); then
    Log::logMessage "${2:-ERROR}" "$1"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logFatal() {
  Log::logMessage "${2:-FATAL}" "$1"
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logHelp() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-HELP}" "$1"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logInfo() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-INFO}" "$1"
  fi
}


# @description Internal: common log message
# @example text
#   [date]|[levelMsg]|message
#
# @example text
#   2020-01-19 19:20:21|ERROR  |log error
#   2020-01-19 19:20:21|SKIPPED|log skipped
#
# @arg $1 levelMsg:String message's level description (eg: STATUS, ERROR, ...)
# @arg $2 msg:String the message to display
# @env BASH_FRAMEWORK_LOG_FILE String log file to use, do nothing if empty
# @env BASH_FRAMEWORK_LOG_LEVEL int log level log only if > OFF or fatal messages
# @stderr diagnostics information is displayed
Log::logMessage() {

  if [[ "${REQUIRE_FUNCTION_ENV_REQUIRE_LOAD_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Env::requireLoad has not been loaded"
    exit 1
  fi

  if [[ "${REQUIRE_FUNCTION_LOG_REQUIRE_LOAD_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Log::requireLoad has not been loaded"
    exit 1
  fi

  local levelMsg="$1"
  local msg="$2"
  local date

  if [[ -n "${BASH_FRAMEWORK_LOG_FILE}" ]] && ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    date="$(date '+%Y-%m-%d %H:%M:%S')"
    touch "${BASH_FRAMEWORK_LOG_FILE}"
    printf "%s|%7s|%s\n" "${date}" "${levelMsg}" "${msg}" >>"${BASH_FRAMEWORK_LOG_FILE}"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logSkipped() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-SKIPPED}" "$1"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logStatus() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_WARNING)); then
    Log::logMessage "${2:-STATUS}" "$1"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logSuccess() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-SUCCESS}" "$1"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logWarning() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_WARNING)); then
    Log::logMessage "${2:-WARNING}" "$1"
  fi
}


# @description activate or not Log::display* and Log::log* functions
# based on BASH_FRAMEWORK_DISPLAY_LEVEL and BASH_FRAMEWORK_LOG_LEVEL
# environment variables loaded by Env::requireLoad
# try to create log file and rotate it if necessary
# @noargs
# @set BASH_FRAMEWORK_LOG_LEVEL int to OFF level if BASH_FRAMEWORK_LOG_FILE is empty or not writable
# @env BASH_FRAMEWORK_DISPLAY_LEVEL int
# @env BASH_FRAMEWORK_LOG_LEVEL int
# @env BASH_FRAMEWORK_LOG_FILE String
# @env BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION int do log rotation if > 0
# @exitcode 0 always successful
# @stderr diagnostics information about log file is displayed
Log::requireLoad() {
  export REQUIRE_FUNCTION_LOG_REQUIRE_LOAD_LOADED=1


  if [[ "${REQUIRE_FUNCTION_ENV_REQUIRE_LOAD_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Env::requireLoad has not been loaded"
    exit 1
  fi

  if [[ "${REQUIRE_FUNCTION_UI_REQUIRE_THEME_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement UI::requireTheme has not been loaded"
    exit 1
  fi

  if [[ -z "${BASH_FRAMEWORK_LOG_FILE:-}" ]]; then
    BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
    export BASH_FRAMEWORK_LOG_LEVEL
  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    if [[ ! -f "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      if [[ ! -d "${BASH_FRAMEWORK_LOG_FILE%/*}" ]]; then
        if ! mkdir -p "${BASH_FRAMEWORK_LOG_FILE%/*}" 2>/dev/null; then
          BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
          echo -e "${__ERROR_COLOR}ERROR   - directory ${BASH_FRAMEWORK_LOG_FILE%/*} is not writable${__RESET_COLOR}" >&2
        fi
      elif ! touch --no-create "${BASH_FRAMEWORK_LOG_FILE}" 2>/dev/null; then
        BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
        echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
      fi
    elif [[ ! -w "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
      echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
    fi
  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    # will always be created even if not in info level
    Log::logMessage "INFO" "Logging to file ${BASH_FRAMEWORK_LOG_FILE} - Log level ${BASH_FRAMEWORK_LOG_LEVEL}"
    if ((BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION > 0)); then
      Log::rotate "${BASH_FRAMEWORK_LOG_FILE}" "${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION}"
    fi
  fi
}


# @description To be called before logging in the log file
# @arg $1 file:string log file name
# @arg $2 maxLogFilesCount:int maximum number of log files
Log::rotate() {
  local file="$1"
  local maxLogFilesCount="${2:-5}"

  if [[ ! -f "${file}" ]]; then
    Log::displayDebug "Log file ${file} doesn't exist yet"
    return 0
  fi
  local i
  for ((i = maxLogFilesCount - 1; i > 0; i--)); do
    Log::displayInfo "Log rotation ${file}.${i} to ${file}.$((i + 1))"
    mv "${file}."{"${i}","$((i + 1))"} &>/dev/null || true
  done
  if cp "${file}" "${file}.1" &>/dev/null; then
    echo >"${file}" # reset log file
    Log::displayInfo "Log rotation ${file} to ${file}.1"
  fi
}


# @description Retry a command 5 times with a delay of 15 seconds between each attempt
# @arg $@ command:String[] the command to run
# @exitcode 0 on success
# @exitcode 1 if max retries count reached
# @env RETRY_MAX_RETRY int max retries
# @env RETRY_DELAY_BETWEEN_RETRIES int delay between attempts
Retry::default() {
  Retry::parameterized "${RETRY_MAX_RETRY:-5}" "${RETRY_DELAY_BETWEEN_RETRIES:-15}" "" "$@"
}


# @description Retry a command several times depending on parameters
# @arg $1 maxRetries:int    $1 max retries
# @arg $2 delay:int between attempt
# @arg $3 message:String to display to describe the attempt
# @arg $@ rest of parameters, the command to run
# @exitcode 0 on success
# @exitcode 1 if max retries count reached
# @exitcode 2 if maxRetries invalid value
Retry::parameterized() {
  local maxRetries=$1
  shift || true
  local delayBetweenTries=$1
  shift || true
  local message="$1"
  shift || true
  local retriesCount=1
  if [[ "${maxRetries}" -lt 1 ]]; then
    Log::displayError "invalid maxRetry value"
    return 2
  fi

  while true; do
    Log::displayInfo "Attempt ${retriesCount}/${maxRetries}: ${message}"
    if "$@"; then
      break
    elif [[ "${retriesCount}" -lt "${maxRetries}" ]]; then
      Log::displayDebug "Command failed. Wait for ${delayBetweenTries} seconds"
      ((retriesCount++))
      sleep "${delayBetweenTries}"
    else
      Log::displayError "The command has failed after ${retriesCount} attempts."
      return 1
    fi
  done
  return 0
}


# @description aggregate number of skip/error/... log messages
# and export the result in aggregateStatFile
# @arg $1 statFile:String the current stat file to add to aggregateStatFile
# @arg $2 appCount:int number of app requested to be installed
# @arg $@ statFiles:String[] the files in which each step stats have been aggregated aggregated
# if it doesn't exist, the file is created with needed variables set to 0
# stats will be saved
Stats::aggregateGlobalStats() {
  local aggregateStatFile="$1"
  local appCount="$2"
  shift 2 || true
  local -a statFiles=("$@")

  (
    if [[ ! -f "${aggregateStatFile}" ]]; then
      Stats::aggregateStatsInitialContent "${appCount}" >"${aggregateStatFile}"
    fi
    # shellcheck source=src/Stats/aggregateStats.example
    source "${aggregateStatFile}"

    local -i globalError=0
    local -i globalWarning=0
    local -i globalSkipped=0
    local -i globalHelp=0
    local -i globalSuccess=0
    local -i globalStatus=0
    ((globalDuration = duration)) || true
    for statFile in "${statFiles[@]}"; do
      if [[ ! -f "${statFile}" ]]; then
        continue
      fi
      # shellcheck source=src/Stats/logStats.example
      source "${statFile}"

      # all statuses need to be 0 for global status to be O
      globalError=$((globalError || error))
      globalWarning=$((globalWarning || warning))
      globalSkipped=$((globalSkipped || skipped))
      globalHelp=$((globalHelp || help))
      globalSuccess=$((globalSuccess || success))
      globalStatus=$((globalStatus || status))
      globalDuration=$((globalDuration + duration))
    done
    # shellcheck source=src/Stats/aggregateStats.example
    source "${aggregateStatFile}"
    ((count++)) || true
    if ((globalStatus == 0)); then
      ((statusSuccess++)) || true
    fi
    if ((globalStatus > 0 || globalError > 0)); then
      ((error++)) || true
    fi
    if ((globalWarning > 0)); then
      ((warning++)) || true
    fi
    if ((globalSkipped > 0)); then
      ((skipped++)) || true
    fi
    if ((globalHelp > 0)); then
      ((help++)) || true
    fi
    if ((globalSuccess > 0)); then
      ((success++)) || true
    fi
    (
      echo "count=${count}"
      echo "appCount=${appCount}"
      echo "error=${error}"
      echo "warning=${warning}"
      echo "skipped=${skipped}"
      echo "help=${help}"
      echo "success=${success}"
      echo "duration=${globalDuration}"
      echo "statusSuccess=${statusSuccess}"
    ) >"${aggregateStatFile}"
  )
}


# @description default aggregateStats file Content
Stats::aggregateStatsInitialContent() {
  local appCount="$1"
  echo "count=0"
  echo "appCount=${appCount}"
  echo "error=0"
  echo "warning=0"
  echo "skipped=0"
  echo "help=0"
  echo "success=0"
  echo "duration=0"
  echo "statusSuccess=0"
}


# @description extract stats form log
# @arg $1 logFile:String the log file to parse
# @arg $2 status:int the status of the command associated to that log file
# @arg $3 statsFile:String where to write stats
# @arg $4 startDate:String date at which log started
# @stdout output with the format provided by this example src/Stats/aggregateStats.example
# @see src/Stats/aggregateStats.example
Stats::computeFromLog() {
  local logFile="$1"
  local status="$2"
  local statsFile="$3"
  local startDate="$4"
  local endDate
  endDate="$(date +%s)"
  local duration="$((endDate - startDate))"

  local logStatsAwkScript
  logStatsAwkScript="$(
    cat <<'EOF'
BEGIN {
  error=0
  warning=0
  skipped=0
  help=0
  success=0
}
{
  buffer = substr($0, 1, 20)
  if(match(buffer, /(ERROR)[ ]+- /, arr) != 0) {
    error+=1
  } else if(match(buffer, /(WARNING)[ ]+- /, arr) != 0) {
    warning+=1
  } else if(match(buffer, /(SKIPPED)[ ]+- /, arr) != 0) {
    skipped+=1
  } else if(match(buffer, /(ERROR)[ ]+- /, arr) != 0) {
    error+=1
  } else if(match(buffer, /(HELP)[ ]+- /, arr) != 0) {
    help+=1
  } else if(match(buffer, /(SUCCESS)[ ]+- /, arr) != 0) {
    success+=1
  }

}
END {
  error = (stat != 0) || error
  print "error=" error
  print "warning=" warning
  print "skipped=" skipped
  print "help=" help
  success = (stat == 0) || success
  print "success=" success
}

EOF
  )"

  (
    if [[ -f "${logFile}" ]]; then
      awk -v status="${status}" --source "${logStatsAwkScript}" "${logFile}"
      echo "status=${status}"
      echo "duration=${duration}"
    else
      # not executed
      echo "status=-1"
    fi
  ) >"${statsFile}"
}


# @description display message to reflect last installation status
# @arg $1:statFile
# @arg $2:msg
Stats::statusLine() {
  local statFile="$1"
  local msg="$2"
  if [[ ! -f "${statFile}" ]]; then
    return 0
  fi
  Log::computeDuration
  (
    # shellcheck source=src/Stats/logStats.example
    source "${statFile}" || exit 1

    local color="${__TEST_ERROR_COLOR}"
    local statusMsg
    if [[ "${status}" = "0" ]]; then
      if [[ "${skipped}" = "0" ]]; then
        color="${__SUCCESS_COLOR}"
        statusMsg="SUCCESS - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR}${msg} successful"
      fi
    elif [[ "${status}" = "-1" ]]; then
      statusMsg="ABORTED - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR}${msg} not executed"
    else
      statusMsg="ERROR   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR}${msg} in error"
    fi
    # overwrite final TEST line
    echo -e "${color}${statusMsg}${__RESET_COLOR}"
  )
}


# @description draw a line with the character passed in parameter repeated depending on terminal width
# @arg $1 character:String character to use as separator (default value #)
UI::drawLine() {
  local character="${1:-#}"
  local -i width=${COLUMNS:-0}
  if ((width == 0)) && [[ -t 1 ]]; then
    width=$(tput cols)
  fi
  if ((width == 0)); then
    width=80
  fi
  printf -- "${character}%.0s" $(seq "${COLUMNS:-$([[ -t 1 ]] && tput cols || echo '80')}")
  echo
}


# @description load color theme
# @noargs
# @env BASH_FRAMEWORK_THEME String theme to use
# @env LOAD_THEME int 0 to avoid loading theme
# @exitcode 0 always successful
UI::requireTheme() {
  export REQUIRE_FUNCTION_UI_REQUIRE_THEME_LOADED=1

  if [[ "${LOAD_THEME:-1}" = "1" ]]; then
    UI::theme "${BASH_FRAMEWORK_THEME-default}"
  fi
}


# @description Display given text and complete the rest of the line with given character
# @arg $1 text:String text to display
# @arg $2 character:String (default:#) character to use to complete the line
UI::textLine() {
  local text="$1"
  local character="${2:-#}"
  ((textSize = ${#text}))
  ((fullWith = $(tput cols)))
  ((remainingWidth = $((fullWith - textSize))))
  echo -n "${text}"
  printf '%*s\n' "${remainingWidth}" '' | tr ' ' "${character}"
}


# @description load colors theme constants
# @warning if tty not opened, noColor theme will be chosen
# @arg $1 theme:String the theme to use (default, noColor)
# @arg $@ args:String[]
# @set __ERROR_COLOR String indicate error status
# @set __INFO_COLOR String indicate info status
# @set __SUCCESS_COLOR String indicate success status
# @set __WARNING_COLOR String indicate warning status
# @set __SKIPPED_COLOR String indicate skipped status
# @set __DEBUG_COLOR String indicate debug status
# @set __HELP_COLOR String indicate help status
# @set __TEST_COLOR String not used
# @set __TEST_ERROR_COLOR String not used
# @set __HELP_TITLE_COLOR String used to display help title in help strings
# @set __HELP_OPTION_COLOR String used to display highlight options in help strings
#
# @set __RESET_COLOR String reset default color
#
# @set __HELP_EXAMPLE String to remove
# @set __HELP_TITLE String to remove
# @set __HELP_NORMAL String to remove
# shellcheck disable=SC2034
UI::theme() {
  local theme="${1-default}"
  if [[ ! "${theme}" =~ -force$ ]] && ! Assert::tty; then
    theme="noColor"
  fi
  case "${theme}" in
    default | default-force)
      theme="default"
      ;;
    noColor) ;;
    *)
      Log::fatal "invalid theme provided"
      ;;
  esac
  if [[ "${theme}" = "default" ]]; then
    BASH_FRAMEWORK_THEME="default"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR='\e[31m'         # Red
    __INFO_COLOR='\e[44m'          # white on lightBlue
    __SUCCESS_COLOR='\e[32m'       # Green
    __WARNING_COLOR='\e[33m'       # Yellow
    __SKIPPED_COLOR='\e[33m'       # Yellow
    __DEBUG_COLOR='\e[37m'         # Gray
    __HELP_COLOR='\e[7;49;33m'     # Black on Gold
    __TEST_COLOR='\e[100m'         # Light magenta
    __TEST_ERROR_COLOR='\e[41m'    # white on red
    __HELP_TITLE_COLOR="\e[1;37m"  # Bold
    __HELP_OPTION_COLOR="\e[1;34m" # Blue
    # Internal: reset color
    __RESET_COLOR='\e[0m' # Reset Color
    # shellcheck disable=SC2155,SC2034
    __HELP_EXAMPLE="$(echo -e "\e[2;97m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_TITLE="$(echo -e "\e[1;37m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_NORMAL="$(echo -e "\033[0m")"
  else
    BASH_FRAMEWORK_THEME="noColor"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR=''
    __INFO_COLOR=''
    __SUCCESS_COLOR=''
    __WARNING_COLOR=''
    __SKIPPED_COLOR=''
    __DEBUG_COLOR=''
    __HELP_COLOR=''
    __TEST_COLOR=''
    __TEST_ERROR_COLOR=''
    __HELP_TITLE_COLOR=''
    __HELP_OPTION_COLOR=''
    # Internal: reset color
    __RESET_COLOR=''
    __HELP_EXAMPLE=''
    __HELP_TITLE=''
    __HELP_NORMAL=''
  fi
}
# FUNCTIONS

# shellcheck disable=SC2034
declare commandFunctionName="installScriptCommand"

isInterfaceMandatoryFunctionImplemented() {
  isFunctionImplemented helpDescription || return 1
  isFunctionImplemented helpLongDescription || return 1
  isFunctionImplemented scriptName || return 1
  isFunctionImplemented dependencies || return 1
  isFunctionImplemented listVariables || return 1
  isFunctionImplemented fortunes || return 1
  isFunctionImplemented helpVariables || return 1
  isFunctionImplemented defaultVariables || return 1
  isFunctionImplemented checkVariables || return 1
  isFunctionImplemented breakOnConfigFailure || return 1
  isFunctionImplemented breakOnTestFailure || return 1
  isFunctionImplemented install || return 1
  isFunctionImplemented testInstall || return 1
  isFunctionImplemented configure || return 1
  isFunctionImplemented testConfigure || return 1
}

scriptName() {
  echo "ShellZshDefaultConfig"
}

beforeParseCallback() {
  defaultBeforeParseCallback
  isInterfaceMandatoryFunctionImplemented
}

commandHelpFunction() {
  echo "Available commands:"
  echo ""
}

listOrNone() {
  local string="$1"
  if [[ -z "${string:-}" ]]; then
    echo -e "${__HELP_EXAMPLE}None${__HELP_NORMAL}" | sed 's/^/    /'
  else
    echo -ne "${__HELP_OPTION_COLOR}"
    echo -e "${string}" | sed 's/^/    - /'
    echo -ne "${__HELP_NORMAL}"
  fi
}

helpDescriptionFunction() {
  helpDescription
  echo
}

helpLongDescription() {
  helpDescription
}

helpLongDescriptionFunction() {
  helpLongDescription | sed 's/^/  /'
  echo
  echo -e "  ${__HELP_TITLE}List of needed variables:${__HELP_NORMAL}"
  listOrNone "$(listVariables)"
  echo
  local variables
  variables="$(helpVariables)"
  if [[ -n "${variables}" ]]; then
    echo -e "${variables}" | sed 's/^/    /'
    echo
  fi
  echo -e "  ${__HELP_TITLE}List of dependencies:${__HELP_NORMAL}"
  listOrNone "$(dependencies)"
}

isFunctionImplemented() {
  local functionName="$1"
  if ! Assert::functionExists "${functionName}"; then
    Log::displayError "Function ${functionName} is not implemented"
    return 1
  fi
}

isInstallImplemented() {
  ! InstallScripts::scriptFunctionEmpty install
}

isTestInstallImplemented() {
  ! InstallScripts::scriptFunctionEmpty testInstall
}

isConfigureImplemented() {
  ! InstallScripts::scriptFunctionEmpty configure
}

isTestConfigureImplemented() {
  ! InstallScripts::scriptFunctionEmpty testConfigure
}

fullScriptName() {
  File::relativeToDir "${REAL_SCRIPT_FILE}" "${BASH_DEV_ENV_ROOT_DIR}"
}

argsInstallScriptCommandCallback() {
  if [[ -n "${command}" ]]; then
    if Array::contains "${command}" install testInstall configure testConfigure; then
      afterParseCallback
    fi
    "${command}"; exit $?
  fi
}



declare -a BASH_FRAMEWORK_ARGV_FILTERED=()

beforeParseCallback() {
  Env::requireLoad
  UI::requireTheme
  Log::requireLoad
}

copyrightCallback() {
  #
  # shellcheck disable=SC2155,SC2154,SC2250
  echo "Copyright (c) 2024-now François Chastanet"
}

# shellcheck disable=SC2317 # if function is overridden
updateArgListInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--verbose)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListTraceVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vvv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListEnvFileCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListLogLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListDisplayLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListNoColorCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--no-color)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListThemeCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListQuietCallback() { :; }

# shellcheck disable=SC2317 # if function is overridden
optionHelpCallback() {
  Log::displayError "optionHelpCallback needs to be overridden"
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionVersionCallback() {
  # shellcheck disable=SC2154
  echo "${SCRIPT_NAME} version 3.0"
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='--verbose'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_INFO}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_INFO}" >>"${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_DEBUG}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}" >>"${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionTraceVerboseCallback() {
  # shellcheck disable=SC2034
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vvv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_TRACE}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}" >>"${overrideEnvFile}"
}

getLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__LEVEL_OFF}"
      ;;
    ERR | ERROR)
      echo "${__LEVEL_ERROR}"
      ;;
    WARN | WARNING)
      echo "${__LEVEL_WARNING}"
      ;;
    INFO)
      echo "${__LEVEL_INFO}"
      ;;
    DEBUG | TRACE)
      echo "${__LEVEL_DEBUG}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
      ;;
  esac
}

getVerboseLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__VERBOSE_LEVEL_OFF}"
      ;;
    ERR | ERROR | WARN | WARNING | INFO)
      echo "${__VERBOSE_LEVEL_INFO}"
      ;;
    DEBUG)
      echo "${__VERBOSE_LEVEL_DEBUG}"
      ;;
    TRACE)
      echo "${__VERBOSE_LEVEL_TRACE}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
      ;;
  esac
}

# shellcheck disable=SC2317 # if function is overridden
optionDisplayLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${logLevel}" >>"${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionLogLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  # shellcheck disable=SC2034
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  echo "BASH_FRAMEWORK_LOG_LEVEL=${logLevel}" >>"${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionLogFileCallback() {
  local logFile="$2"
  echo "BASH_FRAMEWORK_LOG_FILE='${logFile}'" >>"${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionQuietCallback() {
  echo "BASH_FRAMEWORK_QUIET_MODE=1" >>"${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionNoColorCallback() {
  UI::theme "noColor"
}

# shellcheck disable=SC2317 # if function is overridden
optionThemeCallback() {
  UI::theme "$2"
}

displayConfig() {
  echo "Config"
  UI::drawLine "-"
  local var
  while read -r var; do
    printf '%-40s = %s\n' "${var}" "$(declare -p "${var}" | sed -E -e 's/^[^=]+=(.*)/\1/')"
  done < <(typeset -p | awk 'match($3, "^(BASH_FRAMEWORK_[^=]+)=", m) { print m[1] }' | sort)
  exit 0
}

optionBashFrameworkConfigCallback() {
  if [[ ! -f "$2" ]]; then
    Log::fatal "Command ${SCRIPT_NAME} - Bash framework config file '$2' does not exists"
  fi
}

defaultFrameworkConfig="$(
  cat <<'EOF'

# copied from src/_includes/.framework-config.default
# shellcheck disable=SC2034

REAL_SCRIPT_FILE="${REAL_SCRIPT_FILE:-$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")}"
FRAMEWORK_ROOT_DIR="${FRAMEWORK_ROOT_DIR:-${REAL_SCRIPT_FILE%/*/*}}"
FRAMEWORK_SRC_DIR="${FRAMEWORK_SRC_DIR:-${FRAMEWORK_ROOT_DIR}/src}"
FRAMEWORK_BIN_DIR="${FRAMEWORK_BIN_DIR:-${FRAMEWORK_ROOT_DIR}/bin}"
FRAMEWORK_VENDOR_DIR="${FRAMEWORK_VENDOR_DIR:-${FRAMEWORK_ROOT_DIR}/vendor}"
FRAMEWORK_VENDOR_BIN_DIR="${FRAMEWORK_VENDOR_BIN_DIR:-${FRAMEWORK_ROOT_DIR}/vendor/bin}"

# describe the functions that will be skipped from being imported
FRAMEWORK_FUNCTIONS_IGNORE_REGEXP="${FRAMEWORK_FUNCTIONS_IGNORE_REGEXP:-^(Namespace::functions|Functions::myFunction|Namespace::requireSomething|Acquire::ForceIPv4)$}"
# describe the files that do not contain function to be imported
NON_FRAMEWORK_FILES_REGEXP="${NON_FRAMEWORK_FILES_REGEXP:-(^bin/|.framework-config|.bats$|/testsData/|^manualTests/|/_.sh$|/ZZZ.sh$|/__all.sh$|^src/_binaries|^src/_includes|^src/batsHeaders.sh$|^src/_standalone)}"
# describe the files that are allowed to not have an associated bats file
BATS_FILE_NOT_NEEDED_REGEXP="${BATS_FILE_NOT_NEEDED_REGEXP:-(^bin/|.framework-config|.bats$|/testsData/|^manualTests/|/_.sh$|/ZZZ.sh$|/__all.sh$|^src/batsHeaders.sh$|^src/_includes)}"
# describe the files that are allowed to not have a function matching the filename
FRAMEWORK_FILES_FUNCTION_MATCHING_IGNORE_REGEXP="${FRAMEWORK_FILES_FUNCTION_MATCHING_IGNORE_REGEXP:-^bin/|^\.framework-config$|/testsData/|^manualTests/|\.bats$}"
# Source directories
if [[ ! -v FRAMEWORK_SRC_DIRS ]]; then
  FRAMEWORK_SRC_DIRS=(
    "${FRAMEWORK_ROOT_DIR}/src"
  )
fi

# export here all the variables that will be used in your templates
export REPOSITORY_URL="${REPOSITORY_URL:-https://github.com/fchastanet/bash-tools-framework}"

BASH_FRAMEWORK_THEME="${BASH_FRAMEWORK_THEME:-default}"
BASH_FRAMEWORK_LOG_LEVEL="${BASH_FRAMEWORK_LOG_LEVEL:-0}"
BASH_FRAMEWORK_DISPLAY_LEVEL="${BASH_FRAMEWORK_DISPLAY_LEVEL:-3}"
BASH_FRAMEWORK_LOG_FILE="${BASH_FRAMEWORK_LOG_FILE:-${FRAMEWORK_ROOT_DIR}/logs/${0##*/}.log}"
BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION="${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION:-5}"

EOF
)"

overrideEnvFile="$(Framework::createTempFile "overrideEnvFile")"

commandOptionParseFinished() {
  # load default template framework config
  defaultEnvFile="${PERSISTENT_TMPDIR}/.framework-config"
  echo "${defaultFrameworkConfig}" >"${defaultEnvFile}"
  local -a files=("${defaultEnvFile}")
  # shellcheck disable=SC2154
  if [[ -f "${optionBashFrameworkConfig}" ]]; then
    files+=("${optionBashFrameworkConfig}")
  fi
  files+=("${overrideEnvFile}")
  Env::requireLoad "${files[@]}"
  Log::requireLoad
  # shellcheck disable=SC2154
  if [[ "${optionConfig}" = "1" ]]; then
    displayConfig
  fi
}


Linux::requireTarCommand
Compiler::Embed::extractDirFromBase64 \
  "${PERSISTENT_TMPDIR:-/tmp}/131bf6e4bc883f05b733d16d6ca4757dbde1f1df5842f797da52ea77dc7f9e1d/conf_dir" \
  "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"

declare -gx embed_dir_conf_dir="${PERSISTENT_TMPDIR:-/tmp}/131bf6e4bc883f05b733d16d6ca4757dbde1f1df5842f797da52ea77dc7f9e1d/conf_dir"

Linux::requireTarCommand
Compiler::Embed::extractFileFromBase64 \
  "${PERSISTENT_TMPDIR:-/tmp}/5e427bfb617fb2c95ecd2317839d173a1f8c7b5acbf734cc783bcc0ca35c5852/loadConfigFiles" \
  "IyEvdXNyL2Jpbi9lbnYgYmFzaAojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMgR0VORVJBVEVEIEZBQ0FERSBGUk9NIGh0dHBzOi8vZ2l0aHViLmNvbS9mY2hhc3RhbmV0L2Jhc2gtZGV2LWVudi90cmVlL21hc3Rlci9zcmMvX2JpbmFyaWVzL190b29scy9sb2FkQ29uZmlnRmlsZXMuc2gKIyBETyBOT1QgRURJVCBJVAojIEBnZW5lcmF0ZWQKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIyODgsU0MyMDM0CiMgQklOX0ZJTEU9JHtCQVNIX0RFVl9FTlZfUk9PVF9ESVJ9L2Jpbi9sb2FkQ29uZmlnRmlsZXMKIyBWQVJfUkVMQVRJVkVfRlJBTUVXT1JLX0RJUl9UT19DVVJSRU5UX0RJUj0KIyBWQVJfTE9BRF9SRVFVSVJFUz0wCiMgVkFSX0xPQURfQ09ORklHPTAKIyBGQUNBREUKCiMgZW5zdXJlIHRoYXQgbm8gdXNlciBhbGlhc2VzIGNvdWxkIGludGVyZmVyZSB3aXRoCiMgY29tbWFuZHMgdXNlZCBpbiB0aGlzIHNjcmlwdAp1bmFsaWFzIC1hIHx8IHRydWUKc2hvcHQgLXUgZXhwYW5kX2FsaWFzZXMKCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjAzNAooKGZhaWx1cmVzID0gMCkpIHx8IHRydWUKCiMgQmFzaCB3aWxsIHJlbWVtYmVyICYgcmV0dXJuIHRoZSBoaWdoZXN0IGV4aXQgY29kZSBpbiBhIGNoYWluIG9mIHBpcGVzLgojIFRoaXMgd2F5IHlvdSBjYW4gY2F0Y2ggdGhlIGVycm9yIGluc2lkZSBwaXBlcywgZS5nLiBteXNxbGR1bXAgfCBnemlwCnNldCAtbyBwaXBlZmFpbApzZXQgLW8gZXJyZXhpdAoKIyBDb21tYW5kIFN1YnN0aXR1dGlvbiBjYW4gaW5oZXJpdCBlcnJleGl0IG9wdGlvbiBzaW5jZSBiYXNoIHY0LjQKc2hvcHQgLXMgaW5oZXJpdF9lcnJleGl0IHx8IHRydWUKCiMgaWYgc2V0LCBhbmQgam9iIGNvbnRyb2wgaXMgbm90IGFjdGl2ZSwgdGhlIHNoZWxsIHJ1bnMgdGhlIGxhc3QgY29tbWFuZAojIG9mIGEgcGlwZWxpbmUgbm90IGV4ZWN1dGVkIGluIHRoZSBiYWNrZ3JvdW5kIGluIHRoZSBjdXJyZW50IHNoZWxsCiMgZW52aXJvbm1lbnQuCnNob3B0IC1zIGxhc3RwaXBlCgojIGEgbG9nIGlzIGdlbmVyYXRlZCB3aGVuIGEgY29tbWFuZCBmYWlscwpzZXQgLW8gZXJydHJhY2UKCiMgdXNlIG51bGxnbG9iIHNvIHRoYXQgKGZpbGUqLnBocCkgd2lsbCByZXR1cm4gYW4gZW1wdHkgYXJyYXkgaWYgbm8gZmlsZQojIG1hdGNoZXMgdGhlIHdpbGRjYXJkCnNob3B0IC1zIG51bGxnbG9iCgojIGVuc3VyZSByZWdleHAgYXJlIGludGVycHJldGVkIHdpdGhvdXQgYWNjZW50dWF0ZWQgY2hhcmFjdGVycwpleHBvcnQgTENfQUxMPVBPU0lYCgpleHBvcnQgVEVSTT14dGVybS0yNTZjb2xvcgoKIyBhdm9pZCBpbnRlcmFjdGl2ZSBpbnN0YWxsCmV4cG9ydCBERUJJQU5fRlJPTlRFTkQ9bm9uaW50ZXJhY3RpdmUKZXhwb3J0IERFQkNPTkZfTk9OSU5URVJBQ1RJVkVfU0VFTj10cnVlCgojIHN0b3JlIGNvbW1hbmQgYXJndW1lbnRzIGZvciBsYXRlciB1c2FnZQojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKZGVjbGFyZSAtYSBCQVNIX0ZSQU1FV09SS19BUkdWPSgiJEAiKQojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKZGVjbGFyZSAtYSBPUklHSU5BTF9CQVNIX0ZSQU1FV09SS19BUkdWPSgiJEAiKQoKIyBAc2VlIGh0dHBzOi8vdW5peC5zdGFja2V4Y2hhbmdlLmNvbS9hLzM4Njg1NgojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIzMTcKaW50ZXJydXB0TWFuYWdlbWVudCgpIHsKICAjIHJlc3RvcmUgU0lHSU5UIGhhbmRsZXIKICB0cmFwIC0gSU5UCiAgIyBlbnN1cmUgdGhhdCBDdHJsLUMgaXMgdHJhcHBlZCBieSB0aGlzIHNjcmlwdCBhbmQgbm90IGJ5IHN1YiBwcm9jZXNzCiAgIyByZXBvcnQgdG8gdGhlIHBhcmVudCB0aGF0IHdlIGhhdmUgaW5kZWVkIGJlZW4gaW50ZXJydXB0ZWQKICBraWxsIC1zIElOVCAiJCQiCn0KdHJhcCBpbnRlcnJ1cHRNYW5hZ2VtZW50IElOVApTQ1JJUFRfTkFNRT0kezAjIyovfQpSRUFMX1NDUklQVF9GSUxFPSIkKHJlYWRsaW5rIC1lICIkKHJlYWxwYXRoICIke0JBU0hfU09VUkNFWzBdfSIpIikiCmlmIFtbIC1uICIke0VNQkVEX0NVUlJFTlRfRElSfSIgXV07IHRoZW4KICBDVVJSRU5UX0RJUj0iJHtFTUJFRF9DVVJSRU5UX0RJUn0iCmVsc2UKICBDVVJSRU5UX0RJUj0iJHtSRUFMX1NDUklQVF9GSUxFJS8qfSIKZmkKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojIFRlbXAgZGlyIG1hbmFnZW1lbnQKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgpLRUVQX1RFTVBfRklMRVM9IiR7S0VFUF9URU1QX0ZJTEVTOi0wfSIKZXhwb3J0IEtFRVBfVEVNUF9GSUxFUwoKIyBQRVJTSVNURU5UX1RNUERJUiBpcyBub3QgZGVsZXRlZCBieSB0cmFwcwpQRVJTSVNURU5UX1RNUERJUj0iJHtUTVBESVI6LS90bXB9L2Jhc2gtZnJhbWV3b3JrIgpleHBvcnQgUEVSU0lTVEVOVF9UTVBESVIKaWYgW1sgISAtZCAiJHtQRVJTSVNURU5UX1RNUERJUn0iIF1dOyB0aGVuCiAgbWtkaXIgLXAgIiR7UEVSU0lTVEVOVF9UTVBESVJ9IgpmaQoKIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0ClRNUERJUj0iJChta3RlbXAgLWQgLXAgIiR7UEVSU0lTVEVOVF9UTVBESVI6LS90bXB9IiAtdCBiYXNoLWZyYW1ld29yay0kJC1YWFhYWFgpIgpleHBvcnQgVE1QRElSCgojIHRlbXAgZGlyIGNsZWFuaW5nCiMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjMxNwpjbGVhbk9uRXhpdCgpIHsKICBsb2NhbCByYz0kPwogIGlmIFtbICIke0tFRVBfVEVNUF9GSUxFUzotMH0iID0gIjEiIF1dOyB0aGVuCiAgICBMb2c6OmRpc3BsYXlJbmZvICJLRUVQX1RFTVBfRklMRVM9MSB0ZW1wIGZpbGVzIGtlcHQgaGVyZSAnJHtUTVBESVJ9JyIKICBlbGlmIFtbIC1uICIke1RNUERJUit4eHh9IiBdXTsgdGhlbgogICAgTG9nOjpkaXNwbGF5RGVidWcgIktFRVBfVEVNUF9GSUxFUz0wIHJlbW92aW5nIHRlbXAgZmlsZXMgJyR7VE1QRElSfSciCiAgICBybSAtUmYgIiR7VE1QRElSOi0vdG1wL2Zha2V9IiA+L2Rldi9udWxsIDI+JjEKICBmaQogIGV4aXQgIiR7cmN9Igp9CnRyYXAgY2xlYW5PbkV4aXQgRVhJVCBIVVAgUVVJVCBBQlJUIFRFUk0KCiMgQGRlc2NyaXB0aW9uIExvZyBuYW1lc3BhY2UgcHJvdmlkZXMgMiBraW5kIG9mIGZ1bmN0aW9ucwojIC0gTG9nOjpkaXNwbGF5KiBhbGxvd3MgdG8gZGlzcGxheSBnaXZlbiBtZXNzYWdlIHdpdGgKIyAgIGdpdmVuIGRpc3BsYXkgbGV2ZWwKIyAtIExvZzo6bG9nKiBhbGxvd3MgdG8gbG9nIGdpdmVuIG1lc3NhZ2Ugd2l0aAojICAgZ2l2ZW4gbG9nIGxldmVsCiMgTG9nOjpkaXNwbGF5KiBmdW5jdGlvbnMgYXV0b21hdGljYWxseSBsb2cgdGhlIG1lc3NhZ2UgdG9vCiMgQHNlZSBFbnY6OnJlcXVpcmVMb2FkIHRvIGxvYWQgdGhlIGRpc3BsYXkgYW5kIGxvZyBsZXZlbCBmcm9tIC5lbnYgZmlsZQoKIyBAZGVzY3JpcHRpb24gbG9nIGxldmVsIG9mZgpleHBvcnQgX19MRVZFTF9PRkY9MAojIEBkZXNjcmlwdGlvbiBsb2cgbGV2ZWwgZXJyb3IKZXhwb3J0IF9fTEVWRUxfRVJST1I9MQojIEBkZXNjcmlwdGlvbiBsb2cgbGV2ZWwgd2FybmluZwpleHBvcnQgX19MRVZFTF9XQVJOSU5HPTIKIyBAZGVzY3JpcHRpb24gbG9nIGxldmVsIGluZm8KZXhwb3J0IF9fTEVWRUxfSU5GTz0zCiMgQGRlc2NyaXB0aW9uIGxvZyBsZXZlbCBzdWNjZXNzCmV4cG9ydCBfX0xFVkVMX1NVQ0NFU1M9MwojIEBkZXNjcmlwdGlvbiBsb2cgbGV2ZWwgZGVidWcKZXhwb3J0IF9fTEVWRUxfREVCVUc9NAoKIyBAZGVzY3JpcHRpb24gdmVyYm9zZSBsZXZlbCBvZmYKZXhwb3J0IF9fVkVSQk9TRV9MRVZFTF9PRkY9MAojIEBkZXNjcmlwdGlvbiB2ZXJib3NlIGxldmVsIGluZm8KZXhwb3J0IF9fVkVSQk9TRV9MRVZFTF9JTkZPPTEKIyBAZGVzY3JpcHRpb24gdmVyYm9zZSBsZXZlbCBpbmZvCmV4cG9ydCBfX1ZFUkJPU0VfTEVWRUxfREVCVUc9MgojIEBkZXNjcmlwdGlvbiB2ZXJib3NlIGxldmVsIGluZm8KZXhwb3J0IF9fVkVSQk9TRV9MRVZFTF9UUkFDRT0zCgojIEBkZXNjcmlwdGlvbiBEaXNwbGF5IG1lc3NhZ2UgdXNpbmcgaW5mbyBjb2xvciAoYmcgbGlnaHQgYmx1ZS9mZyB3aGl0ZSkKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKIyBAZW52IERJU1BMQVlfRFVSQVRJT04gaW50IChkZWZhdWx0IDApIGlmIDEgZGlzcGxheSBlbGFwc2VkIHRpbWUgaW5mb3JtYXRpb24gYmV0d2VlbiAyIGluZm8gbG9ncwojIEBlbnYgTE9HX0NPTlRFWFQgU3RyaW5nIGFsbG93cyB0byBjb250ZXh0dWFsaXplIHRoZSBsb2cKTG9nOjpkaXNwbGF5SW5mbygpIHsKICBsb2NhbCB0eXBlPSIkezI6LUlORk99IgogIGlmICgoQkFTSF9GUkFNRVdPUktfRElTUExBWV9MRVZFTCA+PSBfX0xFVkVMX0lORk8pKTsgdGhlbgogICAgTG9nOjpjb21wdXRlRHVyYXRpb24KICAgIGVjaG8gLWUgIiR7X19JTkZPX0NPTE9SfSR7dHlwZX0gICAgLSAke0xPR19DT05URVhUOi19JHtMT0dfTEFTVF9EVVJBVElPTl9TVFI6LX0kezF9JHtfX1JFU0VUX0NPTE9SfSIgPiYyCiAgZmkKICBMb2c6OmxvZ0luZm8gIiQxIiAiJHt0eXBlfSIKfQoKIyBAZGVzY3JpcHRpb24gRGlzcGxheSBtZXNzYWdlIHVzaW5nIGRlYnVnIGNvbG9yIChncmF5KQojIEBhcmcgJDEgbWVzc2FnZTpTdHJpbmcgdGhlIG1lc3NhZ2UgdG8gZGlzcGxheQojIEBlbnYgRElTUExBWV9EVVJBVElPTiBpbnQgKGRlZmF1bHQgMCkgaWYgMSBkaXNwbGF5IGVsYXBzZWQgdGltZSBpbmZvcm1hdGlvbiBiZXR3ZWVuIDIgaW5mbyBsb2dzCiMgQGVudiBMT0dfQ09OVEVYVCBTdHJpbmcgYWxsb3dzIHRvIGNvbnRleHR1YWxpemUgdGhlIGxvZwpMb2c6OmRpc3BsYXlEZWJ1ZygpIHsKICBpZiAoKEJBU0hfRlJBTUVXT1JLX0RJU1BMQVlfTEVWRUwgPj0gX19MRVZFTF9ERUJVRykpOyB0aGVuCiAgICBMb2c6OmNvbXB1dGVEdXJhdGlvbgogICAgZWNobyAtZSAiJHtfX0RFQlVHX0NPTE9SfURFQlVHICAgLSAke0xPR19DT05URVhUOi19JHtMT0dfTEFTVF9EVVJBVElPTl9TVFI6LX0kezF9JHtfX1JFU0VUX0NPTE9SfSIgPiYyCiAgZmkKICBMb2c6OmxvZ0RlYnVnICIkMSIKfQoKIyBAZGVzY3JpcHRpb24gY2hlY2tzIGlmIGZ1bmN0aW9uIG5hbWUgcHJvdmlkZWQgZXhpc3RzCiMgQGFyZyAkMSBmdW5jdGlvbk5hbWU6U3RyaW5nCiMgQGV4aXRjb2RlIDEgaWYgZnVuY3Rpb24gbmFtZSBkb2Vzbid0IGV4aXN0CkFzc2VydDo6ZnVuY3Rpb25FeGlzdHMoKSB7CiAgZGVjbGFyZSAtRiAiJDEiID4vZGV2L251bGwKfQoKIyBAZGVzY3JpcHRpb24gZW5zdXJlIENPTU1BTkRfQklOX0RJUiBlbnYgdmFyIGlzIHNldAojIGFuZCBQQVRIIGNvcnJlY3RseSBwcmVwYXJlZAojIEBub2FyZ3MKIyBAc2V0IENPTU1BTkRfQklOX0RJUiBzdHJpbmcgdGhlIGRpcmVjdG9yeSB3aGVyZSB0byBmaW5kIHRoaXMgY29tbWFuZAojIEBzZXQgUEFUSCBzdHJpbmcgYWRkIGRpcmVjdG9yeSB3aGVyZSB0byBmaW5kIHRoaXMgY29tbWFuZCBiaW5hcnkKQ29tcGlsZXI6OkZhY2FkZTo6cmVxdWlyZUNvbW1hbmRCaW5EaXIoKSB7CiAgQ09NTUFORF9CSU5fRElSPSIke0NVUlJFTlRfRElSfSIKICBFbnY6OnBhdGhQcmVwZW5kICIke0NPTU1BTkRfQklOX0RJUn0iCn0KCmRlY2xhcmUgLWcgRklSU1RfTE9HX0RBVEUgTE9HX0xBU1RfTE9HX0RBVEUgTE9HX0xBU1RfTE9HX0RBVEVfSU5JVCBMT0dfTEFTVF9EVVJBVElPTl9TVFIKRklSU1RfTE9HX0RBVEU9IiR7RVBPQ0hSRUFMVElNRS9bXjAtOV0vfSIKTE9HX0xBU1RfTE9HX0RBVEU9IiR7RklSU1RfTE9HX0RBVEV9IgpMT0dfTEFTVF9MT0dfREFURV9JTklUPTEKTE9HX0xBU1RfRFVSQVRJT05fU1RSPSIiCgojIEBkZXNjcmlwdGlvbiBjb21wdXRlIGR1cmF0aW9uIHNpbmNlIGxhc3QgY2FsbCB0byB0aGlzIGZ1bmN0aW9uCiMgdGhlIHJlc3VsdCBpcyBzZXQgaW4gZm9sbG93aW5nIGVudiB2YXJpYWJsZXMuCiMgaW4gc3Muc3NzIChzZWNvbmRzIGZvbGxvd2VkIGJ5IG1pbGxpc2Vjb25kcyBwcmVjaXNpb24gMyBkZWNpbWFscykKIyBAbm9hcmdzCiMgQGVudiBESVNQTEFZX0RVUkFUSU9OIGludCAoZGVmYXVsdCAwKSBpZiAxIGRpc3BsYXkgZWxhcHNlZCB0aW1lIGluZm9ybWF0aW9uIGJldHdlZW4gMiBpbmZvIGxvZ3MKIyBAc2V0IExPR19MQVNUX0xPR19EQVRFX0lOSVQgaW50IChkZWZhdWx0IDEpIHNldCB0byAwIGF0IGZpcnN0IGNhbGwsIGFsbG93cyB0byBkZXRlY3QgcmVmZXJlbmNlIGxvZwojIEBzZXQgTE9HX0xBU1RfRFVSQVRJT05fU1RSIFN0cmluZyB0aGUgbGFzdCBkdXJhdGlvbiBkaXNwbGF5ZWQKIyBAc2V0IExPR19MQVNUX0xPR19EQVRFIFN0cmluZyB0aGUgbGFzdCBsb2cgZGF0ZSB0aGF0IHdpbGwgYmUgdXNlZCB0byBjb21wdXRlIG5leHQgZGlmZgpMb2c6OmNvbXB1dGVEdXJhdGlvbigpIHsKICBpZiAoKCR7RElTUExBWV9EVVJBVElPTjotMH0gPT0gMSkpOyB0aGVuCiAgICBsb2NhbCAtaSBkdXJhdGlvbj0wCiAgICBsb2NhbCAtaSBkZWx0YT0wCiAgICBsb2NhbCAtaSBjdXJyZW50TG9nRGF0ZQogICAgY3VycmVudExvZ0RhdGU9IiR7RVBPQ0hSRUFMVElNRS9bXjAtOV0vfSIKICAgIGlmICgoTE9HX0xBU1RfTE9HX0RBVEVfSU5JVCA9PSAxKSk7IHRoZW4KICAgICAgTE9HX0xBU1RfTE9HX0RBVEVfSU5JVD0wCiAgICAgIExPR19MQVNUX0RVUkFUSU9OX1NUUj0iUmVmIgogICAgZWxzZQogICAgICBkdXJhdGlvbj0kKCgoY3VycmVudExvZ0RhdGUgLSBGSVJTVF9MT0dfREFURSkgLyAxMDAwMDAwKSkKICAgICAgZGVsdGE9JCgoKGN1cnJlbnRMb2dEYXRlIC0gTE9HX0xBU1RfTE9HX0RBVEUpIC8gMTAwMDAwMCkpCiAgICAgIExPR19MQVNUX0RVUkFUSU9OX1NUUj0iJHtkdXJhdGlvbn1zLyske2RlbHRhfXMiCiAgICBmaQogICAgTE9HX0xBU1RfTE9HX0RBVEU9IiR7Y3VycmVudExvZ0RhdGV9IgogICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMDM0CiAgICBsb2NhbCBtaWNyb1NlY29uZHM9IiR7RVBPQ0hSRUFMVElNRSMqLn0iCiAgICBMT0dfTEFTVF9EVVJBVElPTl9TVFI9IiQocHJpbnRmICclKCVUKVQuJTAzLjBmXG4nICIke0VQT0NIU0VDT05EU30iICIke21pY3JvU2Vjb25kczowOjN9IikoJHtMT0dfTEFTVF9EVVJBVElPTl9TVFJ9KSAtICIKICBlbHNlCiAgICAjIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKICAgIExPR19MQVNUX0RVUkFUSU9OX1NUUj0iIgogIGZpCn0KCiMgQGRlc2NyaXB0aW9uIGxvZyBtZXNzYWdlIHRvIGZpbGUKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpsb2dJbmZvKCkgewogIGlmICgoQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMID49IF9fTEVWRUxfSU5GTykpOyB0aGVuCiAgICBMb2c6OmxvZ01lc3NhZ2UgIiR7MjotSU5GT30iICIkMSIKICBmaQp9CgojIEBkZXNjcmlwdGlvbiBsb2cgbWVzc2FnZSB0byBmaWxlCiMgQGFyZyAkMSBtZXNzYWdlOlN0cmluZyB0aGUgbWVzc2FnZSB0byBkaXNwbGF5CkxvZzo6bG9nRGVidWcoKSB7CiAgaWYgKChCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwgPj0gX19MRVZFTF9ERUJVRykpOyB0aGVuCiAgICBMb2c6OmxvZ01lc3NhZ2UgIiR7MjotREVCVUd9IiAiJDEiCiAgZmkKfQoKIyBAZGVzY3JpcHRpb24gcHJlcGVuZCBkaXJlY3RvcmllcyB0byB0aGUgUEFUSCBlbnZpcm9ubWVudCB2YXJpYWJsZQojIEBhcmcgJEAgYXJnczpTdHJpbmdbXSBsaXN0IG9mIGRpcmVjdG9yaWVzIHRvIHByZXBlbmQKIyBAc2V0IFBBVEggdXBkYXRlIFBBVEggd2l0aCB0aGUgZGlyZWN0b3JpZXMgcHJlcGVuZGVkCkVudjo6cGF0aFByZXBlbmQoKSB7CiAgbG9jYWwgYXJnCiAgZm9yIGFyZyBpbiAiJEAiOyBkbwogICAgaWYgW1sgLWQgIiR7YXJnfSIgJiYgIjoke1BBVEh9OiIgIT0gKiI6JHthcmd9OiIqIF1dOyB0aGVuCiAgICAgIFBBVEg9IiQocmVhbHBhdGggIiR7YXJnfSIpOiR7UEFUSH0iCiAgICBmaQogIGRvbmUKfQoKIyBAZGVzY3JpcHRpb24gSW50ZXJuYWw6IGNvbW1vbiBsb2cgbWVzc2FnZQojIEBleGFtcGxlIHRleHQKIyAgIFtkYXRlXXxbbGV2ZWxNc2ddfG1lc3NhZ2UKIwojIEBleGFtcGxlIHRleHQKIyAgIDIwMjAtMDEtMTkgMTk6MjA6MjF8RVJST1IgIHxsb2cgZXJyb3IKIyAgIDIwMjAtMDEtMTkgMTk6MjA6MjF8U0tJUFBFRHxsb2cgc2tpcHBlZAojCiMgQGFyZyAkMSBsZXZlbE1zZzpTdHJpbmcgbWVzc2FnZSdzIGxldmVsIGRlc2NyaXB0aW9uIChlZzogU1RBVFVTLCBFUlJPUiwgLi4uKQojIEBhcmcgJDIgbXNnOlN0cmluZyB0aGUgbWVzc2FnZSB0byBkaXNwbGF5CiMgQGVudiBCQVNIX0ZSQU1FV09SS19MT0dfRklMRSBTdHJpbmcgbG9nIGZpbGUgdG8gdXNlLCBkbyBub3RoaW5nIGlmIGVtcHR5CiMgQGVudiBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwgaW50IGxvZyBsZXZlbCBsb2cgb25seSBpZiA+IE9GRiBvciBmYXRhbCBtZXNzYWdlcwojIEBzdGRlcnIgZGlhZ25vc3RpY3MgaW5mb3JtYXRpb24gaXMgZGlzcGxheWVkCiMgQHJlcXVpcmUgRW52OjpyZXF1aXJlTG9hZAojIEByZXF1aXJlIExvZzo6cmVxdWlyZUxvYWQKTG9nOjpsb2dNZXNzYWdlKCkgewogIGxvY2FsIGxldmVsTXNnPSIkMSIKICBsb2NhbCBtc2c9IiQyIgogIGxvY2FsIGRhdGUKCiAgaWYgW1sgLW4gIiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IiBdXSAmJiAoKEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTCA+IF9fTEVWRUxfT0ZGKSk7IHRoZW4KICAgIGRhdGU9IiQoZGF0ZSAnKyVZLSVtLSVkICVIOiVNOiVTJykiCiAgICB0b3VjaCAiJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRX0iCiAgICBwcmludGYgIiVzfCU3c3wlc1xuIiAiJHtkYXRlfSIgIiR7bGV2ZWxNc2d9IiAiJHttc2d9IiA+PiIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFfSIKICBmaQp9CgojIEBkZXNjcmlwdGlvbiBlbnN1cmUgZW52IGZpbGVzIGFyZSBsb2FkZWQKIyBAYXJnICRAIGxpc3Qgb2YgZGVmYXVsdCBmaWxlcyB0byBsb2FkIGF0IHRoZSBlbmQKIyBAZXhpdGNvZGUgMSBpZiBvbmUgb2YgZW52IGZpbGVzIGZhaWxzIHRvIGxvYWQKIyBAc3RkZXJyIGRpYWdub3N0aWNzIGluZm9ybWF0aW9uIGlzIGRpc3BsYXllZAojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIxMjAKRW52OjpyZXF1aXJlTG9hZCgpIHsKICBsb2NhbCAtYSBkZWZhdWx0RmlsZXM9KCIkQCIpCiAgIyBnZXQgbGlzdCBvZiBwb3NzaWJsZSBjb25maWcgZmlsZXMKICBsb2NhbCAtYSBjb25maWdGaWxlcz0oKQogIGlmIFtbIC1uICIke0JBU0hfRlJBTUVXT1JLX0VOVl9GSUxFU1swXSsxfSIgXV07IHRoZW4KICAgICMgQkFTSF9GUkFNRVdPUktfRU5WX0ZJTEVTIGlzIGFuIGFycmF5CiAgICBjb25maWdGaWxlcys9KCIke0JBU0hfRlJBTUVXT1JLX0VOVl9GSUxFU1tAXX0iKQogIGZpCiAgbG9jYWwgbG9jYWxGcmFtZXdvcmtDb25maWdGaWxlCiAgbG9jYWxGcmFtZXdvcmtDb25maWdGaWxlPSIkKHB3ZCkvLmZyYW1ld29yay1jb25maWciCiAgaWYgW1sgLWYgIiR7bG9jYWxGcmFtZXdvcmtDb25maWdGaWxlfSIgXV07IHRoZW4KICAgIGNvbmZpZ0ZpbGVzKz0oIiR7bG9jYWxGcmFtZXdvcmtDb25maWdGaWxlfSIpCiAgZmkKICBpZiBbWyAtZiAiJHtGUkFNRVdPUktfUk9PVF9ESVJ9Ly5mcmFtZXdvcmstY29uZmlnIiBdXTsgdGhlbgogICAgY29uZmlnRmlsZXMrPSgiJHtGUkFNRVdPUktfUk9PVF9ESVJ9Ly5mcmFtZXdvcmstY29uZmlnIikKICBmaQogIGNvbmZpZ0ZpbGVzKz0oIiR7b3B0aW9uRW52RmlsZXNbQF19IikKICBjb25maWdGaWxlcys9KCIke2RlZmF1bHRGaWxlc1tAXX0iKQoKICBmb3IgZmlsZSBpbiAiJHtjb25maWdGaWxlc1tAXX0iOyBkbwogICAgIyBzaGVsbGNoZWNrIHNvdXJjZT0vLmZyYW1ld29yay1jb25maWcKICAgIENVUlJFTlRfTE9BREVEX0VOVl9GSUxFPSIke2ZpbGV9IiBzb3VyY2UgIiR7ZmlsZX0iIHx8IHsKICAgICAgTG9nOjpkaXNwbGF5RXJyb3IgIndoaWxlIGxvYWRpbmcgY29uZmlnIGZpbGU6ICR7ZmlsZX0iCiAgICAgIHJldHVybiAxCiAgICB9CiAgZG9uZQp9CgojIEBkZXNjcmlwdGlvbiBhY3RpdmF0ZSBvciBub3QgTG9nOjpkaXNwbGF5KiBhbmQgTG9nOjpsb2cqIGZ1bmN0aW9ucwojIGJhc2VkIG9uIEJBU0hfRlJBTUVXT1JLX0RJU1BMQVlfTEVWRUwgYW5kIEJBU0hfRlJBTUVXT1JLX0xPR19MRVZFTAojIGVudmlyb25tZW50IHZhcmlhYmxlcyBsb2FkZWQgYnkgRW52OjpyZXF1aXJlTG9hZAojIHRyeSB0byBjcmVhdGUgbG9nIGZpbGUgYW5kIHJvdGF0ZSBpdCBpZiBuZWNlc3NhcnkKIyBAbm9hcmdzCiMgQHNldCBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwgaW50IHRvIE9GRiBsZXZlbCBpZiBCQVNIX0ZSQU1FV09SS19MT0dfRklMRSBpcyBlbXB0eSBvciBub3Qgd3JpdGFibGUKIyBAZW52IEJBU0hfRlJBTUVXT1JLX0RJU1BMQVlfTEVWRUwgaW50CiMgQGVudiBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwgaW50CiMgQGVudiBCQVNIX0ZSQU1FV09SS19MT0dfRklMRSBTdHJpbmcKIyBAZW52IEJBU0hfRlJBTUVXT1JLX0xPR19GSUxFX01BWF9ST1RBVElPTiBpbnQgZG8gbG9nIHJvdGF0aW9uIGlmID4gMAojIEBleGl0Y29kZSAwIGFsd2F5cyBzdWNjZXNzZnVsCiMgQHN0ZGVyciBkaWFnbm9zdGljcyBpbmZvcm1hdGlvbiBhYm91dCBsb2cgZmlsZSBpcyBkaXNwbGF5ZWQKIyBAcmVxdWlyZSBFbnY6OnJlcXVpcmVMb2FkCiMgQHJlcXVpcmUgVUk6OnJlcXVpcmVUaGVtZQpMb2c6OnJlcXVpcmVMb2FkKCkgewogIGlmIFtbIC16ICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFOi19IiBdXTsgdGhlbgogICAgQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMPSR7X19MRVZFTF9PRkZ9CiAgICBleHBvcnQgQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMCiAgZmkKCiAgaWYgKChCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwgPiBfX0xFVkVMX09GRikpOyB0aGVuCiAgICBpZiBbWyAhIC1mICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFfSIgXV07IHRoZW4KICAgICAgaWYgW1sgISAtZCAiJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRSUvKn0iIF1dOyB0aGVuCiAgICAgICAgaWYgISBta2RpciAtcCAiJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRSUvKn0iIDI+L2Rldi9udWxsOyB0aGVuCiAgICAgICAgICBCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUw9JHtfX0xFVkVMX09GRn0KICAgICAgICAgIGVjaG8gLWUgIiR7X19FUlJPUl9DT0xPUn1FUlJPUiAgIC0gZGlyZWN0b3J5ICR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEUlLyp9IGlzIG5vdCB3cml0YWJsZSR7X19SRVNFVF9DT0xPUn0iID4mMgogICAgICAgIGZpCiAgICAgIGVsaWYgISB0b3VjaCAtLW5vLWNyZWF0ZSAiJHtCQVNIX0ZSQU1FV09SS19MT0dfRklMRX0iIDI+L2Rldi9udWxsOyB0aGVuCiAgICAgICAgQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMPSR7X19MRVZFTF9PRkZ9CiAgICAgICAgZWNobyAtZSAiJHtfX0VSUk9SX0NPTE9SfUVSUk9SICAgLSBGaWxlICR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IGlzIG5vdCB3cml0YWJsZSR7X19SRVNFVF9DT0xPUn0iID4mMgogICAgICBmaQogICAgZWxpZiBbWyAhIC13ICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFfSIgXV07IHRoZW4KICAgICAgQkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMPSR7X19MRVZFTF9PRkZ9CiAgICAgIGVjaG8gLWUgIiR7X19FUlJPUl9DT0xPUn1FUlJPUiAgIC0gRmlsZSAke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFfSBpcyBub3Qgd3JpdGFibGUke19fUkVTRVRfQ09MT1J9IiA+JjIKICAgIGZpCiAgZmkKCiAgaWYgKChCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwgPiBfX0xFVkVMX09GRikpOyB0aGVuCiAgICAjIHdpbGwgYWx3YXlzIGJlIGNyZWF0ZWQgZXZlbiBpZiBub3QgaW4gaW5mbyBsZXZlbAogICAgTG9nOjpsb2dNZXNzYWdlICJJTkZPIiAiTG9nZ2luZyB0byBmaWxlICR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEV9IC0gTG9nIGxldmVsICR7QkFTSF9GUkFNRVdPUktfTE9HX0xFVkVMfSIKICAgIGlmICgoQkFTSF9GUkFNRVdPUktfTE9HX0ZJTEVfTUFYX1JPVEFUSU9OID4gMCkpOyB0aGVuCiAgICAgIExvZzo6cm90YXRlICIke0JBU0hfRlJBTUVXT1JLX0xPR19GSUxFfSIgIiR7QkFTSF9GUkFNRVdPUktfTE9HX0ZJTEVfTUFYX1JPVEFUSU9OfSIKICAgIGZpCiAgZmkKfQoKIyBAZGVzY3JpcHRpb24gRGlzcGxheSBtZXNzYWdlIHVzaW5nIGVycm9yIGNvbG9yIChyZWQpCiMgQGFyZyAkMSBtZXNzYWdlOlN0cmluZyB0aGUgbWVzc2FnZSB0byBkaXNwbGF5CiMgQGVudiBESVNQTEFZX0RVUkFUSU9OIGludCAoZGVmYXVsdCAwKSBpZiAxIGRpc3BsYXkgZWxhcHNlZCB0aW1lIGluZm9ybWF0aW9uIGJldHdlZW4gMiBpbmZvIGxvZ3MKIyBAZW52IExPR19DT05URVhUIFN0cmluZyBhbGxvd3MgdG8gY29udGV4dHVhbGl6ZSB0aGUgbG9nCkxvZzo6ZGlzcGxheUVycm9yKCkgewogIGlmICgoQkFTSF9GUkFNRVdPUktfRElTUExBWV9MRVZFTCA+PSBfX0xFVkVMX0VSUk9SKSk7IHRoZW4KICAgIExvZzo6Y29tcHV0ZUR1cmF0aW9uCiAgICBlY2hvIC1lICIke19fRVJST1JfQ09MT1J9RVJST1IgICAtICR7TE9HX0NPTlRFWFQ6LX0ke0xPR19MQVNUX0RVUkFUSU9OX1NUUjotfSR7MX0ke19fUkVTRVRfQ09MT1J9IiA+JjIKICBmaQogIExvZzo6bG9nRXJyb3IgIiQxIgp9CgojIEBkZXNjcmlwdGlvbiBUbyBiZSBjYWxsZWQgYmVmb3JlIGxvZ2dpbmcgaW4gdGhlIGxvZyBmaWxlCiMgQGFyZyAkMSBmaWxlOnN0cmluZyBsb2cgZmlsZSBuYW1lCiMgQGFyZyAkMiBtYXhMb2dGaWxlc0NvdW50OmludCBtYXhpbXVtIG51bWJlciBvZiBsb2cgZmlsZXMKTG9nOjpyb3RhdGUoKSB7CiAgbG9jYWwgZmlsZT0iJDEiCiAgbG9jYWwgbWF4TG9nRmlsZXNDb3VudD0iJHsyOi01fSIKCiAgaWYgW1sgISAtZiAiJHtmaWxlfSIgXV07IHRoZW4KICAgIExvZzo6ZGlzcGxheURlYnVnICJMb2cgZmlsZSAke2ZpbGV9IGRvZXNuJ3QgZXhpc3QgeWV0IgogICAgcmV0dXJuIDAKICBmaQogIGxvY2FsIGkKICBmb3IgKChpID0gbWF4TG9nRmlsZXNDb3VudCAtIDE7IGkgPiAwOyBpLS0pKTsgZG8KICAgIExvZzo6ZGlzcGxheUluZm8gIkxvZyByb3RhdGlvbiAke2ZpbGV9LiR7aX0gdG8gJHtmaWxlfS4kKChpICsgMSkpIgogICAgbXYgIiR7ZmlsZX0uInsiJHtpfSIsIiQoKGkgKyAxKSkifSAmPi9kZXYvbnVsbCB8fCB0cnVlCiAgZG9uZQogIGlmIGNwICIke2ZpbGV9IiAiJHtmaWxlfS4xIiAmPi9kZXYvbnVsbDsgdGhlbgogICAgZWNobyA+IiR7ZmlsZX0iICMgcmVzZXQgbG9nIGZpbGUKICAgIExvZzo6ZGlzcGxheUluZm8gIkxvZyByb3RhdGlvbiAke2ZpbGV9IHRvICR7ZmlsZX0uMSIKICBmaQp9CgojIEBkZXNjcmlwdGlvbiBsb2FkIGNvbG9yIHRoZW1lCiMgQG5vYXJncwojIEBlbnYgQkFTSF9GUkFNRVdPUktfVEhFTUUgU3RyaW5nIHRoZW1lIHRvIHVzZQojIEBlbnYgTE9BRF9USEVNRSBpbnQgMCB0byBhdm9pZCBsb2FkaW5nIHRoZW1lCiMgQGV4aXRjb2RlIDAgYWx3YXlzIHN1Y2Nlc3NmdWwKVUk6OnJlcXVpcmVUaGVtZSgpIHsKICBpZiBbWyAiJHtMT0FEX1RIRU1FOi0xfSIgPSAiMSIgXV07IHRoZW4KICAgIFVJOjp0aGVtZSAiJHtCQVNIX0ZSQU1FV09SS19USEVNRS1kZWZhdWx0fSIKICBmaQp9CgojIEBkZXNjcmlwdGlvbiBsb2cgbWVzc2FnZSB0byBmaWxlCiMgQGFyZyAkMSBtZXNzYWdlOlN0cmluZyB0aGUgbWVzc2FnZSB0byBkaXNwbGF5CkxvZzo6bG9nRXJyb3IoKSB7CiAgaWYgKChCQVNIX0ZSQU1FV09SS19MT0dfTEVWRUwgPj0gX19MRVZFTF9FUlJPUikpOyB0aGVuCiAgICBMb2c6OmxvZ01lc3NhZ2UgIiR7MjotRVJST1J9IiAiJDEiCiAgZmkKfQoKIyBAZGVzY3JpcHRpb24gbG9hZCBjb2xvcnMgdGhlbWUgY29uc3RhbnRzCiMgQHdhcm5pbmcgaWYgdHR5IG5vdCBvcGVuZWQsIG5vQ29sb3IgdGhlbWUgd2lsbCBiZSBjaG9zZW4KIyBAYXJnICQxIHRoZW1lOlN0cmluZyB0aGUgdGhlbWUgdG8gdXNlIChkZWZhdWx0LCBub0NvbG9yKQojIEBhcmcgJEAgYXJnczpTdHJpbmdbXQojIEBzZXQgX19FUlJPUl9DT0xPUiBTdHJpbmcgaW5kaWNhdGUgZXJyb3Igc3RhdHVzCiMgQHNldCBfX0lORk9fQ09MT1IgU3RyaW5nIGluZGljYXRlIGluZm8gc3RhdHVzCiMgQHNldCBfX1NVQ0NFU1NfQ09MT1IgU3RyaW5nIGluZGljYXRlIHN1Y2Nlc3Mgc3RhdHVzCiMgQHNldCBfX1dBUk5JTkdfQ09MT1IgU3RyaW5nIGluZGljYXRlIHdhcm5pbmcgc3RhdHVzCiMgQHNldCBfX1NLSVBQRURfQ09MT1IgU3RyaW5nIGluZGljYXRlIHNraXBwZWQgc3RhdHVzCiMgQHNldCBfX0RFQlVHX0NPTE9SIFN0cmluZyBpbmRpY2F0ZSBkZWJ1ZyBzdGF0dXMKIyBAc2V0IF9fSEVMUF9DT0xPUiBTdHJpbmcgaW5kaWNhdGUgaGVscCBzdGF0dXMKIyBAc2V0IF9fVEVTVF9DT0xPUiBTdHJpbmcgbm90IHVzZWQKIyBAc2V0IF9fVEVTVF9FUlJPUl9DT0xPUiBTdHJpbmcgbm90IHVzZWQKIyBAc2V0IF9fSEVMUF9USVRMRV9DT0xPUiBTdHJpbmcgdXNlZCB0byBkaXNwbGF5IGhlbHAgdGl0bGUgaW4gaGVscCBzdHJpbmdzCiMgQHNldCBfX0hFTFBfT1BUSU9OX0NPTE9SIFN0cmluZyB1c2VkIHRvIGRpc3BsYXkgaGlnaGxpZ2h0IG9wdGlvbnMgaW4gaGVscCBzdHJpbmdzCiMKIyBAc2V0IF9fUkVTRVRfQ09MT1IgU3RyaW5nIHJlc2V0IGRlZmF1bHQgY29sb3IKIwojIEBzZXQgX19IRUxQX0VYQU1QTEUgU3RyaW5nIHRvIHJlbW92ZQojIEBzZXQgX19IRUxQX1RJVExFIFN0cmluZyB0byByZW1vdmUKIyBAc2V0IF9fSEVMUF9OT1JNQUwgU3RyaW5nIHRvIHJlbW92ZQojIHNoZWxsY2hlY2sgZGlzYWJsZT1TQzIwMzQKVUk6OnRoZW1lKCkgewogIGxvY2FsIHRoZW1lPSIkezEtZGVmYXVsdH0iCiAgaWYgW1sgISAiJHt0aGVtZX0iID1+IC1mb3JjZSQgXV0gJiYgISBBc3NlcnQ6OnR0eTsgdGhlbgogICAgdGhlbWU9Im5vQ29sb3IiCiAgZmkKICBjYXNlICIke3RoZW1lfSIgaW4KICAgIGRlZmF1bHQgfCBkZWZhdWx0LWZvcmNlKQogICAgICB0aGVtZT0iZGVmYXVsdCIKICAgICAgOzsKICAgIG5vQ29sb3IpIDs7CiAgICAqKQogICAgICBMb2c6OmZhdGFsICJpbnZhbGlkIHRoZW1lIHByb3ZpZGVkIgogICAgICA7OwogIGVzYWMKICBpZiBbWyAiJHt0aGVtZX0iID0gImRlZmF1bHQiIF1dOyB0aGVuCiAgICBCQVNIX0ZSQU1FV09SS19USEVNRT0iZGVmYXVsdCIKICAgICMgY2hlY2sgY29sb3JzIGFwcGxpY2FibGUgaHR0cHM6Ly9taXNjLmZsb2dpc29mdC5jb20vYmFzaC90aXBfY29sb3JzX2FuZF9mb3JtYXR0aW5nCiAgICBfX0VSUk9SX0NPTE9SPSdcZVszMW0nICAgICAgICAgIyBSZWQKICAgIF9fSU5GT19DT0xPUj0nXGVbNDRtJyAgICAgICAgICAjIHdoaXRlIG9uIGxpZ2h0Qmx1ZQogICAgX19TVUNDRVNTX0NPTE9SPSdcZVszMm0nICAgICAgICMgR3JlZW4KICAgIF9fV0FSTklOR19DT0xPUj0nXGVbMzNtJyAgICAgICAjIFllbGxvdwogICAgX19TS0lQUEVEX0NPTE9SPSdcZVszM20nICAgICAgICMgWWVsbG93CiAgICBfX0RFQlVHX0NPTE9SPSdcZVszN20nICAgICAgICAgIyBHcmF5CiAgICBfX0hFTFBfQ09MT1I9J1xlWzc7NDk7MzNtJyAgICAgIyBCbGFjayBvbiBHb2xkCiAgICBfX1RFU1RfQ09MT1I9J1xlWzEwMG0nICAgICAgICAgIyBMaWdodCBtYWdlbnRhCiAgICBfX1RFU1RfRVJST1JfQ09MT1I9J1xlWzQxbScgICAgIyB3aGl0ZSBvbiByZWQKICAgIF9fSEVMUF9USVRMRV9DT0xPUj0iXGVbMTszN20iICAjIEJvbGQKICAgIF9fSEVMUF9PUFRJT05fQ09MT1I9IlxlWzE7MzRtIiAjIEJsdWUKICAgICMgSW50ZXJuYWw6IHJlc2V0IGNvbG9yCiAgICBfX1JFU0VUX0NPTE9SPSdcZVswbScgIyBSZXNldCBDb2xvcgogICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMTU1LFNDMjAzNAogICAgX19IRUxQX0VYQU1QTEU9IiQoZWNobyAtZSAiXGVbMjs5N20iKSIKICAgICMgc2hlbGxjaGVjayBkaXNhYmxlPVNDMjE1NSxTQzIwMzQKICAgIF9fSEVMUF9USVRMRT0iJChlY2hvIC1lICJcZVsxOzM3bSIpIgogICAgIyBzaGVsbGNoZWNrIGRpc2FibGU9U0MyMTU1LFNDMjAzNAogICAgX19IRUxQX05PUk1BTD0iJChlY2hvIC1lICJcMDMzWzBtIikiCiAgZWxzZQogICAgQkFTSF9GUkFNRVdPUktfVEhFTUU9Im5vQ29sb3IiCiAgICAjIGNoZWNrIGNvbG9ycyBhcHBsaWNhYmxlIGh0dHBzOi8vbWlzYy5mbG9naXNvZnQuY29tL2Jhc2gvdGlwX2NvbG9yc19hbmRfZm9ybWF0dGluZwogICAgX19FUlJPUl9DT0xPUj0nJwogICAgX19JTkZPX0NPTE9SPScnCiAgICBfX1NVQ0NFU1NfQ09MT1I9JycKICAgIF9fV0FSTklOR19DT0xPUj0nJwogICAgX19TS0lQUEVEX0NPTE9SPScnCiAgICBfX0RFQlVHX0NPTE9SPScnCiAgICBfX0hFTFBfQ09MT1I9JycKICAgIF9fVEVTVF9DT0xPUj0nJwogICAgX19URVNUX0VSUk9SX0NPTE9SPScnCiAgICBfX0hFTFBfVElUTEVfQ09MT1I9JycKICAgIF9fSEVMUF9PUFRJT05fQ09MT1I9JycKICAgICMgSW50ZXJuYWw6IHJlc2V0IGNvbG9yCiAgICBfX1JFU0VUX0NPTE9SPScnCiAgICBfX0hFTFBfRVhBTVBMRT0nJwogICAgX19IRUxQX1RJVExFPScnCiAgICBfX0hFTFBfTk9STUFMPScnCiAgZmkKfQoKIyBAZGVzY3JpcHRpb24gY2hlY2sgaWYgdHR5IChpbnRlcmFjdGl2ZSBtb2RlKSBpcyBhY3RpdmUKIyBAbm9hcmdzCiMgQGV4aXRjb2RlIDEgaWYgdHR5IG5vdCBhY3RpdmUKIyBAZW52IE5PTl9JTlRFUkFDVElWRSBpZiAxIGNvbnNpZGVyIGFzIG5vdCBpbnRlcmFjdGl2ZSBldmVuIGlmIGVudmlyb25tZW50IGlzIGludGVyYWN0aXZlCiMgQGVudiBJTlRFUkFDVElWRSBpZiAxIGNvbnNpZGVyIGFzIGludGVyYWN0aXZlIGV2ZW4gaWYgZW52aXJvbm1lbnQgaXMgbm90IGludGVyYWN0aXZlCkFzc2VydDo6dHR5KCkgewogIGlmIFtbICIke05PTl9JTlRFUkFDVElWRTotMH0iID0gIjEiIF1dOyB0aGVuCiAgICByZXR1cm4gMQogIGZpCiAgaWYgW1sgIiR7SU5URVJBQ1RJVkU6LTB9IiA9ICIxIiBdXTsgdGhlbgogICAgcmV0dXJuIDAKICBmaQogIHR0eSAtcwp9CgojIEBkZXNjcmlwdGlvbiBEaXNwbGF5IG1lc3NhZ2UgdXNpbmcgZXJyb3IgY29sb3IgKHJlZCkgYW5kIGV4aXQgaW1tZWRpYXRlbHkgd2l0aCBlcnJvciBzdGF0dXMgMQojIEBhcmcgJDEgbWVzc2FnZTpTdHJpbmcgdGhlIG1lc3NhZ2UgdG8gZGlzcGxheQojIEBlbnYgRElTUExBWV9EVVJBVElPTiBpbnQgKGRlZmF1bHQgMCkgaWYgMSBkaXNwbGF5IGVsYXBzZWQgdGltZSBpbmZvcm1hdGlvbiBiZXR3ZWVuIDIgaW5mbyBsb2dzCiMgQGVudiBMT0dfQ09OVEVYVCBTdHJpbmcgYWxsb3dzIHRvIGNvbnRleHR1YWxpemUgdGhlIGxvZwpMb2c6OmZhdGFsKCkgewogIExvZzo6Y29tcHV0ZUR1cmF0aW9uCiAgZWNobyAtZSAiJHtfX0VSUk9SX0NPTE9SfUZBVEFMICAgLSAke0xPR19DT05URVhUOi19JHtMT0dfTEFTVF9EVVJBVElPTl9TVFI6LX0kezF9JHtfX1JFU0VUX0NPTE9SfSIgPiYyCiAgTG9nOjpsb2dGYXRhbCAiJDEiCiAgZXhpdCAxCn0KCiMgQGRlc2NyaXB0aW9uIGxvZyBtZXNzYWdlIHRvIGZpbGUKIyBAYXJnICQxIG1lc3NhZ2U6U3RyaW5nIHRoZSBtZXNzYWdlIHRvIGRpc3BsYXkKTG9nOjpsb2dGYXRhbCgpIHsKICBMb2c6OmxvZ01lc3NhZ2UgIiR7MjotRkFUQUx9IiAiJDEiCn0KCiMgRlVOQ1RJT05TCgpmYWNhZGVfbWFpbl9sb2FkQ29uZmlnRmlsZXNzaCgpIHsKCmlmIEFzc2VydDo6ZnVuY3Rpb25FeGlzdHMgaW5pdEZhY2FkZTsgdGhlbgogIGluaXRGYWNhZGUKZmkKTE9BRF9MT0NBTEVfQ09ORklHPSIxIgoKIyBAcmVxdWlyZSBDb21waWxlcjo6RmFjYWRlOjpyZXF1aXJlQ29tbWFuZEJpbkRpcgoKZGVjbGFyZSBkaXI9IiQxIgppZiBbWyAhIC1kICIke2Rpcn0iIF1dOyB0aGVuCiAgcmV0dXJuIDEKZmkKc2hpZnQgfHwgdHJ1ZQpkZWNsYXJlIC1hIGV4dGVuc2lvbnM9KCIkQCIpCmlmICgoJHsjZXh0ZW5zaW9uc1tAXX0gPCAxKSk7IHRoZW4KICBleGl0IDIKZmkKZGVjbGFyZSAtYSBmaW5kQ21kPSgKICBmaW5kICIke2Rpcn0iIC1leGVjdXRhYmxlIC10eXBlICdmLGwnICcoJwopCmZvciBleHQgaW4gIiR7ZXh0ZW5zaW9uc1tAXX0iOyBkbwogIGZpbmRDbWQrPSgtbmFtZSBcKi4iJHtleHR9IiAtbykKZG9uZQp1bnNldCAnZmluZENtZFstMV0nCmZpbmRDbWQrPSgnKScgLXByaW50ZiAnJXBcbicpCgoiJHtmaW5kQ21kW0BdfSIgMj4vZGV2L251bGwgfCBhd2sgLXYgZXh0PSIkKHByaW50ZiAnJXN8JyAiJHtleHRlbnNpb25zW0BdfSIpIiAnCiAgQkVHSU4gewogICAgRlM9Ii4iOwogICAgc3BsaXQoZXh0LCBleHRBcnIsICJ8Iik7CiAgICBmb3IgKGkgaW4gZXh0QXJyKSB7CiAgICAgIGV4dEluZGV4W2V4dEFycltpXV0gPSBpOwogICAgfQogIH0KICBmdW5jdGlvbiBiYXNlbmFtZVdpdGhvdXRFeHRlbnNpb24oZmlsZSkgewogICAgc3ViKCIuKi8iLCAiIiwgZmlsZSkKICAgIHN1YigvXC5bXi5dKyQvLCAiIiwgZmlsZSkKICAgIHJldHVybiBmaWxlCiAgfQogIHsKICAgIGlmICgkTkYgaW4gZXh0SW5kZXgpIHsKICAgICAgZmlsZUJhc2U9YmFzZW5hbWVXaXRob3V0RXh0ZW5zaW9uKCQwKQogICAgICBwcmludCBmaWxlQmFzZSAiXHQiIGV4dEluZGV4WyRORl0gIlx0IiAkMDsKICAgIH0KICB9CicgfCBzb3J0IC10JCdcdCcgLWsxLDEgLWsyLDIgfCBjdXQgLWYzLQoKfQoKZmFjYWRlX21haW5fbG9hZENvbmZpZ0ZpbGVzc2ggIiRAIgo=" \
  "755"

declare -gx embed_file_loadConfigFiles="${PERSISTENT_TMPDIR:-/tmp}/5e427bfb617fb2c95ecd2317839d173a1f8c7b5acbf734cc783bcc0ca35c5852/loadConfigFiles"

Linux::requireTarCommand
Compiler::Embed::extractFileFromBase64 \
  "${PERSISTENT_TMPDIR:-/tmp}/a41b13eb5802e6ccd86d22816a7a8fb4c3675f9887a1b6a716b090ee8b458bf3/talkScript" \
  "cGFyYW0oCiAgICBbUGFyYW1ldGVyKE1hbmRhdG9yeT0kdHJ1ZSwgUG9zaXRpb249MCldCiAgICBbc3RyaW5nXQogICAgJG1zZyA9ICcnCikKCkFkZC1UeXBlIC1Bc3NlbWJseU5hbWUgU3lzdGVtLnNwZWVjaAokc3BlYWsgPSBOZXctT2JqZWN0IFN5c3RlbS5TcGVlY2guU3ludGhlc2lzLlNwZWVjaFN5bnRoZXNpemVyCiRzcGVhay5TcGVhaygkbXNnKQo=" \
  "644"

declare -gx embed_file_talkScript="${PERSISTENT_TMPDIR:-/tmp}/a41b13eb5802e6ccd86d22816a7a8fb4c3675f9887a1b6a716b090ee8b458bf3/talkScript"


helpDescription() {
  echo "Default Zsh configuration"
}

dependencies() {
  echo "installScripts/ShellBashDefaultConfig"
}

listVariables() {
  echo "HOME"
  echo "USERNAME"
  echo "USERGROUP"
}

fortunes() {
  if [[ "${USER_SHELL}" = "/usr/bin/zsh" ]]; then
    echo -e "${__INFO_COLOR}$(scriptName)${__RESET_COLOR} -- Zsh ref card manual ${__HELP_EXAMPLE}<http://www.bash2zsh.com/zsh_refcard/refcard.pdf>${__RESET_COLOR}."
    echo "%"
    if [[ "${ZSH_PREFERRED_THEME:-${ZSH_DEFAULT_THEME}}" != "powerlevel10k/powerlevel10k" ]]; then
      echo -e "${__INFO_COLOR}$(scriptName)${__RESET_COLOR} -- ${__HELP_EXAMPLE}Powerlevel10k${__RESET_COLOR} - use the command ${__HELP_EXAMPLE}p10k configure${__RESET_COLOR} to customize shell prompt."
      echo "%"
    fi
  else
    if command -v zsh &>/dev/null; then
      echo -e "${__INFO_COLOR}$(scriptName)${__RESET_COLOR} -- ${__HELP_EXAMPLE}${USER_SHELL}${__RESET_COLOR} is set as default shell, you can switch to zsh using ${__HELP_EXAMPLE}chsh -s /usr/bin/zsh${__RESET_COLOR}."
      echo "%"
    else
      echo -e "${__INFO_COLOR}$(scriptName)${__RESET_COLOR} -- ${__HELP_EXAMPLE}Zsh${__RESET_COLOR} is not set as your default shell, you can give it a try using ${__HELP_EXAMPLE}installAndConfigure ZshProfile${__RESET_COLOR}."
      echo "%"
    fi
  fi
}

# jscpd:ignore-start
helpVariables() { :; }
defaultVariables() { :; }
checkVariables() { :; }
breakOnConfigFailure() { :; }
breakOnTestFailure() { :; }
isInstallImplemented() { :; }
isTestInstallImplemented() { :; }
isConfigureImplemented() { :; }
isTestConfigureImplemented() { :; }
# jscpd:ignore-end

install() {
  local -a packages=(
    zsh
    # needed by some zinit packages
    subversion
  )
  Linux::Apt::installIfNecessary --no-install-recommends "${packages[@]}"

  Log::displayInfo "install plugin manager"
  if command -v zinit &>/dev/null; then
    zinit self-update
    zinit update --all --parallel
  else
    NO_INPUT=1 NO_TUTORIAL=1 bash -c "$(
      curl \
        --fail --show-error --silent \
        --location https://raw.githubusercontent.com/zdharma-continuum/zinit/HEAD/scripts/install.sh
    )"
  fi
}

assertZshFunctionExists() {
  local functionName="$1"
  zsh -i -c "typeset -f '${functionName}' &>/dev/null" || {
    Log::displayError "Zsh function ${functionName} does not exist"
    return 1
  }
}

testInstall() {
  local -i failures=0
  Assert::commandExists zsh || ((++failures))
  Assert::commandExists "svn" || ((++failures))
  assertZshFunctionExists zinit || ((++failures))
  return "${failures}"
}

configure() {
  if [[ "${PREFERRED_SHELL}" = "ShellZsh" ]]; then
    if [[ "${USER_SHELL}" != "/usr/bin/zsh" ]]; then
      sudo usermod --shell /usr/bin/zsh "${USERNAME}"
      USER_SHELL="/usr/bin/zsh"
      Log::displayHelp "You have to log in/log out to make zsh by default"
    fi
    Log::displayHelp "Zsh is set as default shell, you can switch back to bash using 'chsh -s /usr/bin/bash'"
  fi
  # shellcheck disable=SC2154
  Conf::copyStructure \
    "${embed_dir_conf_dir}" \
    "${CONF_OVERRIDE_DIR}/$(scriptName)" \
    ".bash-dev-env"

  Conf::copyStructure \
    "${embed_dir_conf_dir}" \
    "${CONF_OVERRIDE_DIR}/$(scriptName)" \
    "home" \
    "${HOME}"

  # shellcheck disable=SC2154
  OVERWRITE_CONFIG_FILES=1 Install::file \
    "${embed_file_loadConfigFiles}" \
    "${HOME}/.bash-dev-env/loadConfigFiles"
}

declare -a confFiles=(
  "${HOME}/.bash-dev-env/interactive.d/zsh-syntax-complete-suggest.zsh"
  "${HOME}/.bash-dev-env/interactive.d/zsh-beep.zsh"
  "${HOME}/.bash-dev-env/interactive.d/zsh-history.zsh"
  "${HOME}/.bash-dev-env/interactive.d/zsh-ls-colors.zsh"
  "${HOME}/.bash-dev-env/interactive.d/zsh-ssh.zsh"
  "${HOME}/.bash-dev-env/interactive.d/zsh-z.zsh"
  "${HOME}/.bash-dev-env/themes.d/powerlevel10k.zsh"
  "${HOME}/.bash-dev-env/themes.d/pure.zsh"
  "${HOME}/.bash-dev-env/themes.d/starship.zsh"
  "${HOME}/.bash-dev-env/loadConfigFiles"
  "${HOME}/.zshrc"
  "${HOME}/.zprofile"
  "${HOME}/.p10k.zsh"
)

testConfigure() {
  local -i failures=0
  local file
  for file in "${confFiles[@]}"; do
    Assert::fileExists "${file}" || ((++failures))
  done
  Log::displayInfo "Try to load .zshrc"
  (zsh -i -c 'echo "Hello Zsh"' || exit 1) || {
    Log::displayError "something goes bad while loading ~/.zshrc"
    ((++failures))
  }

  return "${failures}"
}



optionHelpCallback() {
  "ShellZshDefaultConfigCommandHelp"
  exit 0
}

defaultBeforeParseCallback() {
  Env::requireLoad
  UI::requireTheme
  Log::requireLoad
  Linux::requireUbuntu
  Linux::Wsl::requireWsl
}

beforeParseCallback() {
  defaultBeforeParseCallback
}

defaultAfterParseCallback() {
  Engine::Config::loadConfig
}

afterParseCallback() {
  defaultAfterParseCallback
}


# ------------------------------------------
# Command ShellZshDefaultConfigCommand
# ------------------------------------------

# options variables initialization
declare SKIP_CONFIGURE="0"
declare SKIP_INSTALL="0"
declare SKIP_TEST="0"
declare SKIP_DEPENDENCIES="0"
declare PREPARE_EXPORT="0"
declare PROFILE=""
declare optionHelp="0"
declare optionConfig="0"
declare optionBashFrameworkConfig=""
declare optionInfoVerbose="0"
declare optionDebugVerbose="0"
declare optionTraceVerbose="0"
declare optionLogLevel=""
declare optionLogFile=""
declare optionDisplayLevel=""
declare optionNoColor="0"
declare optionTheme="default"
declare optionVersion="0"
declare optionQuiet="0"
# arguments variables initialization
declare command="install"
# @description parse command options and arguments for ShellZshDefaultConfigCommand
ShellZshDefaultConfigCommandParse() {
  Log::displayDebug "Command ${SCRIPT_NAME} - parse arguments: ${BASH_FRAMEWORK_ARGV[*]}"
  Log::displayDebug "Command ${SCRIPT_NAME} - parse filtered arguments: ${BASH_FRAMEWORK_ARGV_FILTERED[*]}"
  SKIP_CONFIGURE="0"
  local -i options_parse_optionParsedCountSKIP_CONFIGURE
  ((options_parse_optionParsedCountSKIP_CONFIGURE = 0)) || true
  SKIP_INSTALL="0"
  local -i options_parse_optionParsedCountSKIP_INSTALL
  ((options_parse_optionParsedCountSKIP_INSTALL = 0)) || true
  SKIP_TEST="0"
  local -i options_parse_optionParsedCountSKIP_TEST
  ((options_parse_optionParsedCountSKIP_TEST = 0)) || true
  SKIP_DEPENDENCIES="0"
  local -i options_parse_optionParsedCountSKIP_DEPENDENCIES
  ((options_parse_optionParsedCountSKIP_DEPENDENCIES = 0)) || true
  PREPARE_EXPORT="0"
  local -i options_parse_optionParsedCountPREPARE_EXPORT
  ((options_parse_optionParsedCountPREPARE_EXPORT = 0)) || true
  PROFILE=""
  local -i options_parse_optionParsedCountPROFILE
  ((options_parse_optionParsedCountPROFILE = 0)) || true
  optionHelp="0"
  local -i options_parse_optionParsedCountOptionHelp
  ((options_parse_optionParsedCountOptionHelp = 0)) || true
  optionConfig="0"
  local -i options_parse_optionParsedCountOptionConfig
  ((options_parse_optionParsedCountOptionConfig = 0)) || true
  optionBashFrameworkConfig=""
  local -i options_parse_optionParsedCountOptionBashFrameworkConfig
  ((options_parse_optionParsedCountOptionBashFrameworkConfig = 0)) || true
  optionInfoVerbose="0"
  local -i options_parse_optionParsedCountOptionInfoVerbose
  ((options_parse_optionParsedCountOptionInfoVerbose = 0)) || true
  optionDebugVerbose="0"
  local -i options_parse_optionParsedCountOptionDebugVerbose
  ((options_parse_optionParsedCountOptionDebugVerbose = 0)) || true
  optionTraceVerbose="0"
  local -i options_parse_optionParsedCountOptionTraceVerbose
  ((options_parse_optionParsedCountOptionTraceVerbose = 0)) || true
  optionLogLevel=""
  local -i options_parse_optionParsedCountOptionLogLevel
  ((options_parse_optionParsedCountOptionLogLevel = 0)) || true
  optionLogFile=""
  local -i options_parse_optionParsedCountOptionLogFile
  ((options_parse_optionParsedCountOptionLogFile = 0)) || true
  optionDisplayLevel=""
  local -i options_parse_optionParsedCountOptionDisplayLevel
  ((options_parse_optionParsedCountOptionDisplayLevel = 0)) || true
  optionNoColor="0"
  local -i options_parse_optionParsedCountOptionNoColor
  ((options_parse_optionParsedCountOptionNoColor = 0)) || true
  optionTheme="default"
  local -i options_parse_optionParsedCountOptionTheme
  ((options_parse_optionParsedCountOptionTheme = 0)) || true
  optionVersion="0"
  local -i options_parse_optionParsedCountOptionVersion
  ((options_parse_optionParsedCountOptionVersion = 0)) || true
  optionQuiet="0"
  local -i options_parse_optionParsedCountOptionQuiet
  ((options_parse_optionParsedCountOptionQuiet = 0)) || true

  command=""
  local -i options_parse_argParsedCountCommand
  ((options_parse_argParsedCountCommand = 0)) || true


  # shellcheck disable=SC2034
  local -i options_parse_parsedArgIndex=0
  while (($# > 0)); do
    local options_parse_arg="$1"
    local argOptDefaultBehavior=0
    case "${options_parse_arg}" in
      # Option 1/19
      # SKIP_CONFIGURE alts --skip-config|--skip-configure|--skip-configuration|-sc
      # type: Boolean min 0 max 1
      --skip-config | --skip-configure | --skip-configuration | -sc)
        # shellcheck disable=SC2034
        SKIP_CONFIGURE="1"

        if ((options_parse_optionParsedCountSKIP_CONFIGURE >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountSKIP_CONFIGURE))
        ;;

      # Option 2/19
      # SKIP_INSTALL alts --skip-install|--skip-installation|-si
      # type: Boolean min 0 max 1
      --skip-install | --skip-installation | -si)
        # shellcheck disable=SC2034
        SKIP_INSTALL="1"

        if ((options_parse_optionParsedCountSKIP_INSTALL >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountSKIP_INSTALL))
        ;;

      # Option 3/19
      # SKIP_TEST alts --skip-test|--skip-tests|-st
      # type: Boolean min 0 max 1
      --skip-test | --skip-tests | -st)
        # shellcheck disable=SC2034
        SKIP_TEST="1"

        if ((options_parse_optionParsedCountSKIP_TEST >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountSKIP_TEST))
        ;;

      # Option 4/19
      # SKIP_DEPENDENCIES alts --skip-deps|--skip-dependencies|-sd
      # type: Boolean min 0 max 1
      --skip-deps | --skip-dependencies | -sd)
        # shellcheck disable=SC2034
        SKIP_DEPENDENCIES="1"

        if ((options_parse_optionParsedCountSKIP_DEPENDENCIES >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountSKIP_DEPENDENCIES))
        ;;

      # Option 5/19
      # PREPARE_EXPORT alts --prepare-export|-e
      # type: Boolean min 0 max 1
      --prepare-export | -e)
        # shellcheck disable=SC2034
        PREPARE_EXPORT="1"

        if ((options_parse_optionParsedCountPREPARE_EXPORT >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountPREPARE_EXPORT))
        ;;

      # Option 6/19
      # PROFILE alts --profile|-p
      # type: String min 0 max 1
      --profile | -p)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi

        if ((options_parse_optionParsedCountPROFILE >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountPROFILE))
        # shellcheck disable=SC2034
        PROFILE="$1"
        validateProfile "${options_parse_arg}" "${PROFILE}"

        ;;

      # Option 7/19
      # optionHelp alts --help|-h
      # type: Boolean min 0 max 1
      --help | -h)
        # shellcheck disable=SC2034
        optionHelp="1"

        if ((options_parse_optionParsedCountOptionHelp >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionHelp))
        optionHelpCallback "${options_parse_arg}" "${optionHelp}"

        ;;

      # Option 8/19
      # optionConfig alts --config
      # type: Boolean min 0 max 1
      --config)
        # shellcheck disable=SC2034
        optionConfig="1"

        if ((options_parse_optionParsedCountOptionConfig >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionConfig))
        ;;

      # Option 9/19
      # optionBashFrameworkConfig alts --bash-framework-config
      # type: String min 0 max 1
      --bash-framework-config)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionBashFrameworkConfig >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionBashFrameworkConfig))
        # shellcheck disable=SC2034
        optionBashFrameworkConfig="$1"
        optionBashFrameworkConfigCallback "${options_parse_arg}" "${optionBashFrameworkConfig}"

        ;;

      # Option 10/19
      # optionInfoVerbose alts --verbose|-v
      # type: Boolean min 0 max 1
      --verbose | -v)
        # shellcheck disable=SC2034
        optionInfoVerbose="1"

        if ((options_parse_optionParsedCountOptionInfoVerbose >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionInfoVerbose))
        optionInfoVerboseCallback "${options_parse_arg}" "${optionInfoVerbose}"

        updateArgListInfoVerboseCallback "${options_parse_arg}" "${optionInfoVerbose}"

        ;;

      # Option 11/19
      # optionDebugVerbose alts -vv
      # type: Boolean min 0 max 1
      -vv)
        # shellcheck disable=SC2034
        optionDebugVerbose="1"

        if ((options_parse_optionParsedCountOptionDebugVerbose >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionDebugVerbose))
        optionDebugVerboseCallback "${options_parse_arg}" "${optionDebugVerbose}"

        updateArgListDebugVerboseCallback "${options_parse_arg}" "${optionDebugVerbose}"

        ;;

      # Option 12/19
      # optionTraceVerbose alts -vvv
      # type: Boolean min 0 max 1
      -vvv)
        # shellcheck disable=SC2034
        optionTraceVerbose="1"

        if ((options_parse_optionParsedCountOptionTraceVerbose >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionTraceVerbose))
        optionTraceVerboseCallback "${options_parse_arg}" "${optionTraceVerbose}"

        updateArgListTraceVerboseCallback "${options_parse_arg}" "${optionTraceVerbose}"

        ;;

      # Option 13/19
      # optionLogLevel alts --log-level
      # type: String min 0 max 1
      # authorizedValues: OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE
      --log-level)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi
        if [[ ! "$1" =~ OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE ]]; then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF, ERR, ERROR, WARN, WARNING, INFO, DEBUG, TRACE)"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionLogLevel >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionLogLevel))
        # shellcheck disable=SC2034
        optionLogLevel="$1"
        optionLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"

        updateArgListLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"

        ;;

      # Option 14/19
      # optionLogFile alts --log-file
      # type: String min 0 max 1
      --log-file)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionLogFile >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionLogFile))
        # shellcheck disable=SC2034
        optionLogFile="$1"
        optionLogFileCallback "${options_parse_arg}" "${optionLogFile}"

        updateArgListLogFileCallback "${options_parse_arg}" "${optionLogFile}"

        ;;

      # Option 15/19
      # optionDisplayLevel alts --display-level
      # type: String min 0 max 1
      # authorizedValues: OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE
      --display-level)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi
        if [[ ! "$1" =~ OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE ]]; then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF, ERR, ERROR, WARN, WARNING, INFO, DEBUG, TRACE)"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionDisplayLevel >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionDisplayLevel))
        # shellcheck disable=SC2034
        optionDisplayLevel="$1"
        optionDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"

        updateArgListDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"

        ;;

      # Option 16/19
      # optionNoColor alts --no-color
      # type: Boolean min 0 max 1
      --no-color)
        # shellcheck disable=SC2034
        optionNoColor="1"

        if ((options_parse_optionParsedCountOptionNoColor >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionNoColor))
        optionNoColorCallback "${options_parse_arg}" "${optionNoColor}"

        updateArgListNoColorCallback "${options_parse_arg}" "${optionNoColor}"

        ;;

      # Option 17/19
      # optionTheme alts --theme
      # type: String min 0 max 1
      # authorizedValues: default|default-force|noColor
      --theme)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi
        if [[ ! "$1" =~ default|default-force|noColor ]]; then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(default, default-force, noColor)"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionTheme >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionTheme))
        # shellcheck disable=SC2034
        optionTheme="$1"
        optionThemeCallback "${options_parse_arg}" "${optionTheme}"

        updateArgListThemeCallback "${options_parse_arg}" "${optionTheme}"

        ;;

      # Option 18/19
      # optionVersion alts --version
      # type: Boolean min 0 max 1
      --version)
        # shellcheck disable=SC2034
        optionVersion="1"

        if ((options_parse_optionParsedCountOptionVersion >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionVersion))
        optionVersionCallback "${options_parse_arg}" "${optionVersion}"

        ;;

      # Option 19/19
      # optionQuiet alts --quiet|-q
      # type: Boolean min 0 max 1
      --quiet | -q)
        # shellcheck disable=SC2034
        optionQuiet="1"

        if ((options_parse_optionParsedCountOptionQuiet >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionQuiet))
        optionQuietCallback "${options_parse_arg}" "${optionQuiet}"

        updateArgListQuietCallback "${options_parse_arg}" "${optionQuiet}"

        ;;

      -*)
        if [[ "${argOptDefaultBehavior}" = "0" ]]; then
          Log::displayError "Command ${SCRIPT_NAME} - Invalid option ${options_parse_arg}"
          return 1
        fi
        ;;
      *)
        ((minParsedArgIndex0 = 0)) || true
        ((maxParsedArgIndex0 = 0)) || true
        ((minParsedArgIndex1 = minParsedArgIndex0 + 0)) || true
        ((maxParsedArgIndex1 = maxParsedArgIndex0 + 1)) || true
        ((incrementArg = 1 ))
        if ((0)); then
          # Technical if - never reached
          :

        # Argument 1/1 - command
        # Argument command min 0 max 1
        # Argument command authorizedValues: helpDescription|scriptName|dependencies|listVariables|fortunes|helpVariables|defaultVariables|checkVariables|breakOnConfigFailure|breakOnTestFailure|isInstallImplemented|install|isTestInstallImplemented|testInstall|isConfigureImplemented|configure|isTestConfigureImplemented|testConfigure
        elif (( options_parse_parsedArgIndex >= minParsedArgIndex0 &&
          options_parse_parsedArgIndex < maxParsedArgIndex1 )); then
          if [[ ! "${options_parse_arg}" =~ helpDescription|scriptName|dependencies|listVariables|fortunes|helpVariables|defaultVariables|checkVariables|breakOnConfigFailure|breakOnTestFailure|isInstallImplemented|install|isTestInstallImplemented|testInstall|isConfigureImplemented|configure|isTestConfigureImplemented|testConfigure ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Argument command - value '${options_parse_arg}' is not part of authorized values(helpDescription, scriptName, dependencies, listVariables, fortunes, helpVariables, defaultVariables, checkVariables, breakOnConfigFailure, breakOnTestFailure, isInstallImplemented, install, isTestInstallImplemented, testInstall, isConfigureImplemented, configure, isTestConfigureImplemented, testConfigure)"
            return 1
          fi
          if ((options_parse_argParsedCountCommand >= 1 )); then
            Log::displayError "Command ${SCRIPT_NAME} - Argument command - Maximum number of argument occurrences reached(1)"
            return 1
          fi
          ((++options_parse_argParsedCountCommand))
          # shellcheck disable=SC2034
          command="${options_parse_arg}"
          argsInstallScriptCommandCallback "${command}" -- "${@:2}"


        # else too much args
        else


          if [[ "${argOptDefaultBehavior}" = "0" ]]; then
            # too much args and no unknownArgumentCallbacks configured
            Log::displayError "Command ${SCRIPT_NAME} - Argument - too much arguments provided: $*"
            return 1
          fi

        fi
        if ((incrementArg == 1)); then
          ((++options_parse_parsedArgIndex))
        fi
        ;;
    esac
    shift || true
  done || return $?

  commandOptionParseFinished

}

# @description display command options and arguments help for ShellZshDefaultConfigCommand
ShellZshDefaultConfigCommandHelp() {
  echo -e "${__HELP_TITLE_COLOR}SYNOPSIS:${__RESET_COLOR}"
  helpDescriptionFunction


  # ------------------------------------------
  # usage section
  # ------------------------------------------
  Array::wrap2 " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" "ShellZshDefaultConfig [OPTIONS] [ARGUMENTS]"
  echo
  # ------------------------------------------
  # usage/options section
  # ------------------------------------------
  optionsAltList=("[--skip-config|--skip-configure|--skip-configuration|-sc]" "[--skip-install|--skip-installation|-si]" "[--skip-test|--skip-tests|-st]" "[--skip-deps|--skip-dependencies|-sd]" "[--prepare-export|-e]" "[--profile|-p <profile>]" "[--help|-h]" "[--config]" "[--bash-framework-config <bash-framework-config>]" "[--verbose|-v]" "[-vv]" "[-vvv]" "[--log-level <log-level>]" "[--log-file <log-file>]" "[--display-level <display-level>]" "[--no-color]" "[--theme <theme>]" "[--version]" "[--quiet|-q]"
  )
  Array::wrap2 " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" \
    "ShellZshDefaultConfig" "${optionsAltList[@]}"
  echo

  # ------------------------------------------
  # usage/arguments section
  # ------------------------------------------
  echo
  echo -e "${__HELP_TITLE_COLOR}ARGUMENTS:${__RESET_COLOR}"

  Array::wrap2 " " 80 2 "  [${__HELP_OPTION_COLOR}command${__HELP_NORMAL} {single}]"
  Array::wrap2 ' ' 76 4 "    " "The command to run on this install script."
  echo

  echo "    Possible values:"
  Array::wrap2 ' ' 76 8 "      - ${__OPTION_COLOR}helpDescription:${__RESET_COLOR} Show help description of this install script."
  echo
  Array::wrap2 ' ' 76 8 "      - ${__OPTION_COLOR}scriptName:${__RESET_COLOR} Show the internal name of this install script."
  echo
  Array::wrap2 ' ' 76 8 "      - ${__OPTION_COLOR}dependencies:${__RESET_COLOR} Show this install scripts's dependencies."
  echo
  Array::wrap2 ' ' 76 8 "      - ${__OPTION_COLOR}listVariables:${__RESET_COLOR} Show the variables needed to execute this
  install script."
  echo
  Array::wrap2 ' ' 76 8 "      - ${__OPTION_COLOR}fortunes:${__RESET_COLOR} Show the fortunes sentences that this
  install script can generate."
  echo
  echo -e "      - ${__OPTION_COLOR}helpVariables${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}defaultVariables${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}checkVariables${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}breakOnConfigFailure${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}breakOnTestFailure${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}isInstallImplemented${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}install${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}isTestInstallImplemented${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}testInstall${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}isConfigureImplemented${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}configure${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}isTestConfigureImplemented${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}testConfigure${__RESET_COLOR}"

  # ------------------------------------------
  # options section
  # ------------------------------------------
  echo
  echo -e "${__HELP_TITLE_COLOR}SKIP OPTIONS:${__RESET_COLOR}"
  echo -e "  ${__HELP_OPTION_COLOR}--skip-config${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-configure${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-configuration${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-sc${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Skip software configuration."
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--skip-install${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-installation${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-si${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Skip software installation."
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--skip-test${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-tests${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-st${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Skip software installation test."
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--skip-deps${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-dependencies${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-sd${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Install the software requested without resolving dependencies."
  echo

  echo
  echo -e "${__HELP_TITLE_COLOR}EXPORT OPTIONS:${__RESET_COLOR}"
  echo -e "  ${__HELP_OPTION_COLOR}--prepare-export${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-e${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "prepare the wsl installation for export (remove all sensitive files)"
  echo

  echo
  echo -e "${__HELP_TITLE_COLOR}INSTALL OPTIONS:${__RESET_COLOR}"
  echo -e "  ${__HELP_OPTION_COLOR}--profile${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-p <profile>${__HELP_NORMAL} {single}"
  profileHelpFunction


  echo
  echo -e "${__HELP_TITLE_COLOR}GLOBAL OPTIONS:${__RESET_COLOR}"
  echo -e "  ${__HELP_OPTION_COLOR}--help${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-h${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Displays this command help"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--config${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Displays configuration"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--bash-framework-config <bash-framework-config>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Use alternate bash framework configuration."
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--verbose${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-v${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Info level verbose mode (alias of --display-level INFO)"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}-vv${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Debug level verbose mode (alias of --display-level DEBUG)"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}-vvv${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Trace level verbose mode (alias of --display-level TRACE)"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--log-level <log-level>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Set log level"
  echo

  echo "    Possible values: "
  echo -e "      - ${__OPTION_COLOR}OFF${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}ERR${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}ERROR${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}WARN${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}WARNING${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}INFO${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}DEBUG${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}TRACE${__RESET_COLOR}"

  echo -e "  ${__HELP_OPTION_COLOR}--log-file <log-file>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Set log file"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--display-level <display-level>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Set display level"
  echo

  echo "    Possible values: "
  echo -e "      - ${__OPTION_COLOR}OFF${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}ERR${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}ERROR${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}WARN${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}WARNING${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}INFO${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}DEBUG${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}TRACE${__RESET_COLOR}"

  echo -e "  ${__HELP_OPTION_COLOR}--no-color${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Produce monochrome output. alias of --theme noColor."
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--theme <theme>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Choose color theme - default-force means colors will be produced even if command is piped."
  echo

  echo "    Possible values: "
  echo -e "      - ${__OPTION_COLOR}default${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}default-force${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}noColor${__RESET_COLOR}"
  Array::wrap2 ' ' 76 6 "    Default value: " "default"
  echo

  echo -e "  ${__HELP_OPTION_COLOR}--version${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Print version information and quit."
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--quiet${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-q${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Quiet mode, doesn't display any output."
  echo

  # ------------------------------------------
  # longDescription section
  # ------------------------------------------
  echo
  echo
  echo -e "${__HELP_TITLE_COLOR}DESCRIPTION:${__RESET_COLOR}"
  helpLongDescriptionFunction
  # ------------------------------------------
  # version section
  # ------------------------------------------
  echo
  echo -n -e "${__HELP_TITLE_COLOR}VERSION: ${__RESET_COLOR}"
  echo "3.0"
  # ------------------------------------------
  # author section
  # ------------------------------------------
  echo
  echo -n -e "${__HELP_TITLE_COLOR}AUTHOR: ${__RESET_COLOR}"
  echo "[François Chastanet](https://github.com/fchastanet)"
  # ------------------------------------------
  # sourceFile section
  # ------------------------------------------
  echo
  echo -n -e "${__HELP_TITLE_COLOR}SOURCE FILE: ${__RESET_COLOR}"
  echo "https://github.com/fchastanet/bash-dev-env/tree/master/src/_installScripts/_Configs/ShellZshDefaultConfig-binary.yaml"
  # ------------------------------------------
  # license section
  # ------------------------------------------
  echo
  echo -n -e "${__HELP_TITLE_COLOR}LICENSE: ${__RESET_COLOR}"
  echo "MIT License"
  # ------------------------------------------
  # copyright section
  # ------------------------------------------
  Array::wrap2 ' ' 76 0 "$(copyrightCallback)"
}


beforeParseCallback

ShellZshDefaultConfigCommandParse "$@"
MAIN_FUNCTION_NAME="main"
main() {

afterParseCallback
InstallScripts::command

}

# if file is sourced avoid calling main function
# shellcheck disable=SC2178
BASH_SOURCE=".$0" # cannot be changed in bash
# shellcheck disable=SC2128
if test ".$0" == ".${BASH_SOURCE}"; then
  if [[ "${BASH_FRAMEWORK_QUIET_MODE:-0}" = "1" ]]; then
    main "$@" &>/dev/null
  else
    main "$@"
  fi
fi
