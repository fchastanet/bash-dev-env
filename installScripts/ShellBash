#!/usr/bin/env bash
###############################################################################
# GENERATED FACADE FROM https://github.com/fchastanet/bash-dev-env/tree/master/src/_binaries/ShellBash/ShellBash.sh
# DO NOT EDIT IT
# @generated
###############################################################################
# shellcheck disable=SC2288,SC2034
# BIN_FILE=${BASH_DEV_ENV_ROOT_DIR}/installScripts/ShellBash

# ensure that no user aliases could interfere with
# commands used in this script
unalias -a || true
shopt -u expand_aliases

# shellcheck disable=SC2034
((failures = 0)) || true

# Bash will remember & return the highest exit code in a chain of pipes.
# This way you can catch the error inside pipes, e.g. mysqldump | gzip
set -o pipefail
set -o errexit

# Command Substitution can inherit errexit option since bash v4.4
shopt -s inherit_errexit || true

# if set, and job control is not active, the shell runs the last command
# of a pipeline not executed in the background in the current shell
# environment.
shopt -s lastpipe

# a log is generated when a command fails
set -o errtrace

# use nullglob so that (file*.php) will return an empty array if no file
# matches the wildcard
shopt -s nullglob

# ensure regexp are interpreted without accentuated characters
export LC_ALL=POSIX

export TERM=xterm-256color

# avoid interactive install
export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true

# store command arguments for later usage
# shellcheck disable=SC2034
declare -a BASH_FRAMEWORK_ARGV=("$@")
# shellcheck disable=SC2034
declare -a ORIGINAL_BASH_FRAMEWORK_ARGV=("$@")

# @see https://unix.stackexchange.com/a/386856
# shellcheck disable=SC2317
interruptManagement() {
  # restore SIGINT handler
  trap - INT
  # ensure that Ctrl-C is trapped by this script and not by sub process
  # report to the parent that we have indeed been interrupted
  kill -s INT "$$"
}
trap interruptManagement INT
SCRIPT_NAME=${0##*/}
REAL_SCRIPT_FILE="$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")"
if [[ -n "${EMBED_CURRENT_DIR}" ]]; then
  CURRENT_DIR="${EMBED_CURRENT_DIR}"
else
  CURRENT_DIR="$(cd "$(readlink -e "${REAL_SCRIPT_FILE%/*}")" && pwd -P)"
fi

################################################
# Temp dir management
################################################

KEEP_TEMP_FILES="${KEEP_TEMP_FILES:-0}"
export KEEP_TEMP_FILES

# PERSISTENT_TMPDIR is not deleted by traps
PERSISTENT_TMPDIR="${TMPDIR:-/tmp}/bash-framework"
export PERSISTENT_TMPDIR
mkdir -p "${PERSISTENT_TMPDIR}"

# shellcheck disable=SC2034
TMPDIR="$(mktemp -d -p "${PERSISTENT_TMPDIR:-/tmp}" -t bash-framework-$$-XXXXXX)"
export TMPDIR

# temp dir cleaning
# shellcheck disable=SC2317
cleanOnExit() {
  local rc=$?
  if [[ "${KEEP_TEMP_FILES:-0}" = "1" ]]; then
    Log::displayInfo "KEEP_TEMP_FILES=1 temp files kept here '${TMPDIR}'"
  elif [[ -n "${TMPDIR+xxx}" ]]; then
    Log::displayDebug "KEEP_TEMP_FILES=0 removing temp files '${TMPDIR}'"
    rm -Rf "${TMPDIR:-/tmp/fake}" >/dev/null 2>&1
  fi
  exit "${rc}"
}
trap cleanOnExit EXIT HUP QUIT ABRT TERM

# @description concat each element of an array with a separator
# but wrapping text when line length is more than provided argument
# The algorithm will try not to cut the array element if it can.
# - if an arg can be placed on current line it will be,
#   otherwise current line is printed and arg is added to the new
#   current line
# - Empty arg is interpreted as a new line.
# - Add \r to arg in order to force break line and avoid following
#   arg to be concatenated with current arg.
#
# @arg $1 glue:String
# @arg $2 maxLineLength:int
# @arg $3 indentNextLine:int
# @arg $@ array:String[]
Array::wrap2() {
  local glue="${1-}"
  local -i glueLength="${#glue}"
  shift || true
  local -i maxLineLength=$1
  shift || true
  local -i indentNextLine=$1
  shift || true
  local indentStr=""
  if ((indentNextLine > 0)); then
    indentStr="$(head -c "${indentNextLine}" </dev/zero | tr '\0' " ")"
  fi
  if (($# == 0)); then
    return 0
  fi

  printCurrentLine() {
    if ((isNewline == 0)) || ((previousLineEmpty == 1)); then
      echo
    fi
    ((isNewline = 1))
    echo -en "${indentStr}"
    ((currentLineLength = indentNextLine)) || true
  }
  appendToCurrentLine() {
    local text="$1"
    local -i length=$2
    ((currentLineLength += length)) || true
    ((isNewline = 0)) || true
    if [[ "${text: -1}" = $'\r' ]]; then
      text="${text:0:-1}"
      echo -en "${text%%+([[:blank:]])}"
      printCurrentLine
    else
      echo -en "${text%%+([[:blank:]])}"
    fi
  }

  (
    local currentLine
    local -i currentLineLength=0 isNewline=1 argLength=0
    local -a additionalLines
    local -i previousLineEmpty=0
    local arg=""

    while (($# > 0)); do
      arg="$1"
      shift || true

      # replace tab by 2 spaces
      arg="${arg//$'\t'/  }"
      # remove trailing spaces
      arg="${arg%[[:blank:]]}"
      if [[ "${arg}" = $'\n' || -z "${arg}" ]]; then
        printCurrentLine
        ((previousLineEmpty = 1))
        continue
      else
        if ((previousLineEmpty == 1)); then
          printCurrentLine
        fi
        ((previousLineEmpty = 0)) || true
      fi
      # convert eol to args
      mapfile -t additionalLines <<<"${arg}"
      if ((${#additionalLines[@]} > 1)); then
        set -- "${additionalLines[@]}" "$@"
        continue
      fi

      ((argLength = ${#arg})) || true

      # empty arg
      if ((argLength == 0)); then
        if ((isNewline == 0)); then
          # isNewline = 0 means currentLine is not empty
          printCurrentLine
        fi
        continue
      fi

      if ((isNewline == 0)); then
        glueLength="${#glue}"
      else
        glueLength="0"
      fi
      if ((currentLineLength + argLength + glueLength > maxLineLength)); then
        if ((argLength + glueLength > maxLineLength)); then
          # arg is too long to even fit on one line
          # we have to split the arg on current and next line
          local -i remainingLineLength
          ((remainingLineLength = maxLineLength - currentLineLength - glueLength))
          appendToCurrentLine "${glue:0:${glueLength}}${arg:0:${remainingLineLength}}" "$((glueLength + remainingLineLength))"
          printCurrentLine
          arg="${arg:${remainingLineLength}}"
          # remove leading spaces
          arg="${arg##[[:blank:]]}"

          set -- "${arg}" "$@"
        else
          # the arg can fit on next line
          printCurrentLine
          appendToCurrentLine "${arg}" "${argLength}"
        fi
      else
        appendToCurrentLine "${glue:0:${glueLength}}${arg}" "$((glueLength + argLength))"
      fi
    done
    if [[ "${currentLine}" != "" ]] && [[ ! "${currentLine}" =~ ^[\ \t]+$ ]]; then
      printCurrentLine
    fi
  ) | sed -E -e 's/[[:blank:]]+$//'
}

# @description asserts that first argument is file that exists with specified ownership
# @arg $1 file:String
# @arg $2 user:String expected owner user name of the file (default: USERNAME or id -un command)
# @arg $3 group:String expected owner group name of the file (default: USERGROUP or id -gn command)
# @env USERNAME String if arg $2 is not provided
# @env USERGROUP String if arg $3 is not provided
# @env SUDO String allows to use custom sudo prefix command
# @exitcode 1 if missing file
# @exitcode 2 if incorrect user ownership
# @exitcode 3 if incorrect group ownership
# @stderr diagnostics information is displayed
Assert::fileExists() {
  local file="$1"
  local user="${2:-${USERNAME}}"
  local group="${3:-${USERGROUP}}"
  Log::displayInfo "Check ${file} exists with user ${user}:${group}"
  if ! ${SUDO:-} test -f "${file}" &>/dev/null; then
    Log::displayError "missing file ${file}"
    return 1
  fi
  if [[ "${user}" != "$(${SUDO:-} stat -c '%U' "${file}")" ]]; then
    Log::displayError "incorrect user ownership on file ${file}"
    return 2
  fi
  if [[ "${group}" != "$(${SUDO:-} stat -c '%G' "${file}")" ]]; then
    Log::displayError "incorrect group ownership on file ${file}"
    return 3
  fi
}

# @description checks if function name provided exists
# @arg $1 functionName:String
# @exitcode 1 if function name doesn't exist
Assert::functionExists() {
  declare -F "$1" >/dev/null
}

# @description convert base64 encoded back to target dir
# it is advised to include the md5sum of the binFile in the path of the target dir
#
# @arg $1 targetDir:string the directory in which tar archive will be untarred
# @arg $2 base64:string the base64 encoded tar czf archive
# @stderr diagnostics information is displayed
# @require Linux::requireTarCommand
Compiler::Embed::extractDirFromBase64() {
  local targetDir="$1"
  local base64="$2"

  if [[ ! -d "${targetDir}" ]]; then
    mkdir -p "${targetDir}"
    (
      cd "${targetDir}" || exit 1
      base64 -d <<<"${base64}" | tar -xzf - 2>/dev/null || {
        Log::displayError "untar failure, invalid base64 string"
        exit 1
      }
    ) || return 1
  fi
}

Conf::copyStructure() {
  local embedDir="$1"
  local overrideDir="$2"
  local subDir="$3"
  local targetDir="${4:-${USER_HOME}/${subDir}}"

  local configDir
  # shellcheck disable=SC2154
  configDir="$(Conf::getOverriddenDir "${embedDir}" "${overrideDir}")"
  # shellcheck disable=SC2154
  OVERWRITE_CONFIG_FILES=${OVERWRITE_CONFIG_FILES:-1} \
  PRETTY_ROOT_DIR="$(dirname "${embedDir}")" \
  Install::structure "${configDir}/${subDir}" "${targetDir}"
}

# @description generate temp directory where default
# and overridden directories have been merged
#   - if overridden dir exists, create a new temp folder
#     - copy all files from default folder
#     - overwrite with files from overridden folder
#     - (Later) delete files listed in .remove$$ file
#     - return the path of this temp folder
#   - else just return the default folder path
# Then it is easier to pick overridden or default files/folders
#
# @arg $1 defaultDir:String usually the embed directory
# @arg $2 overriddenDirPath:String the path to the directory
#   that could be overridden
# @exitcode 1 if default dir does not exist
# @exitcode 2 if error during copy
Conf::getOverriddenDir() {
  local defaultDir="$1"
  local overriddenDirPath="$2"

  if [[ ! -d "${defaultDir}" ]]; then
    Log::displayError "Directory ${defaultDir} does not exists"
    return 1
  fi
  if [[ ! -d "${overriddenDirPath}" || -z "$(ls -A "${overriddenDirPath}")" ]]; then
    Log::displayInfo "Conf::getOverriddenDir - directory ${overriddenDirPath} does not exist, keep default one ${defaultDir}"
    echo "${defaultDir}"
    return 0
  fi
  local tempDir
  tempDir="$(mktemp -d)"
  (
    shopt -s dotglob
    cp -R "${defaultDir}/." "${tempDir}"
    cp -R "${overriddenDirPath}/." "${tempDir}"
  ) || return 2
  echo "${tempDir}"
}

envFileTemplate="$(
  cat <<'EOF'
# shellcheck disable=SC2034
# wsl username
USERNAME="wsl"
USERGROUP="wsl"
USER_HOME="/home/wsl"

# your login to connect to ssh servers if any
SSH_LOGIN=""

# your git full name 'FirstName LastName'
GIT_USERNAME=""
# email used for git 'ldap@domain.com'
GIT_USER_MAIL=""
# email used to connect to aws
AWS_USER_MAIL="fchastanet@gmail.com"
# app id to connect to aws account
AWS_APP_ID=""
AWS_PROFILE=""
AWS_DEFAULT_REGION=""
AWS_TEST_SECRET_ID=""
AWS_DEFAULT_DOCKER_REGISTRY_ID=""

# hostname of the distro
DISTRO_HOSTNAME="wslHost"

# overridden conf directory that will be used to override
# the default configuration that are embedded in binaries
CONF_OVERRIDE_DIR="${BASH_DEV_ENV_ROOT_DIR}/conf.override"

# where to install bash-tools, ...
# shellcheck disable=SC2153
PROJECTS_DIR="${USER_HOME}/projects"

# where overridden config files will be backed up
BACKUP_DIR="${BASH_DEV_ENV_ROOT_DIR}/backup"
# backup files/dirs before installing new file (usually 1, but 0 if using distro)
BACKUP_BEFORE_INSTALL=1
# logs directory
LOGS_DIR="${BASH_DEV_ENV_ROOT_DIR}/logs"
# installScripts dir
INSTALL_SCRIPTS_DIR="${BASH_DEV_ENV_ROOT_DIR}/installScripts"

# 0   => no upgrade at all
# lts => UPGRADE to latest ubuntu lts version
# dev => UPGRADE to latest ubuntu dev version
# Use if you know what you are doing,
# could cause some packages to not being available yet
UPGRADE_UBUNTU_VERSION=0

# -----------------------------------------
# PROFILES options

# Choose your AWS authenticator tool
# possible choices: Saml2Aws, Awsume
AWS_AUTHENTICATOR="Saml2Aws"

# Choose your preferred shell
# possible choices: ShellBash (Legacy experience), ShellZsh (Recommended experience)
PREFERRED_SHELL="ShellBash"

# Display Fortune tooltip at bash/zsh session open
SHOW_FORTUNES=1

# Display MOTD at bash/zsh session open
SHOW_MOTD=1

# Install Docker inside wsl
DOCKER_INSIDE_WSL=1

# Configuration files are overwritten even if exists
# !!!! First time initialization: let this value to 1 !!!!
# Value 0:
# - If target configuration file exists, displays a message and do not overwrite the file
# - If target configuration file doesn't exist, installs the file
# Value 1
# - install or overwrite the file without checking existence
OVERWRITE_CONFIG_FILES=1

# Windows files can be overridden if 1
# if 0
# - skip changes to %USERPROFILE%/.wslconfig
# - skip copying fonts
CHANGE_WINDOWS_FILES=1

# Indicate that install script can warn you using speaker when your input is needed
CAN_TALK_DURING_INSTALLATION=${CAN_TALK_DURING_INSTALLATION:-1}

# if 0 install script will skip all interactive activity (saml2aws, ...),
# so dependent installation will be skipped as well
INSTALL_INTERACTIVE=${INSTALL_INTERACTIVE:-1}

# display elapsed time since last log
DISPLAY_DURATION=1

# -----------------------------------------
# WSLCONFIG - these parameters will help to automatically
# configure %USERPROFILE%/.wslconfig file
# Adjust these values to your needs
# @see https://docs.microsoft.com/en-us/windows/wsl/wsl-config
# Recommended 50% of total memory
WSLCONFIG_MAX_MEMORY=8GB
# personally I prefer run out of memory instead of beginning swapping
# So I know immediately if some processes have to be stopped
WSLCONFIG_SWAP=0

# -----------------------------------------
# Hacks
# on some configurations we have to force path of some windows commands
#POWERSHELL_BIN=/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe
#IPCONFIG_BIN=/mnt/c/Windows/system32/ipconfig.exe
#WSL_EXE_BIN=/mnt/c/Windows/system32/wsl.exe
EOF
)"

# @description load .env file
# @arg $1 envFile:String the file to load
Engine::Config::loadConfig() {
  if [[ "${BASH_DEV_ENV_CONFIG_LOADED:-0}" = "1" ]]; then
    return 0
  fi
  local envFile="${BASH_DEV_ENV_ROOT_DIR}/.env"
  Engine::Config::createEnvFileFromTemplate \
    "${envFile}" "${envFileTemplate}" || exit 1
  set -o allexport
  # shellcheck source=/.env.template
  source <(echo "${envFileTemplate}")
  # shellcheck source=/.env
  source "${BASH_DEV_ENV_ROOT_DIR}/.env"
  set +o allexport

  # load environment variables ID, VERSION_CODENAME
  Engine::Config::loadOsRelease

  if ! Engine::Config::checkEnv; then
    Log::displayError "one or more variables are invalid, check above logs and fix '${envFile}' file accordingly"
    return 1
  fi

  Engine::Config::loadUserVariables
  Engine::Config::loadHostIp

  Engine::Config::requireWslu

  #Linux::Wsl::initEnv
  Engine::Config::loadWslVariables

  Log::requireLoad

  export PATH="${PATH}:${USER_HOME}/.local/bin"

  export BASH_DEV_ENV_CONFIG_LOADED=1
}

# @description ensure env files are loaded
# @arg $@ list of default files to load at the end
# @exitcode 1 if one of env files fails to load
# @stderr diagnostics information is displayed
# shellcheck disable=SC2120
Env::requireLoad() {
  local -a defaultFiles=("$@")
  # get list of possible config files
  local -a configFiles=()
  if [[ -n "${BASH_FRAMEWORK_ENV_FILES[0]+1}" ]]; then
    # BASH_FRAMEWORK_ENV_FILES is an array
    configFiles+=("${BASH_FRAMEWORK_ENV_FILES[@]}")
  fi
  if [[ -f "$(pwd)/.framework-config" ]]; then
    configFiles+=("$(pwd)/.framework-config")
  fi
  if [[ -f "${FRAMEWORK_ROOT_DIR}/.framework-config" ]]; then
    configFiles+=("${FRAMEWORK_ROOT_DIR}/.framework-config")
  fi
  configFiles+=("${optionEnvFiles[@]}")
  configFiles+=("${defaultFiles[@]}")

  for file in "${configFiles[@]}"; do
    # shellcheck source=/.framework-config
    CURRENT_LOADED_ENV_FILE="${file}" source "${file}" || {
      Log::displayError "while loading config file: ${file}"
      return 1
    }
  done
}

# @description create a temp file using default TMPDIR variable
# initialized in _includes/_commonHeader.sh
# @env TMPDIR String (default value /tmp)
# @arg $1 templateName:String template name to use(optional)
Framework::createTempFile() {
  mktemp -p "${TMPDIR:-/tmp}" -t "${1:-}.XXXXXXXXXXXX"
}

# @description installs file to given directory
#
# callbacks parameters `${fromFile} ${targetFile} $@`
# @arg $1 fromFile - original file to copy
# @arg $2 targetFile - target file
# @arg $3 userName:String (optional) (default: ${USERNAME}) the user name that will be used to set target files ownership
# @arg $4 userGroup:String (optional) (default: ${USERNAME}) the group name that will be used to set target files ownership
# @arg $5 successCallback:Function the callback to call when file is installed successfully, by default setUserRights callback is called
# @arg $6 failureCallback:Function the callback to call when file installation has failed, by default unableToCopyCallback callback is called
# @arg $@ callbacksParams:String[] additional parameters passed to callbacks
# @exitcode 1 if fromFile is not readable
# @exitcode 2 if backup file failure
# @exitcode 3 if copy failure
# @exitcode 0 on success or if OVERWRITE_CONFIG_FILES=0
# @exitcode 0 on success or if CHANGE_WINDOWS_FILES=0 and target file is a windows file
# @env OVERWRITE_CONFIG_FILES Boolean (default:0) if 1 will overwrite existing directory
# @env CHANGE_WINDOWS_FILES Boolean (default:0) if 1 and target file is in windows file system, overwrite it
# @env USERNAME (default: root) the user name that will be used to set target files ownership
# @env USERGROUP (default: root) the group name that will be used to set target files ownership
# @env BASE_MNT_C String windows C drive base PATH
# @env FRAMEWORK_ROOT_DIR used to make paths relative to this directory to reduce length of messages
# @env SUDO String allows to use custom sudo prefix command
# @env BACKUP_BEFORE_INSTALL Boolean (default: 1) backup file before installing the file
Install::file() {
  local fromFile="$1"
  local targetFile="$2"
  local userName="${3:-${USERNAME:-root}}"
  local userGroup="${4:-${USERGROUP:-root}}"
  local successCallback=${5:-Install::setUserRightsCallback}
  local failureCallback=${6:-Install::unableToCopyCallback}
  shift 6 || true

  if [[ ! -f "${fromFile}" || ! -r "${fromFile}" ]]; then
    Log::displayError "cannot read source file '${fromFile}'"
    return 1
  fi

  # skip if OVERWRITE_CONFIG_FILES is 0 and target file exists
  if [[ "${OVERWRITE_CONFIG_FILES}" = "0" && -f "${targetFile}" ]]; then
    Log::displayWarning "File '${targetFile}' exists - Skip install (because OVERWRITE_CONFIG_FILES=0 in .env file)"
    return 0
  fi

  # skip if CHANGE_WINDOWS_FILES is 0 and target dir is c drive
  if [[ "${CHANGE_WINDOWS_FILES}" = "0" && "${targetFile}" =~ ^${BASE_MNT_C} ]]; then
    Log::displayWarning "File '${targetFile}' - Skip install (because CHANGE_WINDOWS_FILES=0 in .env file)"
    return 0
  fi

  local targetDir
  targetDir="$(dirname "${targetFile}")"
  if [[ ! -d "${targetDir}" ]]; then
    ${SUDO:-} mkdir -p "${targetDir}"
    ${SUDO:-} chown "${userName}":"${userGroup}" "${targetDir}"
  fi
  local fromDir
  fromDir="$(dirname "${fromFile}")"
  local fromFilename
  fromFilename="$(basename "${fromFile}")"

  local prettyFromDir
  # shellcheck disable=SC2295
  prettyFromDir="${fromDir#${PRETTY_ROOT_DIR:-${FRAMEWORK_ROOT_DIR}}/}"
  if diff -q "${fromFile}" "${targetFile}" &>/dev/null; then
    Log::displayStatus "No changes detected. No need to update '${targetFile}' from '${prettyFromDir}/${fromFilename}'"
    return 0
  fi

  if [[ "${BACKUP_BEFORE_INSTALL:-1}" = "1" ]] ; then
    Backup::file "${targetFile}" || return 2
  fi

  if ${SUDO:-} cp "${fromFile}" "${targetFile}"; then
    # shellcheck disable=SC2295
    Log::displaySuccess "Installed file '${targetFile}' from '${prettyFromDir}/${fromFilename}'"
    ${successCallback} "${fromFile}" "${targetFile}" "${userName}" "${userGroup}" "${prettyFromDir}" "${fromFilename}"
  else
    # shellcheck disable=SC2295
    Log::displayError "unable to copy file '${targetFile}' from '${fromDir#${FRAMEWORK_ROOT_DIR}/}/${fromFilename}'"
    ${failureCallback} "${fromFile}" "${targetFile}" "${userName}" "${userGroup}" "${prettyFromDir}" "${fromFilename}"
    return 3
  fi
}

# @description the command launch different actions(install, configure, test)
# depending on the options selected
# @see src/_includes/install.skip.options.tpl
# @env SKIP_INSTALL
# @env SKIP_CONFIGURE
# @env SKIP_TEST
# @env LOGS_DIR
InstallScripts::command() {
  local logsDir="${LOGS_DIR:-#}"
  local scriptName
  scriptName="$(scriptName)"
  rm -f "${logsDir}/${scriptName}-.*" || true

  # shellcheck disable=SC2317
  onInterrupt() {
    Log::displayError "${scriptName} aborted"
    exit 1
  }
  trap onInterrupt INT TERM ABRT

  local startDate logFile statsFile
  local installStatus="0"
  sourceHook() {
    local hookName="$1"
    # shellcheck disable=SC2154
    hook="$(IGNORE_ERROR=1 Conf::dynamicConfFile "${scriptName}/${hookName}.sh" "${embed_dir_hooks_dir}/${hookName}.sh")"
    if [[ -x "${hook}" ]]; then
      # shellcheck source=src/_binaries/SimpleTest/conf/preInstall.sh
      source "${hook}" || exit 1
    fi
  }
  local globalStatsFile="${logsDir}/${scriptName}-global.stat"
  local hook
  if [[ "${SKIP_INSTALL}" = "0" ]] && ! InstallScripts::scriptFunctionEmpty install; then
    Log::headLine "INSTALL" "Installing ${scriptName}"
    logFile="${logsDir}/${scriptName}-install.log"
    statsFile="${logsDir}/${scriptName}-install.stat"

    # break at first install error
    (
      startDate="$(date +%s)"
      # shellcheck disable=SC2317
      computeStats() {
        local rc=$?
        Stats::computeStatsTrap "${logFile}" "${statsFile}" "${startDate}"
        Stats::computeStatsTrap "${logFile}" "${globalStatsFile}" "${startDate}"
        Stats::statusLine "${statsFile}" "Installation ${scriptName}"
        exit "${rc}"
      }
      trap 'computeStats' EXIT INT TERM ABRT

      local -i failures=0
      sourceHook preInstall || ((++failures))
      install || ((++failures))
      sourceHook postInstall || ((++failures))
      exit "${failures}"
    ) 2>&1 | tee "${logFile}"
  fi

  local testInstallStatus="0"
  if [[ "${SKIP_TEST}" = "0" && "${installStatus}" = "0" ]] &&
    ! InstallScripts::scriptFunctionEmpty testInstall; then
    Log::headLine "TEST" "Testing ${scriptName} installation"
    logFile="${logsDir}/${scriptName}-test-install.log"
    statsFile="${logsDir}/${scriptName}-test-install.stat"
    (
      startDate="$(date +%s)"
      # shellcheck disable=SC2317
      computeStats() {
        local rc=$?
        Stats::computeStatsTrap "${logFile}" "${statsFile}" "${startDate}"
        Stats::computeStatsTrap "${logFile}" "${globalStatsFile}" "${startDate}"
        Stats::statusLine "${statsFile}" "Test Install ${scriptName}"
        exit "${rc}"
      }
      trap 'computeStats' EXIT INT TERM ABRT

      local -i failures=0
      sourceHook preTestInstall || ((++failures))
      testInstall || ((++failures))
      sourceHook postTestInstall || ((++failures))
      exit "${failures}"
    ) 2>&1 | tee "${logFile}" || testInstallStatus="$?" || true
    if [[ "${testInstallStatus}" != "0" ]] && breakOnTestFailure; then
      # break if test script error
      exit "${testInstallStatus}"
    fi
  fi

  local configStatus="0"
  if [[ "${SKIP_CONFIGURE}" = "0" && "${installStatus}" = "0" ]] &&
    ! InstallScripts::scriptFunctionEmpty configure; then
    Log::headLine "CONFIG" "Configuring ${scriptName}"
    logFile="${logsDir}/${scriptName}-config.log"
    statsFile="${logsDir}/${scriptName}-config.stat"
    (
      startDate="$(date +%s)"
      # shellcheck disable=SC2317
      computeStats() {
        local rc=$?
        Stats::computeStatsTrap "${logFile}" "${statsFile}" "${startDate}"
        Stats::computeStatsTrap "${logFile}" "${globalStatsFile}" "${startDate}"
        Stats::statusLine "${statsFile}" "Configuration ${scriptName}"
        exit "${rc}"
      }
      trap 'computeStats' EXIT INT TERM ABRT

      local -i failures=0
      sourceHook preConfigure || ((++failures))
      configure || ((++failures))
      sourceHook postConfigure || ((++failures))
      exit "${failures}"
    ) 2>&1 | tee "${logFile}" || configStatus="$?" || true

    if [[ "${configStatus}" != "0" ]] && breakOnConfigFailure; then
      # break if config script error
      exit "${configStatus}"
    fi
  fi

  local testConfigStatus="0"
  if [[ "${SKIP_TEST}" = "0" && "${installStatus}" = "0" && "${configStatus}" = "0" ]] &&
    ! InstallScripts::scriptFunctionEmpty configure; then
    Log::headLine "TEST" "Testing ${scriptName} configuration"
    logFile="${logsDir}/${scriptName}-test-configuration.log"
    statsFile="${logsDir}/${scriptName}-test-configuration.stat"
    (
      startDate="$(date +%s)"
      # shellcheck disable=SC2317
      computeStats() {
        local rc=$?
        Stats::computeStatsTrap "${logFile}" "${statsFile}" "${startDate}"
        Stats::computeStatsTrap "${logFile}" "${globalStatsFile}" "${startDate}"
        Stats::statusLine "${statsFile}" "Test Configuration ${scriptName}"
        exit "${rc}"
      }
      trap 'computeStats' EXIT INT TERM ABRT

      local -i failures=0
      sourceHook preTestConfigure || ((++failures))
      testConfigure || ((++failures))
      sourceHook postTestConfigure || ((++failures))
      exit "${failures}"
    ) 2>&1 | tee "${logFile}" || testConfigStatus="$?" || true
    if [[ "${testConfigStatus}" != "0" ]] && breakOnTestFailure; then
      # break if test script error
      exit "${testConfigStatus}"
    fi
  fi
}

# @description check if function is empty
# @arg $1 function:Function
# @exitcode 0 if function is considered empty (body with : or true)
InstallScripts::scriptFunctionEmpty() {
  local pattern="^[ \t]+(:|true)"
  [[ "$(declare -f "$1" | sed '3q;d')" =~ ${pattern} && "$(declare -f "$1" | sed '4q;d')" = "}" ]]
}

# @description apt-get install
# @arg $@ softwares:String[] list of softwares to install
# @feature Retry::default
# Linux::requireSudoCommand
# @require Linux::requireUbuntu
# @stdout diagnostics logs
Linux::Apt::install() {
  Log::displayInfo "Apt install $*"
  Retry::default sudo apt-get install -y -q "$@"
}

# @description update apt packages list
# @feature Retry::default
# Linux::requireSudoCommand
# @require Linux::requireUbuntu
# @stdout diagnostics logs
Linux::Apt::update() {
  Log::displayInfo "Apt update ..."
  Retry::default sudo apt-get update -y --fix-missing -o Acquire::ForceIPv4=true
}

# @description retrieve wslpath using cache (cache is refreshed every day)
# @arg $@ args:String[] arguments to pass to wslpath
# @env WSL_TMPDIR String temp directory to store the wslpath cache (default value: TMPDIR), you can use PERSISTENT_TMPDIR instead
# @exitcode * if Linux::Wsl::originalWslpath cannot find the path
# @stderr diagnostics information is displayed
# @require Linux::Wsl::requireWsl
# @feature cache
Linux::Wsl::cachedWslpath() {
  local -a args=("$@")
  local tempEnvFile key
  tempEnvFile="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}/bash_tools_wslpath_$(id -un)"

  key="$(Linux::Wsl::getKeyFromWslpathOptions "$@")"
  Cache::getPropertyValue "${tempEnvFile}" "${key}" Linux::Wsl::originalWslpath "${args[@]}"
}

# @description Log namespace provides 2 kind of functions
# - Log::display* allows to display given message with
#   given display level
# - Log::log* allows to log given message with
#   given log level
# Log::display* functions automatically log the message too
# @see Env::requireLoad to load the display and log level from .env file

# @description log level off
export __LEVEL_OFF=0
# @description log level error
export __LEVEL_ERROR=1
# @description log level warning
export __LEVEL_WARNING=2
# @description log level info
export __LEVEL_INFO=3
# @description log level success
export __LEVEL_SUCCESS=3
# @description log level debug
export __LEVEL_DEBUG=4

# @description verbose level off
export __VERBOSE_LEVEL_OFF=0
# @description verbose level info
export __VERBOSE_LEVEL_INFO=1
# @description verbose level info
export __VERBOSE_LEVEL_DEBUG=2
# @description verbose level info
export __VERBOSE_LEVEL_TRACE=3

# @description Display message using debug color (grey)
# @arg $1 message:String the message to display
Log::displayDebug() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_DEBUG)); then
    Log::computeDuration
    echo -e "${__DEBUG_COLOR}DEBUG   - ${LOG_LAST_DURATION_STR}${1}${__RESET_COLOR}" >&2
  fi
  Log::logDebug "$1"
}

# @description Display message using error color (red)
# @arg $1 message:String the message to display
Log::displayError() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_ERROR)); then
    Log::computeDuration
    echo -e "${__ERROR_COLOR}ERROR   - ${LOG_LAST_DURATION_STR}${1}${__RESET_COLOR}" >&2
  fi
  Log::logError "$1"
}

# @description Display message using info color (bg light blue/fg white)
# @arg $1 message:String the message to display
Log::displayHelp() {
  local type="${2:-HELP}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__HELP_COLOR}${type}    - ${LOG_LAST_DURATION_STR}${1}${__RESET_COLOR}" >&2
  fi
  Log::logHelp "$1" "${type}"
}

# @description Display message using info color (bg light blue/fg white)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
Log::displayInfo() {
  local type="${2:-INFO}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__INFO_COLOR}${type}    - ${LOG_LAST_DURATION_STR}${1}${__RESET_COLOR}" >&2
  fi
  Log::logInfo "$1" "${type}"
}

# @description Display message using warning color (yellow)
# @arg $1 message:String the message to display
Log::displayWarning() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_WARNING)); then
    Log::computeDuration
    echo -e "${__WARNING_COLOR}WARN    - ${LOG_LAST_DURATION_STR}${1}${__RESET_COLOR}" >&2
  fi
  Log::logWarning "$1"
}

# @description Display message using error color (red) and exit immediately with error status 1
# @arg $1 message:String the message to display
Log::fatal() {
  Log::computeDuration
  echo -e "${__ERROR_COLOR}FATAL   - ${LOG_LAST_DURATION_STR}${1}${__RESET_COLOR}" >&2
  Log::logFatal "$1"
  exit 1
}

# @description activate or not Log::display* and Log::log* functions
# based on BASH_FRAMEWORK_DISPLAY_LEVEL and BASH_FRAMEWORK_LOG_LEVEL
# environment variables loaded by Env::requireLoad
# try to create log file and rotate it if necessary
# @noargs
# @set BASH_FRAMEWORK_LOG_LEVEL int to OFF level if BASH_FRAMEWORK_LOG_FILE is empty or not writable
# @env BASH_FRAMEWORK_DISPLAY_LEVEL int
# @env BASH_FRAMEWORK_LOG_LEVEL int
# @env BASH_FRAMEWORK_LOG_FILE String
# @env BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION int do log rotation if > 0
# @exitcode 0 always successful
# @stderr diagnostics information about log file is displayed
# @require Env::requireLoad
# @require UI::requireTheme
Log::requireLoad() {
  if [[ -z "${BASH_FRAMEWORK_LOG_FILE:-}" ]]; then
    BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
    export BASH_FRAMEWORK_LOG_LEVEL
  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    if [[ ! -f "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      if
        ! mkdir -p "$(dirname "${BASH_FRAMEWORK_LOG_FILE}")" 2>/dev/null ||
          ! touch --no-create "${BASH_FRAMEWORK_LOG_FILE}" 2>/dev/null
      then
        BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
        echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
      fi
    elif [[ ! -w "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
      echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
    fi

  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    # will always be created even if not in info level
    Log::logMessage "INFO" "Logging to file ${BASH_FRAMEWORK_LOG_FILE} - Log level ${BASH_FRAMEWORK_LOG_LEVEL}"
    if ((BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION > 0)); then
      Log::rotate "${BASH_FRAMEWORK_LOG_FILE}" "${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION}"
    fi
  fi
}

# @description Retry a command 5 times with a delay of 15 seconds between each attempt
# @arg $@ command:String[] the command to run
# @exitcode 0 on success
# @exitcode 1 if max retries count reached
Retry::default() {
  Retry::parameterized 5 15 "" "$@"
}

# @description draw a line with the character passed in parameter repeated depending on terminal width
# @arg $1 character:String character to use as separator (default value #)
UI::drawLine() {
  local character="${1:-#}"
  printf -- "${character}%.0s" $(seq "${COLUMNS:-$([[ -t 0 ]] && tput cols || echo '80')}")
}

# @description load colors theme constants
# @warning if tty not opened, noColor theme will be chosen
# @arg $1 theme:String the theme to use (default, noColor)
# @arg $@ args:String[]
# @set __ERROR_COLOR String indicate error status
# @set __INFO_COLOR String indicate info status
# @set __SUCCESS_COLOR String indicate success status
# @set __WARNING_COLOR String indicate warning status
# @set __SKIPPED_COLOR String indicate skipped status
# @set __DEBUG_COLOR String indicate debug status
# @set __HELP_COLOR String indicate help status
# @set __TEST_COLOR String not used
# @set __TEST_ERROR_COLOR String not used
# @set __HELP_TITLE_COLOR String used to display help title in help strings
# @set __HELP_OPTION_COLOR String used to display highlight options in help strings
#
# @set __RESET_COLOR String reset default color
#
# @set __HELP_EXAMPLE String to remove
# @set __HELP_TITLE String to remove
# @set __HELP_NORMAL String to remove
# shellcheck disable=SC2034
UI::theme() {
  local theme="${1-default}"
  if [[ ! "${theme}" =~ -force$ ]] && ! Assert::tty; then
    theme="noColor"
  fi
  case "${theme}" in
    default | default-force)
      theme="default"
      ;;
    noColor) ;;
    *)
      Log::fatal "invalid theme provided"
      ;;
  esac
  if [[ "${theme}" = "default" ]]; then
    BASH_FRAMEWORK_THEME="default"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR='\e[31m'         # Red
    __INFO_COLOR='\e[44m'          # white on lightBlue
    __SUCCESS_COLOR='\e[32m'       # Green
    __WARNING_COLOR='\e[33m'       # Yellow
    __SKIPPED_COLOR='\e[33m'       # Yellow
    __DEBUG_COLOR='\e[37m'         # Grey
    __HELP_COLOR='\e[7;49;33m'     # Black on Gold
    __TEST_COLOR='\e[100m'         # Light magenta
    __TEST_ERROR_COLOR='\e[41m'    # white on red
    __HELP_TITLE_COLOR="\e[1;37m"  # Bold
    __HELP_OPTION_COLOR="\e[1;34m" # Blue
    # Internal: reset color
    __RESET_COLOR='\e[0m' # Reset Color
    # shellcheck disable=SC2155,SC2034
    __HELP_EXAMPLE="$(echo -e "\e[2;97m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_TITLE="$(echo -e "\e[1;37m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_NORMAL="$(echo -e "\033[0m")"
  else
    BASH_FRAMEWORK_THEME="noColor"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR=''
    __INFO_COLOR=''
    __SUCCESS_COLOR=''
    __WARNING_COLOR=''
    __SKIPPED_COLOR=''
    __DEBUG_COLOR=''
    __HELP_COLOR=''
    __TEST_COLOR=''
    __TEST_ERROR_COLOR=''
    __HELP_TITLE_COLOR=''
    __HELP_OPTION_COLOR=''
    # Internal: reset color
    __RESET_COLOR=''
    __HELP_EXAMPLE=''
    __HELP_TITLE=''
    __HELP_NORMAL=''
  fi
}

# @description ensure COMMAND_BIN_DIR env var is set
# and PATH correctly prepared
# @noargs
# @set COMMAND_BIN_DIR string the directory where to find this command
# @set PATH string add directory where to find this command binary
Compiler::Facade::requireCommandBinDir() {
  COMMAND_BIN_DIR="${CURRENT_DIR}"
  Env::pathPrepend "${COMMAND_BIN_DIR}"
}

# @description check if tty (interactive mode) is active
# @noargs
# @exitcode 1 if tty not active
# @env NON_INTERACTIVE if 1 consider as not interactive even if environment is interactive
# @env INTERACTIVE if 1 consider as interactive even if environment is not interactive
Assert::tty() {
  if [[ "${NON_INTERACTIVE:-0}" = "1" ]]; then
    return 1
  fi
  if [[ "${INTERACTIVE:-0}" = "1" ]]; then
    return 0
  fi
  # check if stdout or stderr is connected to terminal
  [[ -t 1 || -t 2 ]]
}

# @description Backup given file in the same directory or in BACKUP_DIR directory
# backup file name is composed by following fields separated by -:
#   - if BACKUP_DIR is not empty then escaped dirname separated by @
#   - filename(without path)
#   - date with format %Y%m%d_%H:%M:%S (Eg: 20240326_14:45:08)
# @arg $1 file:String the file to backup
# @stderr messages about backup file location
# @env SUDO String allows to use custom sudo prefix command
# @env BACKUP_DIR if not set backup the file in the same directory as original file
# @exitcode 1 on copy failure
Backup::file() {
  local file="$1"
  local backupFile dirname escapedDirname
  if [[ -f "${file}" ]]; then
    dirname="$(dirname "${file}")"
    escapedDirname="$(sed -e 's#^/##; s#/#@#g' <<<"${dirname}")"
    if [[ -z "${BACKUP_DIR:-}" ]]; then
      backupFile="${dirname}/$(basename "${file}")-$(date +"%Y%m%d_%H:%M:%S")"
    else
      backupFile="${BACKUP_DIR}/${escapedDirname}@$(basename "${file}")-$(date +"%Y%m%d_%H:%M:%S")"
    fi
    Log::displayInfo "Backup file '${file}' to ${backupFile}"
    ${SUDO:-} cp "${file}" "${backupFile}"
  fi
}

# @description get property value from file
# if not present compute it using propertyNotFoundCallback (if provided) and store it in property file
# @arg $1 propertyFile:String the file in which the property will be searched
# @arg $2 key:String the property key to search in property file
# @arg $3 propertyNotFoundCallback:Function (optional) a callback to call if property key is not found in property file
# @arg $@ args:String[] (optional) the arguments to pass to the propertyNotFoundCallback
# @exitcode 1 if value is not found
# @exitcode * if propertyNotFoundCallback fails
# @stdout the property value given by property file or by the propertyNotFoundCallback
Cache::getPropertyValue() {
  local value
  local propertyFile="$1"
  shift || true
  local key
  key="$(echo -E "$1" | sed -E 's#\\#/#g')"
  shift || true
  local propertyNotFoundCallback=$1
  shift || true

  if grep -E "^${key}=.*" "${propertyFile}" &>/dev/null; then
    grep -E "^${key}=" "${propertyFile}" | cut -d'=' -f2
    return 0
  elif [[ "$(type -t "${propertyNotFoundCallback}")" = "function" ]]; then
    value="$("${propertyNotFoundCallback}" "$@")" || return $?
    if [[ -n "${value}" ]]; then
      echo -E "${key}=${value}" >>"${propertyFile}"
    fi
    echo -E "${value}"
    return 0
  fi
  return 1
}

# @description select right file to load depending if file exists in this order:
# - from conf.override
# - from embedded file if provided
# - from conf dir
# @arg $1 file:String
# @arg $2 embedFile:String eventual embedded file
# @exitcode 1 if file does not exist at all
Conf::dynamicConfFile() {
  local file="${1/#\//}" # remove first slash if any
  local embedFile="${2:-}"
  if [[ -f "${CONF_OVERRIDE_DIR}/${file}" ]]; then
    echo "${CONF_OVERRIDE_DIR}/${file}"
    return 0
  elif [[ -f "${embedFile}" ]]; then
    echo "${embedFile}"
    return 0
  fi
  if [[ "${IGNORE_ERROR:-0}" = "0" ]]; then
    Log::displayWarning "Conf::dynamicConfFile - ${file} does not exist in any config dirs declared"
    return 1
  fi
}

# @description check validity of .env variables
# @env CHECK_ENV int 0 to avoid checking environment
# @noargs
Engine::Config::checkEnv() {
  if [[ "${CHECK_ENV:-1}" = "0" ]]; then
    return 0
  fi
  local errorCount=0 || true
  checkNotEmpty() {
    local var="$1"
    if ! Assert::varExistsAndNotEmpty "${var}"; then
      ((++errorCount))
      return 1
    fi
  }
  checkVarAndDir() {
    local var="$1"
    local mode="${2:-}"
    local status=0
    if checkNotEmpty "${var}"; then
      if ! mkdir -p "${!var}"; then
        Log::displayError "variable ${var} - impossible to create the directory '${!var}'"
        ((errorCount++))
        return 1
      fi
      if [[ "${mode}" =~ w && ! -w "${!var}" ]]; then
        Log::displayError "variable ${var} - directory '${!var}' is not writable"
        ((status++))
        ((errorCount++))
      fi
      if [[ "${mode}" =~ r && ! -r "${!var}" ]]; then
        Log::displayError "variable ${var} - directory '${!var}' is not accessible"
        ((status++))
        ((errorCount++))
      fi
    fi

    return "${status}"
  }
  checkValidValues() {
    local var="$1"
    shift || true
    local -a validValues=("$@")
    if ! Array::contains "${!var}" "${validValues[@]}"; then
      Log::displayError "variable ${var} - value ${!var} is not part of the following values ${validValues[*]}"
      ((++errorCount))
    fi
  }

  if ! echo "${ID}" | grep -qEw 'debian|ubuntu'; then
    Log::fatal "This script is built to support only Debian or Ubuntu distributions. You are using ${ID}."
  fi

  if checkNotEmpty USERNAME && ! getent passwd "${USERNAME}" 2>/dev/null >/dev/null; then
    Log::displayError "USERNAME - user '${USERNAME}' does not exist"
    ((errorCount++))
  fi

  if [[ -n "${SSH_LOGIN:-}" ]] && ! Assert::ldapLogin "${SSH_LOGIN}"; then
    Log::displayError "SSH_LOGIN - invalid ldap login (format expected firstNameLastName) in ${BASH_DEV_ENV_ROOT_DIR}/.env file"
    ((errorCount++))
  fi

  if checkNotEmpty "GIT_USERNAME" && ! Assert::firstNameLastName "${GIT_USERNAME}"; then
    Log::displayError "GIT_USERNAME - invalid format, expected : firstName lastName"
    ((errorCount++))
  fi

  if checkNotEmpty "GIT_USER_MAIL" && ! Assert::emailAddress "${GIT_USER_MAIL}"; then
    Log::displayError "GIT_USER_MAIL - invalid email address"
    ((errorCount++))
  fi

  if checkNotEmpty "AWS_USER_MAIL" && ! Assert::emailAddress "${AWS_USER_MAIL}"; then
    Log::displayError "AWS_USER_MAIL - invalid email address"
    ((errorCount++))
  fi

  checkVarAndDir CONF_OVERRIDE_DIR r || true
  checkVarAndDir PROJECTS_DIR r || true
  checkVarAndDir BACKUP_DIR rw || true
  checkVarAndDir LOGS_DIR rw || true
  checkVarAndDir INSTALL_SCRIPTS_DIR r || true
  checkVarAndDir USER_HOME rw || true

  checkValidValues UPGRADE_UBUNTU_VERSION 0 lts dev
  checkValidValues AWS_AUTHENTICATOR Saml2Aws Awsume
  checkValidValues PREFERRED_SHELL ShellBash ShellZsh

  checkValidValues SHOW_FORTUNES 0 1
  checkValidValues SHOW_MOTD 0 1
  checkValidValues DOCKER_INSIDE_WSL 0 1
  checkValidValues OVERWRITE_CONFIG_FILES 0 1
  checkValidValues CHANGE_WINDOWS_FILES 0 1
  checkValidValues CAN_TALK_DURING_INSTALLATION 0 1
  checkValidValues INSTALL_INTERACTIVE 0 1

  checkNotEmpty WSLCONFIG_MAX_MEMORY
  checkValidValues WSLCONFIG_SWAP 0 1

  return "${errorCount}"
}

# @description if .env does not exist, initialize it with .env.template
Engine::Config::createEnvFileFromTemplate() {
  local envFile="$1"
  local envFileTemplate="$2"

  if [[ ! -f "${envFile}" ]]; then
    echo "${envFileTemplate}" >"${envFile}"
    Log::displayError "a default env file has been created, please edit ${envFile}"
    return 1
  fi
}

# @description deduce wsl host ip
# @set HOST_IP exported env containing the IP
Engine::Config::loadHostIp() {
  HOST_IP="$(/sbin/ip route | awk '/default/ { print $3 }')"

  export HOST_IP
}

# @description load /etc/os-release file
# @set NAME
# @set VERSION
# @set ID
# @set ID_LIKE
# @set PRETTY_NAME
# @set VERSION_ID
# @set HOME_URL
# @set SUPPORT_URL
# @set BUG_REPORT_URL
# @set PRIVACY_POLICY_URL
# @set VERSION_CODENAME
# @set UBUNTU_CODENAME
Engine::Config::loadOsRelease() {
  if [[ ! -f /etc/os-release ]]; then
    Log::displayError "file /etc/os-release does not exists"
    return 1
  fi
  # This will load environment variables ID, VERSION_CODENAME, ...
  set -o allexport
  source /etc/os-release
  set +o allexport
}

# @description deduce USER_HOME, USER_ID, USERGROUP_ID and USERGROUP from USERNAME
# @env USERNAME String the name of the user
# @set USER_ID String
# @set USERGROUP String
# @set USERGROUP_ID String
# @set USER_HOME String
Engine::Config::loadUserVariables() {
  # deduce user home and group
  # shellcheck disable=SC2153
  USER_ID="$(getent passwd "${USERNAME}" | cut -d: -f3)"
  USERGROUP_ID="$(getent passwd "${USERNAME}" | cut -d: -f4)"
  USERGROUP="$(getent group "${USERGROUP_ID}" | cut -d: -f1)"
  USER_HOME="$(getent passwd "${USERNAME}" | cut -d: -f6)"

  if [[ -z "${USERGROUP}" || -z "${USER_HOME}" ]]; then
    Log::displayError "USERNAME - unable to deduce USERGROUP, USER_HOME from USERNAME"
    return 1
  fi

  export USER_HOME
  export USER_ID
  export USERGROUP_ID
  export USERGROUP
}

# @description load wsl env variables
# @set BASE_MNT_C
# @set WINDOWS_DIR
# @set WINDOWS_PROFILE_DIR
# @set LOCAL_APP_DATA
# @set WINDOW_PATH
# @set WSL_EXE_BIN
# @set IPCONFIG_BIN
# @set POWERSHELL_BIN
# @env WSL_EXE_BIN
# @env IPCONFIG_BIN
# @env POWERSHELL_BIN
Engine::Config::loadWslVariables() {
  if ! Assert::wsl; then
    # skip
    return 0
  fi
  # shellcheck disable=SC1003
  BASE_MNT_C="$(mount | grep 'path=C:\\' | awk -F ' ' '{print $3}')"
  export BASE_MNT_C

  WINDOWS_DIR="$(Linux::Wsl::cachedWslpathFromWslVar SystemRoot)"
  WINDOWS_DIR="${WINDOWS_DIR:-${BASE_MNT_C}/Windows}"
  export WINDOWS_DIR

  WINDOWS_PROFILE_DIR="$(Linux::Wsl::cachedWslpathFromWslVar USERPROFILE)"
  WINDOWS_PROFILE_DIR="${WINDOWS_PROFILE_DIR:-${BASE_MNT_C}/Users/$(id -un)}"
  export WINDOWS_PROFILE_DIR

  LOCAL_APP_DATA="$(Linux::Wsl::cachedWslpathFromWslVar LOCALAPPDATA | tr -d '\n\r')"
  export LOCAL_APP_DATA

  # WINDOW_PATH
  WINDOW_PATH="$(Linux::Wsl::cachedWslvar PATH)"
  WINDOW_PATH="${WINDOW_PATH//;/:}"
  WINDOW_PATH="${WINDOW_PATH//\\//}"
  WINDOW_PATH="${WINDOW_PATH//C:/${BASE_MNT_C}}"

  deduceBin() {
    local var="$1"
    local expectedFullPath="$2"
    local expectedBin="$3"
    if [[ -z "${!var+xxx}" ]]; then
      eval "${var}=${expectedFullPath}"
      if ! command -v "${!var}" >/dev/null 2>&1; then
        eval "${var}=$(command -v "${expectedBin}" 2>/dev/null)"
      fi
    fi
    if [[ -z "${!var:-}" ]] || ! command -v "${!var}" >/dev/null 2>&1; then
      Log::fatal "variable ${var} - command ${expectedBin} not found"
    fi
    # shellcheck disable=SC2163
    export "${var}"
  }

  checkBinary() {
    local var="$1"
    if [[ -z "${var}" || ! -x "${!var}" ]]; then
      Log::displayError "variable ${var} - binary '${!var}' does not exist or not executable"
      ((errorCount++))
    fi
  }

  local errorCount=0
  # IPCONFIG_BIN - which ipconfig.exe does not work when executed as root
  deduceBin IPCONFIG_BIN "${WINDOWS_DIR}/System32/ipconfig.exe" "ipconfig.exe"
  checkBinary IPCONFIG_BIN

  deduceBin WSL_EXE_BIN "${WINDOWS_DIR}/System32/wsl.exe" "wsl.exe"
  checkBinary WSL_EXE_BIN

  deduceBin POWERSHELL_BIN "${WINDOWS_DIR}/System32/WindowsPowerShell/v1.0/powershell.exe" "powershell.exe"
  checkBinary POWERSHELL_BIN

  return "${errorCount}"
}

# @description install apt wslu if necessary providing wslvar, wslpath
Engine::Config::requireWslu() {
  if ! command -v wslvar &>/dev/null; then
    Log::displayInfo "Installing pre-requisite Wslu : wslvar, wslpath, ... commands"
    Linux::Apt::update
    Linux::Apt::install --no-install-recommends wslu

    # @see https://github.com/microsoft/WSL/issues/8843#issuecomment-1792256894
    Log::displayInfo "Fix wsl interoperability due to wsl bug"
    if [[ ! -f /usr/lib/binfmt.d/WSLInterop.conf &&
      ! -f /etc/systemd/system/wsl-binfmt.service &&
      -f /run/systemd/generator.early/wsl-binfmt.service ]]; then
      sudo sh -c 'echo :WSLInterop:M::MZ::/init:PF > /usr/lib/binfmt.d/WSLInterop.conf'
      sudo ln -s /run/systemd/generator.early/wsl-binfmt.service /etc/systemd/system/wsl-binfmt.service
    fi
  fi
}

# @description prepend directories to the PATH environment variable
# @arg $@ args:String[] list of directories to prepend
# @set PATH update PATH with the directories prepended
Env::pathPrepend() {
  local arg
  for arg in "$@"; do
    if [[ -d "${arg}" && ":${PATH}:" != *":${arg}:"* ]]; then
      PATH="$(realpath "${arg}"):${PATH}"
    fi
  done
}

# @description install callback
#   set file with root ownership and execution bit
# @arg $1 fromFile:String
# @arg $2 targetFile:String
# @arg $3 userName:String (optional) (default: ${USERNAME}) the user name that will be used to set target files ownership
# @arg $4 userGroup:String (optional) (default: ${USERNAME}) the group name that will be used to set target files ownership
# @env USERNAME (default: root) the user name that will be used to set target files ownership
# @env USERGROUP (default: root) the group name that will be used to set target files ownership
# @env SUDO String allows to use custom sudo prefix command
# @exitcode 1 on any failure
# @see Install::file
Install::setUserRightsCallback() {
  # shellcheck disable=SC2034 # $1 not used
  local fromFile="$1"
  local targetFile="$2"
  local userName="${3:-${USERNAME:-root}}"
  local userGroup="${4:-${USERGROUP:-root}}"

  ${SUDO:-} chown "${userName}":"${userGroup}" "${targetFile}"
}

# @description install dir to given directory but backup it before
# @arg $1 fromDir:String the source base directory
# @arg $2 toDir:String the target base directory
# @env OVERWRITE_CONFIG_FILES Boolean (default:0) if 1 will overwrite existing files
# @env CHANGE_WINDOWS_FILES Boolean (default:0) if 1 and target directory is in windows file system, overwrite it
# @env USERNAME (default: ${USERNAME} if SUDO empty else root) the user name that will be used to set target files ownership
# @env USERGROUP (default: ${USERGROUP} if SUDO empty else root) the group name that will be used to set target files ownership
# @env BASE_MNT_C String windows C drive base PATH
# @env PRETTY_ROOT_DIR used to make paths relative to this directory to reduce length of messages
# @env SUDO String allows to use custom sudo prefix command
# @env BACKUP_BEFORE_INSTALL Boolean (default:1) backup directory before installing the dir
# @exitcode 1 if source directory is not readable
# @exitcode 2 if error during structure replication
# @exitcode 2 if error during file copy
# @exitcode 0 if copy successful
# @exitcode 0 with warning message if CHANGE_WINDOWS_FILES=0 and target directory in C drive
# @stderr diagnostics information is displayed, skipped information if OVERWRITE_CONFIG_FILES or CHANGE_WINDOWS_FILES are set to 1
Install::structure() {
  local fromDir="$1"
  local toDir="$2"
  local userName="root"
  local userGroup="root"
  if [[ -z "${SUDO:-}" ]]; then
    userName="${USERNAME:-root}"
    userGroup="${USERGROUP:-root}"
  fi

  if [[ ! -d "${fromDir}" || ! -r "${fromDir}" ]]; then
    Log::displayError "Install::structure - cannot read source directory '${fromDir}'"
    return 1
  fi

  # skip if CHANGE_WINDOWS_FILES is 0 and target dir is c drive
  if [[ "${CHANGE_WINDOWS_FILES:-0}" = "0" && "${toDir}" =~ ^${BASE_MNT_C} ]]; then
    Log::displayWarning "Install::structure - Directory '${fromDir}' - Skip install (because CHANGE_WINDOWS_FILES=0 in .env file)"
    return 0
  fi

  # first replicate directory structure
  # shellcheck disable=SC2317
  createStructure() {
    local dir="$1"
    if ! ${SUDO:-} mkdir -p "${dir}"; then
      Log::displayError "Install::structure - impossible to create directory '${dir}'"
      exit 1
    fi

    if ! ${SUDO:-} chown "${userName}":"${userGroup}" "${dir}"; then
      Log::displayError "Install::structure - impossible to update directory owner '${dir}' with ${userName}:${userGroup}"
      exit 1
    fi
  }
  local dir

  (
    local dir
    shopt -s lastpipe
    # -links 2 allows to exclude empty directories
    # %P get file without initial directory
    ${SUDO:-} find "${fromDir}" -depth -type d -links 2 -printf "%P\0" |
      while read -rd '' dir; do
        if ! createStructure "${toDir}/${dir}"; then
          # error already reported by createStructure
          exit 1
        fi
      done || {
        if [[ "${PIPESTATUS[0]}" != "0" ]]; then
          Log::displayError "Install::structure - replicated directory structure - find directories on '${fromDir}' resulted in an error"
          exit 2
        fi
      }
  ) || return 2

  # for each file, copy it
  (
    local file
    shopt -s lastpipe
    ${SUDO:-} find "${fromDir}" -depth -type f -printf "%P\0" |
      while read -rd '' file; do
          if ! Install::file "${fromDir}/${file}" "${toDir}/${file}"; then
            # error already reported by Install::file
            exit 1
          fi
      done || {
        if [[ "${PIPESTATUS[0]}" != "0" ]]; then
          Log::displayError "Install::structure - replicated file structure - find files on '${fromDir}' resulted in an error"
          exit 2
        fi
      }
  ) || return 3

  # shellcheck disable=SC2295
  Log::displaySuccess "Installed directory '${toDir#${PRETTY_ROOT_DIR}/}' from '${fromDir#${PRETTY_ROOT_DIR}/}'"
}

# @description install callback
#   default callback used called when file copy has failed
# @arg $1 fromFile:String
# @arg $2 targetFile:String
# @env FRAMEWORK_ROOT_DIR used to make paths relative to this directory to reduce length of messages
# @exitcode 1 always fail
# @stderr diagnostics information is displayed
# @see Install::file
Install::unableToCopyCallback() {
  local fromDir="$1"
  local fileName="$2"
  local targetFile="$3"
  Log::fatal "unable to copy file '${fromDir#"${FRAMEWORK_ROOT_DIR}/"}/${fileName}' to '${targetFile}'"
}

# @description Compute a cache from wslpath options
# @arg $@ args:String[] arguments passed to wslpath
# @stderr diagnostics information is displayed
# @stdout the cache key deduced from the options
# @require Linux::Wsl::requireWsl
# @feature cache
# @internal
Linux::Wsl::getKeyFromWslpathOptions() {
  local options
  options=$(getopt -o "auwm" -- "$@" 2>/dev/null) || {
    Log::displayError "invalid options specified"
    return 1
  }
  local key="wslpath"
  eval set -- "${options}"
  while true; do
    case "$1" in
      -a | -u | -w | -m)
        key="${key}$1"
        ;;
      --)
        shift || true
        break
        ;;
      *)
        shift || true
        Log::displayWarning "Unknown key $1"
        ;;
    esac
    shift || true
  done
  echo -E "${key}_$1"
}

# @description call simply original wslpath command
# @arg $@ args:String[] args to pass to wslpath
# @exitcode * wslpath exit code
# @stdout wslpath stdout
# @require Linux::Wsl::requireWsl
Linux::Wsl::originalWslpath() {
  wslpath "$@"
}

declare -g FIRST_LOG_DATE LOG_LAST_LOG_DATE LOG_LAST_LOG_DATE_INIT LOG_LAST_DURATION_STR
FIRST_LOG_DATE="$(date '+%s%3N')"
LOG_LAST_LOG_DATE="${FIRST_LOG_DATE}"
LOG_LAST_LOG_DATE_INIT=1
LOG_LAST_DURATION_STR=""

# @description Display message using info color (bg light blue/fg white)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
Log::computeDuration() {
  if ((DISPLAY_DURATION == 1)); then
    local -i duration=0
    local -i delta=0
    local -i currentLogDate
    currentLogDate="$(date '+%s%3N')"
    if ((LOG_LAST_LOG_DATE_INIT == 1)); then
      LOG_LAST_LOG_DATE_INIT=0
      LOG_LAST_DURATION_STR="Ref"
    else
      duration=$(((currentLogDate - FIRST_LOG_DATE) / 1000))
      delta=$(((currentLogDate - LOG_LAST_LOG_DATE) / 1000))
      LOG_LAST_DURATION_STR="${duration}s/+${delta}s"
    fi
    LOG_LAST_LOG_DATE="${currentLogDate}"
    # shellcheck disable=SC2034
    LOG_LAST_DURATION_STR="$(date '+%H:%M:%S.%3N')(${LOG_LAST_DURATION_STR}) - "
  else
    # shellcheck disable=SC2034
    LOG_LAST_DURATION_STR=""
  fi
}

# @description Display message using info color (blue) but warning level
# @arg $1 message:String the message to display
Log::displayStatus() {
  local type="${2:-STATUS}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_WARNING)); then
    Log::computeDuration
    echo -e "${__INFO_COLOR}${type}  - ${LOG_LAST_DURATION_STR}${1}${__RESET_COLOR}" >&2
  fi
  Log::logStatus "$1" "${type}"
}

# @description Display message using success color (bg green/fg white)
# @arg $1 message:String the message to display
Log::displaySuccess() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__SUCCESS_COLOR}SUCCESS - ${LOG_LAST_DURATION_STR}${1}${__RESET_COLOR}" >&2
  fi
  Log::logSuccess "$1"
}

# @description Display given text on full line with TEST_COLOR style
# @arg $1 text:String text to display
Log::headLine() {
  local type="$1"
  local text="$2"
  local message="${type}   - ${text}"
  if [[ -z "${type}" ]]; then
    message="${text}"
  else
    Log::computeDuration
    message="$(printf '%-7s - %s%s' "${type}" "${LOG_LAST_DURATION_STR}" "${text}")"
  fi
  echo -e "${__TEST_COLOR}$(UI::textLine "${message}" " ")${__RESET_COLOR}" >&2
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logDebug() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_DEBUG)); then
    Log::logMessage "${2:-DEBUG}" "$1"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logError() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_ERROR)); then
    Log::logMessage "${2:-ERROR}" "$1"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logFatal() {
  Log::logMessage "${2:-FATAL}" "$1"
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logHelp() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-HELP}" "$1"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logInfo() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-INFO}" "$1"
  fi
}

# @description Internal: common log message
# @example text
#   [date]|[levelMsg]|message
#
# @example text
#   2020-01-19 19:20:21|ERROR  |log error
#   2020-01-19 19:20:21|SKIPPED|log skipped
#
# @arg $1 levelMsg:String message's level description (eg: STATUS, ERROR, ...)
# @arg $2 msg:String the message to display
# @env BASH_FRAMEWORK_LOG_FILE String log file to use, do nothing if empty
# @env BASH_FRAMEWORK_LOG_LEVEL int log level log only if > OFF or fatal messages
# @stderr diagnostics information is displayed
# @require Env::requireLoad
# @require Log::requireLoad
Log::logMessage() {
  local levelMsg="$1"
  local msg="$2"
  local date

  if [[ -n "${BASH_FRAMEWORK_LOG_FILE}" ]] && ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    date="$(date '+%Y-%m-%d %H:%M:%S')"
    touch "${BASH_FRAMEWORK_LOG_FILE}"
    printf "%s|%7s|%s\n" "${date}" "${levelMsg}" "${msg}" >>"${BASH_FRAMEWORK_LOG_FILE}"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logWarning() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_WARNING)); then
    Log::logMessage "${2:-WARNING}" "$1"
  fi
}

# @description To be called before logging in the log file
# @arg $1 file:string log file name
# @arg $2 maxLogFilesCount:int maximum number of log files
Log::rotate() {
  local file="$1"
  local maxLogFilesCount="${2:-5}"

  if [[ ! -f "${file}" ]]; then
    Log::displaySkipped "Log file ${file} doesn't exist yet"
    return 0
  fi
  local i
  for ((i = maxLogFilesCount - 1; i > 0; i--)); do
    Log::displayInfo "Log rotation ${file}.${i} to ${file}.$((i + 1))"
    mv "${file}."{"${i}","$((i + 1))"} &>/dev/null || true
  done
  if cp "${file}" "${file}.1" &>/dev/null; then
    echo >"${file}" # reset log file
    Log::displayInfo "Log rotation ${file} to ${file}.1"
  fi
}

# @description Retry a command several times depending on parameters
# @arg $1 maxRetries:int    $1 max retries
# @arg $2 delay:int between attempt
# @arg $3 message:String to display to describe the attempt
# @arg $@ rest of parameters, the command to run
# @exitcode 0 on success
# @exitcode 1 if max retries count reached
# @exitcode 2 if maxRetries invalid value
Retry::parameterized() {
  local maxRetries=$1
  shift || true
  local delayBetweenTries=$1
  shift || true
  local message="$1"
  shift || true
  local retriesCount=1
  if [[ "${maxRetries}" -lt 1 ]]; then
    Log::displayError "invalid maxRetry value"
    return 2
  fi

  while true; do
    Log::displayInfo "Attempt ${retriesCount}/${maxRetries}: ${message}"
    if "$@"; then
      break
    elif [[ "${retriesCount}" -lt "${maxRetries}" ]]; then
      Log::displayWarning "Command failed. Wait for ${delayBetweenTries} seconds"
      ((retriesCount++))
      sleep "${delayBetweenTries}"
    else
      Log::displayError "The command has failed after ${retriesCount} attempts."
      return 1
    fi
  done
  return 0
}

# @description trap function responsible to compute and display stats after each script execution
# @arg $1 logFile:String
# @arg $2 statFile:String
# @arg $3 startDate:String date at which log started
Stats::computeStatsTrap() {
  local status="$?"
  local logFile="$1"
  local statFile="$2"
  local startDate="$3"
  local endDate
  endDate="$(date +%s)"
  Stats::computeFromLog "${logFile}" "${status}" "$((endDate - startDate))" >"${statFile}"
  return "${status}"
}

# @description display message to reflect last installation status
Stats::statusLine() {
  local statFile="$1"
  local msg="$2"
  if [[ ! -f "${statFile}" ]]; then
    return 0
  fi
  Log::computeDuration
  (
    # shellcheck source=src/Stats/logStats.example
    source "${statFile}" || exit 1

    local color="${__TEST_ERROR_COLOR}"
    local statusMsg
    if [[ "${status}" = "0" ]]; then
      if [[ "${skipped}" = "0" ]]; then
        color="${__SUCCESS_COLOR}"
        statusMsg="SUCCESS - ${LOG_LAST_DURATION_STR}${msg} successful"
      else
        color="${__SKIPPED_COLOR}"
        statusMsg="SKIPPED - ${LOG_LAST_DURATION_STR}${msg} skipped"
      fi
    elif [[ "${status}" = "-1" ]]; then
      statusMsg="ABORTED - ${LOG_LAST_DURATION_STR}${msg} not executed"
    else
      statusMsg="ERROR   - ${LOG_LAST_DURATION_STR}${msg} in error"
    fi
    # overwrite final TEST line
    echo -e "${color}${statusMsg}${__RESET_COLOR}"
  )
}

# @description ensure command tar is available
# @exitcode 1 if tar command not available
# @stderr diagnostics information is displayed
Linux::requireTarCommand() {
  Assert::commandExists tar
}

# @description ensure linux distribution is ubuntu
# @exitcode 1 if linux distribution is not ubuntu
Linux::requireUbuntu() {
  if ! Array::contains "$(Linux::getDistributorId)" "Ubuntu" "Debian"; then
    Log::fatal "this script should be executed under Ubuntu or Debian OS"
  fi
}

# @description ensure linux runs under wsl
# @env WSL_GARBAGE_COLLECT int 0 to disable garbage collect of cache files
# @exitcode 1 if linux does not run under wsl
Linux::Wsl::requireWsl() {
  Assert::wsl || return 1
  if [[ "${WSL_GARBAGE_COLLECT:-1}" = "1" ]]; then
    local tempEnvDir
    tempEnvDir="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}"
    File::garbageCollect "${tempEnvDir}/bash_tools_wslpath_$(id -un)" "1"
    tempEnvDir="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}"
    File::garbageCollect "${tempEnvDir}/bash_tools_wslvar_$(id -un)" "1"
  fi
}

# @description load color theme
# @noargs
# @env BASH_FRAMEWORK_THEME String theme to use
# @env LOAD_THEME int 0 to avoid loading theme
# @exitcode 0 always successful
UI::requireTheme() {
  if [[ "${LOAD_THEME:-1}" = "1" ]]; then
    UI::theme "${BASH_FRAMEWORK_THEME-default}"
  fi
}

# @description check if an element is contained in an array
#
# @arg $1 needle:String
# @arg $@ array:String[]
# @exitcode 0 if found
# @exitcode 1 otherwise
# @example
#   Array::contains "${libPath}" "${__BASH_FRAMEWORK_IMPORTED_FILES[@]}"
Array::contains() {
  local element
  for element in "${@:2}"; do
    [[ "${element}" = "$1" ]] && return 0
  done
  return 1
}

# @description check if command specified exists or return 1
# with error and message if not
#
# @arg $1 commandName:String on which existence must be checked
# @arg $2 helpIfNotExists:String a help command to display if the command does not exist
#
# @exitcode 1 if the command specified does not exist
# @stderr diagnostic information + help if second argument is provided
Assert::commandExists() {
  local commandName="$1"
  local helpIfNotExists="$2"

  "${BASH_FRAMEWORK_COMMAND:-command}" -v "${commandName}" >/dev/null 2>/dev/null || {
    Log::displayError "${commandName} is not installed, please install it"
    if [[ -n "${helpIfNotExists}" ]]; then
      Log::displayInfo "${helpIfNotExists}"
    fi
    return 1
  }
  return 0
}

# @description check if param is valid email address
# @warning it is a very simple check, no RFC validation
# @arg $1 emailAddress:String the full email address
# @exitcode 1 if invalid email address
Assert::emailAddress() {
  local expectedRegexp="^\S+@\S+$"

  [[ "$1" =~ ${expectedRegexp} ]]
}

# @description check if argument respects 2 or more words separated by a space
# it supports accentuated characters and names with hyphen(-)
# @arg $1 firstNameLastName:String
# @exitcode 1 if regexp not matches
# @see https://regex101.com/r/JyyfOM/1
Assert::firstNameLastName() {
  local regexp="^[^ ]+([ ][^ ]+)+$"
  [[ $1 =~ ${regexp} ]]
}

# @description check if argument respects ldap login naming convention
# only using lowercase characters a-z
# @arg $1 ldapLogin:String
# @exitcode 1 if regexp not matches
Assert::ldapLogin() {
  [[ $1 =~ ^[a-z]+$ ]]
}

# @description checks if variable name provided exists
# @arg $1 varName:String
# @exitcode 1 if variable doesn't exist
# @exitcode 2 if variable value empty
# @exitcode 3 if variable name invalid
# @see Assert::validVariableName
# @stderr diagnostics information is displayed
Assert::varExistsAndNotEmpty() {
  local varName="$1"
  if ! Assert::validVariableName "${varName}"; then
    Log::displayError "${varName} - invalid variable name"
    return 3
  fi
  if [[ -z "${!varName+unset}" ]]; then
    Log::displayError "${varName} - not defined"
    return 1
  elif [[ -z "${!varName}" ]]; then
    Log::displayError "${varName} - please provide a value"
    return 2
  fi
}

# @description determine if the script is executed under WSL
# cspell:disable
# @example text
#   uname GitBash windows (with wsl) => MINGW64_NT-10.0 ZOXFL-6619QN2 2.10.0(0.325/5/3) 2018-06-13 23:34 x86_64 Msys
#   uname GitBash windows (wo wsl)   => MINGW64_NT-10.0 frsa02-j5cbkc2 2.9.0(0.318/5/3) 2018-01-12 23:37 x86_64 Msys
#   uname wsl => Linux ZOXFL-6619QN2 4.4.0-17134-Microsoft #112-Microsoft Thu Jun 07 22:57:00 PST 2018 x86_64 x86_64 x86_64 GNU/Linux
# cspell:enable
#
# @exitcode 1 on error
Assert::wsl() {
  [[ "$(uname -o)" = "GNU/Linux" ]]
}

# @description delete files older than n days in given path
# @warning use this function with caution as it will delete all files in given path without any prompt
# @arg $1 path:String the directory in which files will be deleted or the file to delete
# @arg $2 mtime:String expiration time in days (eg: 1 means 1 day) (default value: 1). Eg: +1 match files that have been accessed at least two days ago (rounding effect)
# @arg $3 maxdepth:int Descend at most levels (a non-negative integer) levels of directories below the starting-points. (default value: 1)
# @exitcode 1 if path not provided or empty
# @exitcode * find command failure code
# @stderr find output on error or diagnostics logs
# @see man find atime
File::garbageCollect() {
  local path="$1"
  local mtime="$2"
  local maxdepth="${3:-1}"

  if [[ -z "${path}" ]]; then
    return 1
  fi

  if [[ ! -e "${path}" ]]; then
    # path already removed
    return 0
  fi

  Log::displayInfo "Garbage collect files older than ${mtime} days in path ${path} with max depth ${maxdepth}"
  find "${path}" -depth -maxdepth "${maxdepth}" -type f -mtime "${mtime}" -print -delete
}

# @description retrieve path from wslvar and then use wslpath to resolve it
# using cache (cache is refreshed every day)
# @arg $1 var:String the var to retrieve using wslvar
# @arg $@ args:String[] (optional) additional arguments to pass to wslvar
# @env WSL_TMPDIR String temp directory to store the wslpath cache (default value: TMPDIR), you can use PERSISTENT_TMPDIR instead
# @exitcode * if Linux::Wsl::originalWslpath cannot find the path or Linux::Wsl::originalWslvar cannot find the var
# @stderr diagnostics information is displayed
# @require Linux::Wsl::requireWsl
# @feature cache
Linux::Wsl::cachedWslpathFromWslVar() {
  local var="$1"
  shift || true
  local value
  value="$(Linux::Wsl::cachedWslvar "${var}" "$@")" || return 1
  Linux::Wsl::cachedWslpath "${value}" || return 1
}

# @description retrieve wslvar using cache (cache is refreshed every day)
# @arg $@ args:String[] arguments to pass to wslvar
# @env WSL_TMPDIR String temp directory to store the wslvar cache (default value: TMPDIR), you can use PERSISTENT_TMPDIR instead
# @exitcode * if Linux::Wsl::originalWslvar cannot find the variable
# @stderr diagnostics information is displayed
# @require Linux::Wsl::requireWsl
# @feature cache
Linux::Wsl::cachedWslvar() {
  local tempEnvFile
  tempEnvFile="${WSL_TMPDIR:-${PERSISTENT_TMPDIR:-/tmp}}/bash_tools_wslvar_$(id -un)"

  Cache::getPropertyValue "${tempEnvFile}" "$1" Linux::Wsl::originalWslvar "$@"
}

# @description retrieve linux distributor id
# @noargs
# @exitcode 1 if lsb_release fails or not found
# @stdout the linux distributor id
Linux::getDistributorId() {
  lsb_release -a 2>/dev/null | sed -En 's/Distributor ID:[ \t]+(.+)/\1/p'
}

# @description Display message using skip color (yellow)
# @arg $1 message:String the message to display
Log::displaySkipped() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__SKIPPED_COLOR}SKIPPED - ${LOG_LAST_DURATION_STR}${1}${__RESET_COLOR}" >&2
  fi
  Log::logSkipped "$1"
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logStatus() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_WARNING)); then
    Log::logMessage "${2:-STATUS}" "$1"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logSuccess() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-SUCCESS}" "$1"
  fi
}

# @description extract stats form log
# @arg $1 logFile:String the log file to parse
# @arg $2 status:int the status of the command associated to that log file
# @arg $3 duration:int the duration  of the command associated to that log file
# @stdout output with the format provided by this example src/Stats/aggregateStats.example
# @see src/Stats/aggregateStats.example
Stats::computeFromLog() {
  local logFile="$1"
  local status="$2"
  local duration="$3"

  local logStatsAwkScript
  logStatsAwkScript="$(
    cat <<'EOF'
BEGIN {
  error=0
  warning=0
  skipped=0
  help=0
  success=0
}
{
  buffer = substr($0, 1, 20)
  if(match(buffer, /(ERROR)[ ]+- /, arr) != 0) {
    error+=1
  } else if(match(buffer, /(WARNING)[ ]+- /, arr) != 0) {
    warning+=1
  } else if(match(buffer, /(SKIPPED)[ ]+- /, arr) != 0) {
    skipped+=1
  } else if(match(buffer, /(ERROR)[ ]+- /, arr) != 0) {
    error+=1
  } else if(match(buffer, /(HELP)[ ]+- /, arr) != 0) {
    help+=1
  } else if(match(buffer, /(SUCCESS)[ ]+- /, arr) != 0) {
    success+=1
  }

}
END {
  print "error=" error
  print "warning=" warning
  print "skipped=" skipped
  print "help=" help
  print "success=" success
}
EOF
  )"

  if [[ -f "${logFile}" ]]; then
    awk --source "${logStatsAwkScript}" "${logFile}"
    echo "status=${status}"
    echo "duration=${duration}"
  else
    # not executed
    echo "status=-1"
  fi
}

# @description Display given text and complete the rest of the line with given character
# @arg $1 text:String text to display
# @arg $2 character:String (default:#) character to use to complete the line
UI::textLine() {
  local text="$1"
  local character="${2:-#}"
  ((textSize = ${#text}))
  ((fullWith = $(tput cols)))
  ((remainingWidth = $((fullWith - textSize))))
  echo -n "${text}"
  printf '%*s\n' "${remainingWidth}" '' | tr ' ' "${character}"
}

# @description check if argument respects this framework variable naming convention
# - if variable begins with an uppercase or underscore, following letters have to be uppercase or underscore
# - variable name can includes ':' or '_' or digits but not as first letter
# here valid variable name examples
#
# @arg $1 variableName:String
# @exitcode 1 if regexp not matches
# @see https://regex101.com/r/BUlPXS/1
Assert::validVariableName() {
  echo "$1" | LC_ALL=POSIX grep -E -q '(^[a-z][A-Za-z_0-9:]+$)|(^[A-Z_][A-Z_0-9:]+$)'
}

# @description call simply original wslvar command
# @arg $@ args:String[] args to pass to wslvar
# @exitcode * wslvar exit code
# @stdout wslvar stdout
# @require Linux::Wsl::requireWsl
Linux::Wsl::originalWslvar() {
  wslvar "$@" | sed -z '$ s/[\r\n]$//'
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logSkipped() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-SKIPPED}" "$1"
  fi
}

# FUNCTIONS

Compiler::Embed::extractDirFromBase64 "${TMPDIR:-/tmp}/conf_dir" "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"

declare -gx embed_dir_conf_dir="${TMPDIR:-/tmp}/conf_dir"

facade_main_ShellBashsh() {

# REQUIRES
Linux::requireTarCommand
Linux::requireUbuntu
Linux::Wsl::requireWsl
Env::requireLoad
UI::requireTheme
Log::requireLoad
Compiler::Facade::requireCommandBinDir

if Assert::functionExists initFacade; then
  initFacade
fi
Engine::Config::loadConfig
# @description create sudoer file and add traps to remove it at the end
# @arg $1 sudoerFile:String the file path to create
# @env USERNAME
# shellcheck disable=SC2317
local sudoerFile="${SUDOER_FILE_PREFIX}/etc/sudoers.d/bash-dev-env-no-password"
if [[ -f "${sudoerFile}" ]]; then
  # sudoerFile probably already managed by parent script
  true
else
  cleanSudoer() {
    local rc=$?
    if [[ -f "${sudoerFile}" ]]; then
      ${SUDO:-sudo} rm -f "${sudoerFile}" || true
    fi
    exit "${rc}"
  }
  trap cleanSudoer EXIT HUP QUIT ABRT TERM

  Log::displayInfo "Creating sudoer file"
  echo "${USERNAME} ALL=(ALL) NOPASSWD: ALL" |
    ${SUDO:-sudo} tee "${sudoerFile}" >/dev/null
  ${SUDO:-sudo} chmod 0440 "${sudoerFile}"
fi

# @require Compiler::Facade::requireCommandBinDir
# ROOT_DIR_RELATIVE_TO_BIN_DIR=..
# FACADE
# IMPLEMENT InstallScripts::interface
# EMBED "${BASH_DEV_ENV_ROOT_DIR}/src/_binaries/ShellBash/conf" as conf_dir

declare -a BASH_FRAMEWORK_ARGV_FILTERED=()

copyrightCallback() {
  if [[ -z "${copyrightBeginYear}" ]]; then
    copyrightBeginYear="$(date +%Y)"
  fi
  echo "Copyright (c) ${copyrightBeginYear}-now François Chastanet"
}

# shellcheck disable=SC2317 # if function is overridden
updateArgListInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--verbose)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListTraceVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vvv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListEnvFileCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListLogLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListDisplayLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListNoColorCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--no-color)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListThemeCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListQuietCallback() { :; }

# shellcheck disable=SC2317 # if function is overridden
optionHelpCallback() {
  installScriptCommand help
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionVersionCallback() {
  echo "${SCRIPT_NAME} version 1.0"
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionEnvFileCallback() {
  local envFile="$2"
  Log::displayWarning "Command ${SCRIPT_NAME} - Option --env-file is deprecated and will be removed in the future"
  if [[ ! -f "${envFile}" || ! -r "${envFile}" ]]; then
    Log::displayError "Command ${SCRIPT_NAME} - Option --env-file - File '${envFile}' doesn't exist"
    exit 1
  fi
}

# shellcheck disable=SC2317 # if function is overridden
optionInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='--verbose'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_INFO}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_INFO}" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_DEBUG}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionTraceVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vvv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_TRACE}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}" >> "${overrideEnvFile}"
}

getLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__LEVEL_OFF}"
      ;;
    ERR | ERROR)
      echo "${__LEVEL_ERROR}"
      ;;
    WARN | WARNING)
      echo "${__LEVEL_WARNING}"
      ;;
    INFO)
      echo "${__LEVEL_INFO}"
      ;;
    DEBUG | TRACE)
      echo "${__LEVEL_DEBUG}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
  esac
}

getVerboseLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__VERBOSE_LEVEL_OFF}"
      ;;
    ERR | ERROR | WARN | WARNING | INFO)
      echo "${__VERBOSE_LEVEL_INFO}"
      ;;
    DEBUG)
      echo "${__VERBOSE_LEVEL_DEBUG}"
      ;;
    TRACE)
      echo "${__VERBOSE_LEVEL_TRACE}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
  esac
}

# shellcheck disable=SC2317 # if function is overridden
optionDisplayLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${logLevel}" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionLogLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  echo "BASH_FRAMEWORK_LOG_LEVEL=${logLevel}" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionLogFileCallback() {
  local logFile="$2"
  echo "BASH_FRAMEWORK_LOG_FILE='${logFile}'" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionQuietCallback() {
  echo "BASH_FRAMEWORK_QUIET_MODE=1" >> "${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionNoColorCallback() {
  UI::theme "noColor"
}

# shellcheck disable=SC2317 # if function is overridden
optionThemeCallback() {
  UI::theme "$2"
}

displayConfig() {
  echo "Config"
  UI::drawLine "-"
  local var
  while read -r var; do
    printf '%-40s = %s\n' "${var}" "$(declare -p "${var}" | sed -E -e 's/^[^=]+=(.*)/\1/')"
  done < <(typeset -p | awk 'match($3, "^(BASH_FRAMEWORK_[^=]+)=", m) { print m[1] }' | sort)
  exit 0
}

optionBashFrameworkConfigCallback() {
  if [[ ! -f "$2" ]]; then
    Log::fatal "Command ${SCRIPT_NAME} - Bash framework config file '$2' does not exists"
  fi
}

defaultFrameworkConfig="$(
  cat <<'EOF'
# copied from src/_includes/.framework-config.default
# shellcheck disable=SC2034

REAL_SCRIPT_FILE="${REAL_SCRIPT_FILE:-$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")}"
FRAMEWORK_ROOT_DIR="${FRAMEWORK_ROOT_DIR:-$(cd "$(readlink -e "${REAL_SCRIPT_FILE%/*}")/../.." && pwd -P)}"
FRAMEWORK_SRC_DIR="${FRAMEWORK_SRC_DIR:-${FRAMEWORK_ROOT_DIR}/src}"
FRAMEWORK_BIN_DIR="${FRAMEWORK_BIN_DIR:-${FRAMEWORK_ROOT_DIR}/bin}"
FRAMEWORK_VENDOR_DIR="${FRAMEWORK_VENDOR_DIR:-${FRAMEWORK_ROOT_DIR}/vendor}"
FRAMEWORK_VENDOR_BIN_DIR="${FRAMEWORK_VENDOR_BIN_DIR:-${FRAMEWORK_ROOT_DIR}/vendor/bin}"

# describe the functions that will be skipped from being imported
FRAMEWORK_FUNCTIONS_IGNORE_REGEXP="${FRAMEWORK_FUNCTIONS_IGNORE_REGEXP:-^(Namespace::functions|Functions::myFunction|Namespace::requireSomething|Acquire::ForceIPv4)$}"
# describe the files that do not contain function to be imported
NON_FRAMEWORK_FILES_REGEXP="${NON_FRAMEWORK_FILES_REGEXP:-(^bin/|.framework-config|.bats$|/testsData/|^manualTests/|/_.sh$|/ZZZ.sh$|/__all.sh$|^src/_binaries|^src/_includes|^src/batsHeaders.sh$|^src/_standalone)}"
# describe the files that are allowed to not have an associated bats file
BATS_FILE_NOT_NEEDED_REGEXP="${BATS_FILE_NOT_NEEDED_REGEXP:-(^bin/|.framework-config|.bats$|/testsData/|^manualTests/|/_.sh$|/ZZZ.sh$|/__all.sh$|^src/batsHeaders.sh$|^src/_includes)}"
# describe the files that are allowed to not have a function matching the filename
FRAMEWORK_FILES_FUNCTION_MATCHING_IGNORE_REGEXP="${FRAMEWORK_FILES_FUNCTION_MATCHING_IGNORE_REGEXP:-^bin/|^\.framework-config$|\.tpl$|/testsData/|^manualTests/|\.bats$}"
# Source directories
if [[ ! -v FRAMEWORK_SRC_DIRS ]]; then
  FRAMEWORK_SRC_DIRS=(
    "${FRAMEWORK_ROOT_DIR}/src"
  )
fi

# export here all the variables that will be used in your templates
export REPOSITORY_URL="${REPOSITORY_URL:-https://github.com/fchastanet/bash-tools-framework}"

BASH_FRAMEWORK_THEME="${BASH_FRAMEWORK_THEME:-default}"
BASH_FRAMEWORK_LOG_LEVEL="${BASH_FRAMEWORK_LOG_LEVEL:-0}"
BASH_FRAMEWORK_DISPLAY_LEVEL="${BASH_FRAMEWORK_DISPLAY_LEVEL:-3}"
BASH_FRAMEWORK_LOG_FILE="${BASH_FRAMEWORK_LOG_FILE:-${FRAMEWORK_ROOT_DIR}/logs/$(basename "$0").log}"
BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION="${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION:-5}"
EOF
)"

overrideEnvFile="$(Framework::createTempFile "overrideEnvFile")"

commandOptionParseFinished() {
  # load default template framework config
  defaultEnvFile="${PERSISTENT_TMPDIR}/.framework-config"
  echo "${defaultFrameworkConfig}" > "${defaultEnvFile}"
  local -a files=("${defaultEnvFile}")
  if [[ -f "${envFile}" ]]; then
    files+=("${envFile}")
  fi
  # shellcheck disable=SC2154
  if [[ -f "${optionBashFrameworkConfig}" ]]; then
    files+=("${optionBashFrameworkConfig}")
  fi
  files+=("${overrideEnvFile}")
  Env::requireLoad "${files[@]}"
  Log::requireLoad
  # shellcheck disable=SC2154
  if [[ "${optionConfig}" = "1" ]]; then
    displayConfig
  fi
}

export SKIP_INSTALL
export SKIP_CONFIGURE
export SKIP_TEST
export SKIP_DEPENDENCIES

installScriptCommand() {
  local options_parse_cmd="$1"
  shift || true

  if [[ "${options_parse_cmd}" = "parse" ]]; then
    SKIP_CONFIGURE="0"
    local -i options_parse_optionParsedCountSKIP_CONFIGURE
    ((options_parse_optionParsedCountSKIP_CONFIGURE = 0)) || true
    SKIP_INSTALL="0"
    local -i options_parse_optionParsedCountSKIP_INSTALL
    ((options_parse_optionParsedCountSKIP_INSTALL = 0)) || true
    SKIP_TEST="0"
    local -i options_parse_optionParsedCountSKIP_TEST
    ((options_parse_optionParsedCountSKIP_TEST = 0)) || true
    SKIP_DEPENDENCIES="0"
    local -i options_parse_optionParsedCountSKIP_DEPENDENCIES
    ((options_parse_optionParsedCountSKIP_DEPENDENCIES = 0)) || true
    local -i options_parse_optionParsedCountOptionBashFrameworkConfig
    ((options_parse_optionParsedCountOptionBashFrameworkConfig = 0)) || true
    optionConfig="0"
    local -i options_parse_optionParsedCountOptionConfig
    ((options_parse_optionParsedCountOptionConfig = 0)) || true
    optionInfoVerbose="0"
    local -i options_parse_optionParsedCountOptionInfoVerbose
    ((options_parse_optionParsedCountOptionInfoVerbose = 0)) || true
    optionDebugVerbose="0"
    local -i options_parse_optionParsedCountOptionDebugVerbose
    ((options_parse_optionParsedCountOptionDebugVerbose = 0)) || true
    optionTraceVerbose="0"
    local -i options_parse_optionParsedCountOptionTraceVerbose
    ((options_parse_optionParsedCountOptionTraceVerbose = 0)) || true
    optionNoColor="0"
    local -i options_parse_optionParsedCountOptionNoColor
    ((options_parse_optionParsedCountOptionNoColor = 0)) || true
    optionTheme="default"
    local -i options_parse_optionParsedCountOptionTheme
    ((options_parse_optionParsedCountOptionTheme = 0)) || true
    optionHelp="0"
    local -i options_parse_optionParsedCountOptionHelp
    ((options_parse_optionParsedCountOptionHelp = 0)) || true
    optionVersion="0"
    local -i options_parse_optionParsedCountOptionVersion
    ((options_parse_optionParsedCountOptionVersion = 0)) || true
    optionQuiet="0"
    local -i options_parse_optionParsedCountOptionQuiet
    ((options_parse_optionParsedCountOptionQuiet = 0)) || true
    local -i options_parse_optionParsedCountOptionLogLevel
    ((options_parse_optionParsedCountOptionLogLevel = 0)) || true
    local -i options_parse_optionParsedCountOptionLogFile
    ((options_parse_optionParsedCountOptionLogFile = 0)) || true
    local -i options_parse_optionParsedCountOptionDisplayLevel
    ((options_parse_optionParsedCountOptionDisplayLevel = 0)) || true
    # shellcheck disable=SC2034
    local -i options_parse_parsedArgIndex=0
    while (($# > 0)); do
      local options_parse_arg="$1"
      local argOptDefaultBehavior=0
      case "${options_parse_arg}" in
        # Option 1/18
        # Option SKIP_CONFIGURE --skip-config|--skip-configure|--skip-configuration variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --skip-config | --skip-configure | --skip-configuration)
          # shellcheck disable=SC2034
          SKIP_CONFIGURE="1"
          if ((options_parse_optionParsedCountSKIP_CONFIGURE >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountSKIP_CONFIGURE))
          ;;
        # Option 2/18
        # Option SKIP_INSTALL --skip-install|--skip-installation variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --skip-install | --skip-installation)
          # shellcheck disable=SC2034
          SKIP_INSTALL="1"
          if ((options_parse_optionParsedCountSKIP_INSTALL >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountSKIP_INSTALL))
          ;;
        # Option 3/18
        # Option SKIP_TEST --skip-test|--skip-tests variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --skip-test | --skip-tests)
          # shellcheck disable=SC2034
          SKIP_TEST="1"
          if ((options_parse_optionParsedCountSKIP_TEST >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountSKIP_TEST))
          ;;
        # Option 4/18
        # Option SKIP_DEPENDENCIES --skip-dependencies|--skip-deps variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --skip-dependencies | --skip-deps)
          # shellcheck disable=SC2034
          SKIP_DEPENDENCIES="1"
          if ((options_parse_optionParsedCountSKIP_DEPENDENCIES >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountSKIP_DEPENDENCIES))
          ;;
        # Option 5/18
        # Option optionBashFrameworkConfig --bash-framework-config variableType String min 0 max 1 authorizedValues '' regexp ''
        --bash-framework-config)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionBashFrameworkConfig >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionBashFrameworkConfig))
          # shellcheck disable=SC2034
          optionBashFrameworkConfig="$1"
          optionBashFrameworkConfigCallback "${options_parse_arg}" "${optionBashFrameworkConfig}"
          ;;
        # Option 6/18
        # Option optionConfig --config variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --config)
          # shellcheck disable=SC2034
          optionConfig="1"
          if ((options_parse_optionParsedCountOptionConfig >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionConfig))
          ;;
        # Option 7/18
        # Option optionInfoVerbose --verbose|-v variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --verbose | -v)
          # shellcheck disable=SC2034
          optionInfoVerbose="1"
          if ((options_parse_optionParsedCountOptionInfoVerbose >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionInfoVerbose))
          optionInfoVerboseCallback "${options_parse_arg}"
          updateArgListInfoVerboseCallback "${options_parse_arg}"
          ;;
        # Option 8/18
        # Option optionDebugVerbose -vv variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        -vv)
          # shellcheck disable=SC2034
          optionDebugVerbose="1"
          if ((options_parse_optionParsedCountOptionDebugVerbose >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionDebugVerbose))
          optionDebugVerboseCallback "${options_parse_arg}"
          updateArgListDebugVerboseCallback "${options_parse_arg}"
          ;;
        # Option 9/18
        # Option optionTraceVerbose -vvv variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        -vvv)
          # shellcheck disable=SC2034
          optionTraceVerbose="1"
          if ((options_parse_optionParsedCountOptionTraceVerbose >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionTraceVerbose))
          optionTraceVerboseCallback "${options_parse_arg}"
          updateArgListTraceVerboseCallback "${options_parse_arg}"
          ;;
        # Option 10/18
        # Option optionEnvFiles --env-file variableType StringArray min 0 max -1 authorizedValues '' regexp ''
        --env-file)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionEnvFiles))
          optionEnvFiles+=("$1")
          optionEnvFileCallback "${options_parse_arg}" "${optionEnvFiles[@]}"
          updateArgListEnvFileCallback "${options_parse_arg}" "${optionEnvFiles[@]}"
          ;;
        # Option 11/18
        # Option optionNoColor --no-color variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --no-color)
          # shellcheck disable=SC2034
          optionNoColor="1"
          if ((options_parse_optionParsedCountOptionNoColor >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionNoColor))
          optionNoColorCallback "${options_parse_arg}"
          updateArgListNoColorCallback "${options_parse_arg}"
          ;;
        # Option 12/18
        # Option optionTheme --theme variableType String min 0 max 1 authorizedValues 'default|default-force|noColor' regexp ''
        --theme)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ default|default-force|noColor ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(default|default-force|noColor)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionTheme >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionTheme))
          # shellcheck disable=SC2034
          optionTheme="$1"
          optionThemeCallback "${options_parse_arg}" "${optionTheme}"
          updateArgListThemeCallback "${options_parse_arg}" "${optionTheme}"
          ;;
        # Option 13/18
        # Option optionHelp --help|-h variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --help | -h)
          # shellcheck disable=SC2034
          optionHelp="1"
          if ((options_parse_optionParsedCountOptionHelp >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionHelp))
          optionHelpCallback "${options_parse_arg}"
          ;;
        # Option 14/18
        # Option optionVersion --version variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --version)
          # shellcheck disable=SC2034
          optionVersion="1"
          if ((options_parse_optionParsedCountOptionVersion >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionVersion))
          optionVersionCallback "${options_parse_arg}"
          ;;
        # Option 15/18
        # Option optionQuiet --quiet|-q variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --quiet | -q)
          # shellcheck disable=SC2034
          optionQuiet="1"
          if ((options_parse_optionParsedCountOptionQuiet >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionQuiet))
          optionQuietCallback "${options_parse_arg}"
          updateArgListQuietCallback "${options_parse_arg}"
          ;;
        # Option 16/18
        # Option optionLogLevel --log-level variableType String min 0 max 1 authorizedValues 'OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE' regexp ''
        --log-level)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionLogLevel >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionLogLevel))
          # shellcheck disable=SC2034
          optionLogLevel="$1"
          optionLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"
          updateArgListLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"
          ;;
        # Option 17/18
        # Option optionLogFile --log-file variableType String min 0 max 1 authorizedValues '' regexp ''
        --log-file)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionLogFile >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionLogFile))
          # shellcheck disable=SC2034
          optionLogFile="$1"
          optionLogFileCallback "${options_parse_arg}" "${optionLogFile}"
          updateArgListLogFileCallback "${options_parse_arg}" "${optionLogFile}"
          ;;
        # Option 18/18
        # Option optionDisplayLevel --display-level variableType String min 0 max 1 authorizedValues 'OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE' regexp ''
        --display-level)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionDisplayLevel >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionDisplayLevel))
          # shellcheck disable=SC2034
          optionDisplayLevel="$1"
          optionDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"
          updateArgListDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"
          ;;
        -*)
          if [[ "${argOptDefaultBehavior}" = "0" ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Invalid option ${options_parse_arg}"
            return 1
          fi
          ;;
        *)
          if [[ "${argOptDefaultBehavior}" = "0" ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Argument - too much arguments provided"
            return 1
          fi
          ;;
      esac
      shift || true
    done
    commandOptionParseFinished
    InstallScripts::command
    Log::displayDebug "Command ${SCRIPT_NAME} - parse arguments: ${BASH_FRAMEWORK_ARGV[*]}"
    Log::displayDebug "Command ${SCRIPT_NAME} - parse filtered arguments: ${BASH_FRAMEWORK_ARGV_FILTERED[*]}"
  elif [[ "${options_parse_cmd}" = "help" ]]; then
    Array::wrap2 ' ' 80 0 "\e[1;37mDESCRIPTION:\e[0m" "$(helpDescriptionCallback)"
    echo

    echo -e "$(Array::wrap2 " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" "${SCRIPT_NAME}" "[OPTIONS]")"
    echo -e "$(Array::wrap2 " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" \
      "${SCRIPT_NAME}" \
      "[--skip-config|--skip-configure|--skip-configuration]" "[--skip-install|--skip-installation]" "[--skip-test|--skip-tests]" "[--skip-dependencies|--skip-deps]" "[--bash-framework-config <String>]" "[--config]" "[--verbose|-v]" "[-vv]" "[-vvv]" "[--env-file <String>]" "[--no-color]" "[--theme <String>]" "[--help|-h]" "[--version]" "[--quiet|-q]" "[--log-level <String>]" "[--log-file <String>]" "[--display-level <String>]")"
    echo
    echo -e "${__HELP_TITLE_COLOR}OPTIONS:${__RESET_COLOR}"
    echo -e "  ${__HELP_OPTION_COLOR}--skip-config${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-configure${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-configuration${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(skip\ software\ configuration)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--skip-install${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-installation${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(skip\ software\ installation)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--skip-test${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-tests${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(skip\ software\ installation\ test)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--skip-dependencies${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}--skip-deps${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(install\ the\ software\ requested\ without\ resolving\ dependencies)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo
    echo -e "${__HELP_TITLE_COLOR}GLOBAL OPTIONS:${__RESET_COLOR}"
    echo -e "  ${__HELP_OPTION_COLOR}--bash-framework-config <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(use\ alternate\ bash\ framework\ configuration.)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--config${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Display\ configuration)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--verbose${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-v${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(info\ level\ verbose\ mode\ \(alias\ of\ --display-level\ INFO\))
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}-vv${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(debug\ level\ verbose\ mode\ \(alias\ of\ --display-level\ DEBUG\))
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}-vvv${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(trace\ level\ verbose\ mode\ \(alias\ of\ --display-level\ TRACE\))
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--env-file <String>${__HELP_NORMAL} {list} (optional)"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Load\ the\ specified\ env\ file\ \(deprecated\,\ please\ use\ --bash-framework-config\ option\ instead\))
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--no-color${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Produce\ monochrome\ output.\ alias\ of\ --theme\ noColor.)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--theme <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(choose\ color\ theme\ -\ default-force\ means\ colors\ will\ be\ produced\ even\ if\ command\ is\ piped)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo '    Default value: default'
    echo '    Possible values: default|default-force|noColor'
    echo -e "  ${__HELP_OPTION_COLOR}--help${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-h${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Display\ this\ command\ help)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--version${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Print\ version\ information\ and\ quit)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--quiet${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-q${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(quiet\ mode\,\ doesn\'t\ display\ any\ output)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--log-level <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Set\ log\ level)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo '    Possible values: OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE'
    echo -e "  ${__HELP_OPTION_COLOR}--log-file <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Set\ log\ file)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--display-level <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(set\ display\ level)
    echo -e "    $(Array::wrap2 " " 76 4 "${helpArray[@]}")"
    echo '    Possible values: OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE'
    Array::wrap2 ' ' 76 0 "$(helpLongDescriptionCallback)"
    echo
    echo -n -e "${__HELP_TITLE_COLOR}VERSION: ${__RESET_COLOR}"
    echo '1.0'
    echo
    echo -e "${__HELP_TITLE_COLOR}AUTHOR:${__RESET_COLOR}"
    echo '[François Chastanet](https://github.com/fchastanet)'
    echo
    echo -e "${__HELP_TITLE_COLOR}SOURCE FILE:${__RESET_COLOR}"
    echo 'https://github.com/fchastanet/bash-dev-env/tree/master/src/_binaries/ShellBash/ShellBash.sh'
    echo
    echo -e "${__HELP_TITLE_COLOR}LICENSE:${__RESET_COLOR}"
    echo 'MIT License'
    echo
    Array::wrap2 ' ' 76 4 "$(copyrightCallback)"
  else
    Log::displayError "Command ${SCRIPT_NAME} - Option command invalid: '${options_parse_cmd}'"
    return 1
  fi
}

# default action called by the facade if no interface action recognized
defaultFacadeAction() {
  installScriptCommand parse "${BASH_FRAMEWORK_ARGV[@]}"
}

stringOrNone() {
  local string="$1"
  echo -e "${string:-${__HELP_EXAMPLE}None${__HELP_NORMAL}}"
}

helpDescriptionCallback() {
  helpDescription
  echo
}

helpLongDescriptionCallback() {
  helpDescription
  echo

  echo -e "${__HELP_TITLE}List of needed variables:${__HELP_NORMAL}"
  stringOrNone "$(helpVariables)"

  echo -e "${__HELP_TITLE}List of dependencies:${__HELP_NORMAL}"
  stringOrNone "$(dependencies)"
}

isInstallImplemented() {
  ! InstallScripts::scriptFunctionEmpty install
}

isTestInstallImplemented() {
  ! InstallScripts::scriptFunctionEmpty testInstall
}

isConfigureImplemented() {
  ! InstallScripts::scriptFunctionEmpty configure
}

isTestConfigureImplemented() {
  ! InstallScripts::scriptFunctionEmpty testConfigure
}

scriptName() {
  echo "ShellBash"
}

helpDescription() {
  echo "ShellBash"
}

dependencies() {
  echo Fasd
  echo Fzf
  echo Kubectx
  echo Kubeps1
  # font needed for displaying bash prompt
  echo Font
  echo Vim
}

# jscpd:ignore-start
helpVariables() { :; }
listVariables() { :; }
defaultVariables() { :; }
checkVariables() { :; }
breakOnConfigFailure() { :; }
breakOnTestFailure() { :; }
# jscpd:ignore-end

fortunes() {
  local currentUserShell
  currentUserShell="$(grep "^${USERNAME}:" /etc/passwd | awk -F ":" '{print $7}')"
  if [[ "${currentUserShell}" = "/usr/bin/bash" ]]; then
    if command -v zsh &>/dev/null; then
      fortunes+=("Bash is set as default shell, you can switch to zsh using 'chsh -s /usr/bin/zsh'")
    fi
  fi
}

install() {
  Linux::Apt::update
  Linux::Apt::install \
    bash-completion
}

testInstall() {
  Assert::fileExists /etc/profile.d/bash_completion.sh root root || return 1
}

configure() {
  if [[ "${PREFERRED_SHELL}" = "ShellBash" ]]; then
    CURRENT_USER_SHELL="$(grep "^${USERNAME}:" /etc/passwd | awk -F ":" '{print $7}')"
    if [[ "${CURRENT_USER_SHELL}" != "/bin/bash" ]]; then
      usermod --shell /bin/bash "${USERNAME}"
      Log::displayHelp "You have to log in/log out to make bash by default"
    fi
    if command -v zsh &>/dev/null; then
      Log::displayHelp "Bash is set as default shell, you can switch back to zsh using 'chsh -s /usr/bin/zsh'"
    fi
  fi

  mkdir -p "${USER_HOME}/.bash-dev-env/interactive.d" || return 1
  Retry::default curl -o "${USER_HOME}/.bash-dev-env/interactive.d/git-prompt.sh" \
    https://raw.githubusercontent.com/git/git/master/contrib/completion/git-prompt.sh || return 1

  # shellcheck disable=SC2154
  Conf::copyStructure \
    "${embed_dir_conf_dir}" \
    "${CONF_OVERRIDE_DIR}/$(scriptName)" \
    ".bash-dev-env"

  Conf::copyStructure \
    "${embed_dir_conf_dir}" \
    "${CONF_OVERRIDE_DIR}/$(scriptName)" \
    ".vscode"

  Conf::copyStructure \
    "${embed_dir_conf_dir}" \
    "${CONF_OVERRIDE_DIR}/$(scriptName)" \
    "home" \
    "${USER_HOME}"

  local configDir
  # shellcheck disable=SC2154
  configDir="$(Conf::getOverriddenDir "${embed_dir_conf_dir}" "${CONF_OVERRIDE_DIR}/$(scriptName)")"

  SUDO=sudo OVERWRITE_CONFIG_FILES=0 Install::file \
    "${configDir}/home/.vimrc" "/root/.vimrc" root root
  SUDO=sudo OVERWRITE_CONFIG_FILES=0 Install::file \
    "${configDir}/home/.inputrc" "/root/.inputrc" root root

  # disable bell
  sudo sed -i -e 's/;set bell-style none/set bell-style none/g' /etc/inputrc

}

testConfigure() {
  local -i failures=0
  Assert::fileExists "${USER_HOME}/.bash-dev-env/interactive.d/git-prompt.sh" || ((++failures))

  Assert::fileExists "${USER_HOME}/.bash_logout" || ((++failures))
  Assert::fileExists "${USER_HOME}/.bashrc" || ((++failures))
  Assert::fileExists "${USER_HOME}/.dir_colors" || ((++failures))
  Assert::fileExists "${USER_HOME}/.inputrc" || ((++failures))
  Assert::fileExists "${USER_HOME}/.profile" || ((++failures))
  Assert::fileExists "${USER_HOME}/.vimrc" || ((++failures))
  Assert::fileExists "${USER_HOME}/.Xresources" || ((++failures))

  SUDO=sudo Assert::fileExists /root/.vimrc root root || ((++failures))
  SUDO=sudo Assert::fileExists /root/.inputrc root root || ((++failures))

  Assert::fileExists "${USER_HOME}/.bash-dev-env/aliases.d/colors.sh" || ((++failures))
  Assert::fileExists "${USER_HOME}/.bash-dev-env/aliases.d/filesDirectory.sh" || ((++failures))
  Assert::fileExists "${USER_HOME}/.bash-dev-env/aliases.d/miscellaneous.sh" || ((++failures))
  Assert::fileExists "${USER_HOME}/.bash-dev-env/aliases.d/ssh.sh" || ((++failures))
  Assert::fileExists "${USER_HOME}/.bash-dev-env/aliases.d/xserver.sh" || ((++failures))
  Assert::fileExists "${USER_HOME}/.bash-dev-env/aliases.d/DISCLAIMER.md" || ((++failures))

  Assert::fileExists "${USER_HOME}/.bash-dev-env/completions.d/makeTargets.sh" || ((++failures))
  Assert::fileExists "${USER_HOME}/.bash-dev-env/completions.d/DISCLAIMER.md" || ((++failures))

  Assert::fileExists "${USER_HOME}/.bash-dev-env/interactive.d/00_bash_prompt.sh" || ((++failures))
  Assert::fileExists "${USER_HOME}/.bash-dev-env/interactive.d/bash_navigation.sh" || ((++failures))
  Assert::fileExists "${USER_HOME}/.bash-dev-env/interactive.d/DISCLAIMER.md" || ((++failures))

  Assert::fileExists "${USER_HOME}/.bash-dev-env/profile.d/DISCLAIMER.md" || ((++failures))

  Assert::fileExists "${USER_HOME}/.vscode/argv.json" || ((++failures))
  Assert::fileExists "${USER_HOME}/.vscode/settings.json" || ((++failures))

  # check font in windows terminal configuration
  local terminalConfFile
  # cspell:ignore wekyb, bbwe
  terminalConfFile="${WINDOWS_PROFILE_DIR}/AppData/Local/Packages/Microsoft.WindowsTerminal_8wekyb3d8bbwe/LocalState/settings.json"
  if [[ -f "${terminalConfFile}" ]]; then
    if ! grep -q '"face": "MesloLGS NF"' "${terminalConfFile}"; then
      Log::displayHelp "Please change your terminal settings($(Linux::Wsl::cachedWslpath -w "${terminalConfFile}")) to use font 'MesloLGS NF' for wsl profile"
    fi
  else
    Log::displayHelp "please use windows terminal for better shell display results"
  fi

  return "${failures}"
}

local action=$1
shift || true
case ${action} in
  scriptName)
    scriptName "$@"
    ;;
  helpDescription)
    helpDescription "$@"
    ;;
  helpVariables)
    helpVariables "$@"
    ;;
  listVariables)
    listVariables "$@"
    ;;
  defaultVariables)
    defaultVariables "$@"
    ;;
  checkVariables)
    checkVariables "$@"
    ;;
  fortunes)
    fortunes "$@"
    ;;
  dependencies)
    dependencies "$@"
    ;;
  breakOnTestFailure)
    breakOnTestFailure "$@"
    ;;
  breakOnConfigFailure)
    breakOnConfigFailure "$@"
    ;;
  install)
    install "$@"
    ;;
  isInstallImplemented)
    isInstallImplemented "$@"
    ;;
  testInstall)
    testInstall "$@"
    ;;
  isTestInstallImplemented)
    isTestInstallImplemented "$@"
    ;;
  configure)
    configure "$@"
    ;;
  isConfigureImplemented)
    isConfigureImplemented "$@"
    ;;
  testConfigure)
    testConfigure "$@"
    ;;
  isTestConfigureImplemented)
    isTestConfigureImplemented "$@"
    ;;
  *)
    if Assert::functionExists defaultFacadeAction; then
      defaultFacadeAction "$1" "$@"
    else
      Log::displayError "invalid action requested: ${action}"
      exit 1
    fi
    ;;
esac
exit 0
}

facade_main_ShellBashsh "$@"
